
bin/scoreboard.elf:     file format elf32-msp430

SYMBOL TABLE:
0000c000 l    d  .text	00000000 .text
00000200 l    d  .data	00000000 .data
00000204 l    d  .bss	00000000 .bss
0000ffe0 l    d  .vectors	00000000 .vectors
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 main.c
0000c2ea l       .text	00000000 __br_unexpected_
00000000 l    df *ABS*	00000000 delay.c
00000000 l    df *ABS*	00000000 lcd_hal.c
0000c9c2 l     O .text	0000003b Rcmd1
0000c9fd l     O .text	0000000d Rcmd2green
0000ca17 l     O .text	0000002b Rcmd3
0000ca0a l     O .text	0000000d Rcmd2red
00000000 l    df *ABS*	00000000 lcd_gfx.c
0000e486 l     O .text	000004fb glcd_font
00000000 l    df *ABS*	00000000 glcdfont.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 sprintf.c
0000e9a2 l     F .text	00000022 append
00000206 l     O .bss	00000002 available_
00000204 l     O .bss	00000002 destination_
0000e9c4 l     F .text	0000003c call_vuprintf
00000000 l    df *ABS*	00000000 vuprintf.c
0000ea5e l     F .text	00000104 print_field
0000c344 g     F .text	00000010 putchar
00000004 g       *ABS*	00000000 __data_size
0000e440 g     F .text	0000002e lcd_gfx_setRotation
0000c2ea  w      .text	00000000 __isr_14
0000d4ae g     F .text	000000c2 lcd_gfx_drawFastVLine
0000d8ac g     F .text	00000082 lcd_gfx_fillRoundRect
0000e982 g     F .text	00000012 printf
0000ea36 g     F .text	00000016 vsprintf
0000c60a g     F .text	000000d2 lcd_init_screen
0000c2ea  w      .text	00000000 __isr_4
0000c4ba g     F .text	00000012 lcd_spiwrite_byte
00000138 g       *ABS*	00000000 __OP2
0000e330 g     F .text	000000ea lcd_gfx_print
0000c5be g     F .text	0000004c commonInit
00000218 g     O .bss	00000002 CONST_HEIGHT
0000c6dc g     F .text	00000176 lcd_setAddrWindow
0000ea1c g     F .text	0000001a snprintf
0000ef0a g       .text	00000000 __udivmodhi4
00000130 g       *ABS*	00000000 __MPY
0000c40c g     F .text	0000001a testprint
0000013a g       *ABS*	00000000 __RESLO
00000136 g       *ABS*	00000000 __MACS
0000ef58 g       *ABS*	00000000 _etext
00000214 g     O .bss	00000001 tabcolor
00000028 g       *ABS*	00000000 __bss_size
0000c4cc g     F .text	00000022 lcd_writecommand
0000ef52  w      .text	00000000 __stop_progExec__
0000021a g     O .bss	00000002 cursor_y
0000c2ea  w      .text	00000000 __isr_11
0000ea4c g     F .text	00000012 vsnprintf
0000d5c4 g     F .text	000002e8 lcd_gfx_drawRoundRect
0000021c g     O .bss	00000002 cur_width
0000e480 g     F .text	00000006 lcd_gfx_setHeight
0000c2ea  w      .text	00000000 __isr_5
0000ca42 g     F .text	0000002a lcd_init_gfx
0000ef58 g       *ABS*	00000000 __data_load_start
0000c8f0 g     F .text	00000076 lcd_fillScreen
0000c2ea g       .text	00000000 __dtors_end
00000208 g     O .bss	00000001 button_back
0000c354 g       .text	00000000 __isr_2
0000c2ee g       .text	00000000 __isr_10
0000013c g       *ABS*	00000000 __RESHI
0000c4ee g     F .text	00000022 lcd_writedata
0000c966 g     F .text	0000005c lcd_drawPixel
0000021e g     O .bss	00000002 CONST_WIDTH
0000c2ea  w      .text	00000000 __isr_7
0000ffe0 g     O .vectors	00000020 __ivtbl_16
0000debe g     F .text	000000c0 lcd_gfx_drawBitmap
0000df7e g     F .text	000003b2 lcd_gfx_drawChar
0000d076 g     F .text	000000fa lcd_gfx_fillCircle
0000e47a g     F .text	00000006 lcd_gfx_setWidth
0000e994 g     F .text	0000000e vprintf
0000c2ea  w      .text	00000000 __isr_0
0000c4b0 g     F .text	0000000a lcd_spi_init
0000c024  w      .text	00000000 __do_clear_bss
00000220 g     O .bss	00000002 cur_height
0000c32c g     F .text	00000018 TimerA_Interrupt
0000c852 g     F .text	0000009e lcd_fillRect
0000e424 g     F .text	0000000c lcd_gfx_setTextSize
00000209 g     O .bss	00000001 button_next
0000ef50  w      .text	00000000 _unexpected_
0000c354 g     F .text	0000004c INT_button
0000c2ea  w      .text	00000000 __isr_8
0000eed4 g       .text	00000000 __divmodhi4
0000e474 g     F .text	00000006 lcd_gfx_getHeight
0000c2ea  w      .text	00000000 __isr_3
0000eb6a g     F .text	0000036a vuprintf
00000222 g     O .bss	00000001 rotation
0000dc06 g     F .text	000002b8 lcd_gfx_fillTriangle
0000cb88 g     F .text	0000014e lcd_gfx_drawCircleHelper
0000c3a0 g     F .text	00000068 init
0000c000  w      .text	00000000 _reset_vector__
0000c2ea g       .text	00000000 __ctors_start
0000c2ea  w      .text	00000000 __isr_12
0000c510 g     F .text	000000ae commandList
0000c00e  w      .text	00000000 __do_copy_data
00000204 g       .bss	00000000 __bss_start
0000ca6c g     F .text	0000011c lcd_gfx_drawCircle
0000c038 g     F .text	000002b2 main
0000c476 g     F .text	0000003a delay_ms
0000c2ea  w      .text	00000000 __isr_13
0000e46e g     F .text	00000006 lcd_gfx_getWidth
0000020a g     O .bss	00000002 seconds
0000e41a g     F .text	0000000a lcd_gfx_setCursor
00010000 g       .vectors	00000000 _vectors_end
0000e430 g     F .text	0000000a lcd_gfx_setTextColor
0000c448 g     F .text	0000002e delay
0000d172 g     F .text	000000c8 lcd_gfx_drawLine
0000ea00 g     F .text	0000001c sprintf
0000020c g     O .bss	00000001 button_down
0000d23a g     F .text	00000274 lcd_gfx_drawRect
0000c32c g       .text	00000000 __isr_9
00000200 g     O .data	00000001 _width
0000c000  w      .text	00000000 __init_stack
0000020e g     O .bss	00000002 offset
0000c2ea g       .text	00000000 __dtors_start
0000c2ea  w      .text	00000000 __isr_6
0000c2ea g       .text	00000000 __ctors_end
00000132 g       *ABS*	00000000 __MPYS
00004200 g       *ABS*	00000000 __stack
0000e43a g     F .text	00000006 lcd_gfx_getRotation
0000c2ea  w      .text	00000000 __isr_1
00000224 g     O .bss	00000002 cursor_x
00000204 g       .data	00000000 _edata
0000022c g       .bss	00000000 _end
00000226 g     O .bss	00000001 textsize
00000215 g     O .bss	00000001 colstart
00000202 g     O .data	00000001 _height
00000134 g       *ABS*	00000000 __MAC
0000ef26 g       .text	00000000 __udivmodsi4
0000ef52  w      .text	00000000 _endless_loop__
0000ccd6 g     F .text	000003a0 lcd_gfx_fillCircleHelper
00000216 g     O .bss	00000001 rowstart
00000210 g     O .bss	00000001 button_up
0000c004  w      .text	00000000 __low_level_init
0000c446 g     F .text	00000002 nop
0000d170 g     F .text	00000002 abs
00000200 g       .data	00000000 __data_start
0000d92e g     F .text	000002d8 lcd_gfx_drawTriangle
00000120 g       *ABS*	00000000 __WDTCTL
00000211 g     O .bss	00000001 timer_count
00000228 g     O .bss	00000002 textbgcolor
0000022a g     O .bss	00000002 textcolor
0000013e g       *ABS*	00000000 __SUMEXT
0000c2ee g     F .text	0000003e INT_Watchdog
00000212 g     O .bss	00000002 irq_counter
0000d570 g     F .text	00000054 lcd_gfx_drawFastHLine



Disassembly of section .text:

0000c000 <__init_stack>:
    c000:	31 40 00 42 	mov	#16896,	r1	;#0x4200

0000c004 <__low_level_init>:
    c004:	15 42 20 01 	mov	&0x0120,r5	
    c008:	75 f3       	and.b	#-1,	r5	;r3 As==11
    c00a:	35 d0 08 5a 	bis	#23048,	r5	;#0x5a08

0000c00e <__do_copy_data>:
    c00e:	3f 40 04 00 	mov	#4,	r15	;#0x0004
    c012:	0f 93       	tst	r15		
    c014:	07 24       	jz	$+16     	;abs 0xc024
    c016:	82 45 20 01 	mov	r5,	&0x0120	
    c01a:	2f 83       	decd	r15		
    c01c:	9f 4f 58 ef 	mov	-4264(r15),512(r15);0xef58(r15), 0x0200(r15)
    c020:	00 02 
    c022:	f9 23       	jnz	$-12     	;abs 0xc016

0000c024 <__do_clear_bss>:
    c024:	3f 40 28 00 	mov	#40,	r15	;#0x0028
    c028:	0f 93       	tst	r15		
    c02a:	06 24       	jz	$+14     	;abs 0xc038
    c02c:	82 45 20 01 	mov	r5,	&0x0120	
    c030:	1f 83       	dec	r15		
    c032:	cf 43 04 02 	mov.b	#0,	516(r15);r3 As==00, 0x0204(r15)
    c036:	fa 23       	jnz	$-10     	;abs 0xc02c

0000c038 <main>:
	printf("%s\r", s);
	lcd_gfx_print(s);
}

int main(void)
{
    c038:	31 50 e0 ff 	add	#-32,	r1	;#0xffe0



void init(void)
{ 
    WDTCTL = WDTPW | WDTHOLD;          // Disable watchdog timer
    c03c:	b2 40 80 5a 	mov	#23168,	&0x0120	;#0x5a80
    c040:	20 01 
 
    UART_BAUD = BAUD;                   // Init UART
    c042:	b2 40 8a 00 	mov	#138,	&0x0082	;#0x008a
    c046:	82 00 
    UART_CTL = UART_EN;                 //Enable UART Output
    c048:	d2 43 80 00 	mov.b	#1,	&0x0080	;r3 As==01
    
    P1OUT  = 0x00;                     // Port data output
    c04c:	c2 43 21 00 	mov.b	#0,	&0x0021	;r3 As==00
    P2OUT  = 0x00;
    c050:	c2 43 29 00 	mov.b	#0,	&0x0029	;r3 As==00
 
    P1DIR  = 0x00;                     // Port direction register
    c054:	c2 43 22 00 	mov.b	#0,	&0x0022	;r3 As==00
    P2DIR  = 0xff;
    c058:	f2 43 2a 00 	mov.b	#-1,	&0x002a	;r3 As==11
 
    P1IES  = 0x00;                     // Port interrupt enable (0=dis 1=enabled)
    c05c:	c2 43 24 00 	mov.b	#0,	&0x0024	;r3 As==00
    P2IES  = 0x00;
    c060:	c2 43 2c 00 	mov.b	#0,	&0x002c	;r3 As==00
    P1IE   = 0x0F;                     // Port interrupt Edge Select (0=pos 1=neg)
    c064:	f2 40 0f 00 	mov.b	#15,	&0x0025	;#0x000f
    c068:	25 00 
    P2IE   = 0x00;
    c06a:	c2 43 2d 00 	mov.b	#0,	&0x002d	;r3 As==00
 
    //WDTCTL = WDTPW | WDTTMSEL | WDTCNTCL;// | WDTIS1  | WDTIS0 ;          // Configure watchdog interrupt
    
    timer_count = seconds = 0;
    c06e:	82 43 0a 02 	mov	#0,	&0x020a	;r3 As==00
    c072:	c2 43 11 02 	mov.b	#0,	&0x0211	;r3 As==00

    CCR0 = 20000; 
    c076:	b2 40 20 4e 	mov	#20000,	&0x0172	;#0x4e20
    c07a:	72 01 
    CCTL0 |= CCIE;
    c07c:	b2 d0 10 00 	bis	#16,	&0x0162	;#0x0010
    c080:	62 01 
    TACTL = ID_3 | TASSEL_2 | MC_1; // ACLK, upmode 
    c082:	b2 40 d0 02 	mov	#720,	&0x0160	;#0x02d0
    c086:	60 01 

    

    eint();                            //enable interrupts
    c088:	32 d2       	eint			
    
    lcd_init_screen( INITR_BLACKTAB );
    c08a:	6f 43       	mov.b	#2,	r15	;r3 As==10
    c08c:	b0 12 0a c6 	call	#0xc60a	
    lcd_init_gfx( 160, 128 );
    c090:	3e 40 80 00 	mov	#128,	r14	;#0x0080
    c094:	3f 40 a0 00 	mov	#160,	r15	;#0x00a0
    c098:	b0 12 42 ca 	call	#0xca42	
}

int main(void)
{
    init();
    irq_counter = 0;
    c09c:	82 43 12 02 	mov	#0,	&0x0212	;r3 As==00
    offset      = 0;
    c0a0:	82 43 0e 02 	mov	#0,	&0x020e	;r3 As==00
    button_up = button_down = button_back = button_next = 0;
    c0a4:	c2 43 09 02 	mov.b	#0,	&0x0209	;r3 As==00
    c0a8:	d2 42 09 02 	mov.b	&0x0209,&0x0208	
    c0ac:	08 02 
    c0ae:	d2 42 08 02 	mov.b	&0x0208,&0x020c	
    c0b2:	0c 02 
    c0b4:	d2 42 0c 02 	mov.b	&0x020c,&0x0210	
    c0b8:	10 02 

    lcd_fillScreen( COLOR_LEGIT_ORANGE );
    c0ba:	3f 40 e0 fb 	mov	#-1056,	r15	;#0xfbe0
    c0be:	b0 12 f0 c8 	call	#0xc8f0	
    lcd_gfx_drawChar(30, 50, 0x56, COLOR_LEGIT_PURPLE, COLOR_LEGIT_ORANGE, 4);
    c0c2:	70 12 04 00 	push.b	#4		;#0x0004
    c0c6:	30 12 e0 fb 	push	#-1056		;#0xfbe0
    c0ca:	3c 40 48 28 	mov	#10312,	r12	;#0x2848
    c0ce:	7d 40 56 00 	mov.b	#86,	r13	;#0x0056
    c0d2:	3e 40 32 00 	mov	#50,	r14	;#0x0032
    c0d6:	3f 40 1e 00 	mov	#30,	r15	;#0x001e
    c0da:	b0 12 7e df 	call	#0xdf7e	
    c0de:	21 52       	add	#4,	r1	;r2 As==10
    lcd_gfx_drawChar(70, 50, 0x49, COLOR_LEGIT_PURPLE, COLOR_LEGIT_ORANGE, 4);
    c0e0:	70 12 04 00 	push.b	#4		;#0x0004
    c0e4:	30 12 e0 fb 	push	#-1056		;#0xfbe0
    c0e8:	3c 40 48 28 	mov	#10312,	r12	;#0x2848
    c0ec:	7d 40 49 00 	mov.b	#73,	r13	;#0x0049
    c0f0:	3e 40 32 00 	mov	#50,	r14	;#0x0032
    c0f4:	3f 40 46 00 	mov	#70,	r15	;#0x0046
    c0f8:	b0 12 7e df 	call	#0xdf7e	
    c0fc:	21 52       	add	#4,	r1	;r2 As==10
    lcd_gfx_drawChar(110, 50, 0x50, COLOR_LEGIT_PURPLE, COLOR_LEGIT_ORANGE, 4);
    c0fe:	70 12 04 00 	push.b	#4		;#0x0004
    c102:	30 12 e0 fb 	push	#-1056		;#0xfbe0
    c106:	3c 40 48 28 	mov	#10312,	r12	;#0x2848
    c10a:	7d 40 50 00 	mov.b	#80,	r13	;#0x0050
    c10e:	3e 40 32 00 	mov	#50,	r14	;#0x0032
    c112:	3f 40 6e 00 	mov	#110,	r15	;#0x006e
    c116:	b0 12 7e df 	call	#0xdf7e	
    c11a:	21 52       	add	#4,	r1	;r2 As==10

    lcd_gfx_setTextColor(COLOR_LEGIT_PURPLE, COLOR_LEGIT_ORANGE);
    c11c:	3e 40 e0 fb 	mov	#-1056,	r14	;#0xfbe0
    c120:	3f 40 48 28 	mov	#10312,	r15	;#0x2848
    c124:	b0 12 30 e4 	call	#0xe430	
    lcd_init_gfx( 160, 128 );
}

void testprint(char *s)
{
	printf("%s\r", s);
    c128:	30 12 26 c4 	push	#-15322	;#0xc426
    c12c:	30 12 08 c4 	push	#-15352	;#0xc408
    c130:	b0 12 82 e9 	call	#0xe982	
    c134:	21 52       	add	#4,	r1	;r2 As==10
	lcd_gfx_print(s);
    c136:	3f 40 26 c4 	mov	#-15322,r15	;#0xc426
    c13a:	b0 12 30 e3 	call	#0xe330	
    c13e:	0b 41       	mov	r1,	r11	
    c140:	09 3c       	jmp	$+20     	;abs 0xc154
            lcd_gfx_drawChar(110, 50, 0x50, COLOR_LEGIT_PURPLE, COLOR_LEGIT_ORANGE, 4);

            lcd_gfx_setTextColor(COLOR_LEGIT_PURPLE, COLOR_LEGIT_ORANGE);

        }
        if (button_down == 1){
    c142:	d2 93 0c 02 	cmp.b	#1,	&0x020c	;r3 As==01
    c146:	47 24       	jz	$+144    	;abs 0xc1d6

            lcd_gfx_setTextColor(COLOR_LEGIT_PURPLE, COLOR_LEGIT_ORANGE);
            button_down =0;
						
        }
        if (button_back == 1){
    c148:	d2 93 08 02 	cmp.b	#1,	&0x0208	;r3 As==01
    c14c:	80 24       	jz	$+258    	;abs 0xc24e
            lcd_gfx_drawChar(70, 50, 0x49, ST7735_WHITE , COLOR_LEGIT_PURPLE , 4);
            lcd_gfx_drawChar(110, 50, 0x50, ST7735_WHITE , COLOR_LEGIT_PURPLE , 4);

            lcd_gfx_setTextColor(COLOR_LEGIT_PURPLE, COLOR_LEGIT_ORANGE);
        }
        if (button_next == 1) {
    c14e:	d2 93 09 02 	cmp.b	#1,	&0x0209	;r3 As==01
    c152:	b6 24       	jz	$+366    	;abs 0xc2c0
    lcd_gfx_setTextColor(COLOR_LEGIT_PURPLE, COLOR_LEGIT_ORANGE);
	testprint("Testing Buttons..\n");

    while(1) 
    {
        LPM0;
    c154:	32 d0 10 00 	bis	#16,	r2	;#0x0010

		if (button_up == 1){
    c158:	d2 93 10 02 	cmp.b	#1,	&0x0210	;r3 As==01
    c15c:	f2 23       	jnz	$-26     	;abs 0xc142
            button_up = 0;
    c15e:	c2 43 10 02 	mov.b	#0,	&0x0210	;r3 As==00
		
            lcd_fillScreen( COLOR_LEGIT_ORANGE );
    c162:	3f 40 e0 fb 	mov	#-1056,	r15	;#0xfbe0
    c166:	b0 12 f0 c8 	call	#0xc8f0	
            lcd_gfx_drawChar(30, 50, 0x56, COLOR_LEGIT_PURPLE, COLOR_LEGIT_ORANGE, 4);
    c16a:	70 12 04 00 	push.b	#4		;#0x0004
    c16e:	30 12 e0 fb 	push	#-1056		;#0xfbe0
    c172:	3c 40 48 28 	mov	#10312,	r12	;#0x2848
    c176:	7d 40 56 00 	mov.b	#86,	r13	;#0x0056
    c17a:	3e 40 32 00 	mov	#50,	r14	;#0x0032
    c17e:	3f 40 1e 00 	mov	#30,	r15	;#0x001e
    c182:	b0 12 7e df 	call	#0xdf7e	
    c186:	21 52       	add	#4,	r1	;r2 As==10
            lcd_gfx_drawChar(70, 50, 0x49, COLOR_LEGIT_PURPLE, COLOR_LEGIT_ORANGE, 4);
    c188:	70 12 04 00 	push.b	#4		;#0x0004
    c18c:	30 12 e0 fb 	push	#-1056		;#0xfbe0
    c190:	3c 40 48 28 	mov	#10312,	r12	;#0x2848
    c194:	7d 40 49 00 	mov.b	#73,	r13	;#0x0049
    c198:	3e 40 32 00 	mov	#50,	r14	;#0x0032
    c19c:	3f 40 46 00 	mov	#70,	r15	;#0x0046
    c1a0:	b0 12 7e df 	call	#0xdf7e	
    c1a4:	21 52       	add	#4,	r1	;r2 As==10
            lcd_gfx_drawChar(110, 50, 0x50, COLOR_LEGIT_PURPLE, COLOR_LEGIT_ORANGE, 4);
    c1a6:	70 12 04 00 	push.b	#4		;#0x0004
    c1aa:	30 12 e0 fb 	push	#-1056		;#0xfbe0
    c1ae:	3c 40 48 28 	mov	#10312,	r12	;#0x2848
    c1b2:	7d 40 50 00 	mov.b	#80,	r13	;#0x0050
    c1b6:	3e 40 32 00 	mov	#50,	r14	;#0x0032
    c1ba:	3f 40 6e 00 	mov	#110,	r15	;#0x006e
    c1be:	b0 12 7e df 	call	#0xdf7e	
    c1c2:	21 52       	add	#4,	r1	;r2 As==10

            lcd_gfx_setTextColor(COLOR_LEGIT_PURPLE, COLOR_LEGIT_ORANGE);
    c1c4:	3e 40 e0 fb 	mov	#-1056,	r14	;#0xfbe0
    c1c8:	3f 40 48 28 	mov	#10312,	r15	;#0x2848
    c1cc:	b0 12 30 e4 	call	#0xe430	

        }
        if (button_down == 1){
    c1d0:	d2 93 0c 02 	cmp.b	#1,	&0x020c	;r3 As==01
    c1d4:	b9 23       	jnz	$-140    	;abs 0xc148
            lcd_fillScreen( COLOR_LEGIT_PURPLE);
    c1d6:	3f 40 48 28 	mov	#10312,	r15	;#0x2848
    c1da:	b0 12 f0 c8 	call	#0xc8f0	
            lcd_gfx_drawChar(30, 50, 0x56, COLOR_LEGIT_ORANGE, COLOR_LEGIT_PURPLE, 4);
    c1de:	70 12 04 00 	push.b	#4		;#0x0004
    c1e2:	30 12 48 28 	push	#10312		;#0x2848
    c1e6:	3c 40 e0 fb 	mov	#-1056,	r12	;#0xfbe0
    c1ea:	7d 40 56 00 	mov.b	#86,	r13	;#0x0056
    c1ee:	3e 40 32 00 	mov	#50,	r14	;#0x0032
    c1f2:	3f 40 1e 00 	mov	#30,	r15	;#0x001e
    c1f6:	b0 12 7e df 	call	#0xdf7e	
    c1fa:	21 52       	add	#4,	r1	;r2 As==10
            lcd_gfx_drawChar(70, 50, 0x49, COLOR_LEGIT_ORANGE, COLOR_LEGIT_PURPLE, 4);
    c1fc:	70 12 04 00 	push.b	#4		;#0x0004
    c200:	30 12 48 28 	push	#10312		;#0x2848
    c204:	3c 40 e0 fb 	mov	#-1056,	r12	;#0xfbe0
    c208:	7d 40 49 00 	mov.b	#73,	r13	;#0x0049
    c20c:	3e 40 32 00 	mov	#50,	r14	;#0x0032
    c210:	3f 40 46 00 	mov	#70,	r15	;#0x0046
    c214:	b0 12 7e df 	call	#0xdf7e	
    c218:	21 52       	add	#4,	r1	;r2 As==10
            lcd_gfx_drawChar(110, 50, 0x50, COLOR_LEGIT_ORANGE, COLOR_LEGIT_PURPLE, 4);
    c21a:	70 12 04 00 	push.b	#4		;#0x0004
    c21e:	30 12 48 28 	push	#10312		;#0x2848
    c222:	3c 40 e0 fb 	mov	#-1056,	r12	;#0xfbe0
    c226:	7d 40 50 00 	mov.b	#80,	r13	;#0x0050
    c22a:	3e 40 32 00 	mov	#50,	r14	;#0x0032
    c22e:	3f 40 6e 00 	mov	#110,	r15	;#0x006e
    c232:	b0 12 7e df 	call	#0xdf7e	
    c236:	21 52       	add	#4,	r1	;r2 As==10

            lcd_gfx_setTextColor(COLOR_LEGIT_PURPLE, COLOR_LEGIT_ORANGE);
    c238:	3e 40 e0 fb 	mov	#-1056,	r14	;#0xfbe0
    c23c:	3f 40 48 28 	mov	#10312,	r15	;#0x2848
    c240:	b0 12 30 e4 	call	#0xe430	
            button_down =0;
    c244:	c2 43 0c 02 	mov.b	#0,	&0x020c	;r3 As==00
						
        }
        if (button_back == 1){
    c248:	d2 93 08 02 	cmp.b	#1,	&0x0208	;r3 As==01
    c24c:	80 23       	jnz	$-254    	;abs 0xc14e
            button_back = 0;
    c24e:	c2 43 08 02 	mov.b	#0,	&0x0208	;r3 As==00
						
            lcd_fillScreen( COLOR_LEGIT_PURPLE);
    c252:	3f 40 48 28 	mov	#10312,	r15	;#0x2848
    c256:	b0 12 f0 c8 	call	#0xc8f0	
            lcd_gfx_drawChar(30, 50, 0x56, ST7735_WHITE  , COLOR_LEGIT_PURPLE , 4);
    c25a:	70 12 04 00 	push.b	#4		;#0x0004
    c25e:	30 12 48 28 	push	#10312		;#0x2848
    c262:	3c 43       	mov	#-1,	r12	;r3 As==11
    c264:	7d 40 56 00 	mov.b	#86,	r13	;#0x0056
    c268:	3e 40 32 00 	mov	#50,	r14	;#0x0032
    c26c:	3f 40 1e 00 	mov	#30,	r15	;#0x001e
    c270:	b0 12 7e df 	call	#0xdf7e	
    c274:	21 52       	add	#4,	r1	;r2 As==10
            lcd_gfx_drawChar(70, 50, 0x49, ST7735_WHITE , COLOR_LEGIT_PURPLE , 4);
    c276:	70 12 04 00 	push.b	#4		;#0x0004
    c27a:	30 12 48 28 	push	#10312		;#0x2848
    c27e:	3c 43       	mov	#-1,	r12	;r3 As==11
    c280:	7d 40 49 00 	mov.b	#73,	r13	;#0x0049
    c284:	3e 40 32 00 	mov	#50,	r14	;#0x0032
    c288:	3f 40 46 00 	mov	#70,	r15	;#0x0046
    c28c:	b0 12 7e df 	call	#0xdf7e	
    c290:	21 52       	add	#4,	r1	;r2 As==10
            lcd_gfx_drawChar(110, 50, 0x50, ST7735_WHITE , COLOR_LEGIT_PURPLE , 4);
    c292:	70 12 04 00 	push.b	#4		;#0x0004
    c296:	30 12 48 28 	push	#10312		;#0x2848
    c29a:	3c 43       	mov	#-1,	r12	;r3 As==11
    c29c:	7d 40 50 00 	mov.b	#80,	r13	;#0x0050
    c2a0:	3e 40 32 00 	mov	#50,	r14	;#0x0032
    c2a4:	3f 40 6e 00 	mov	#110,	r15	;#0x006e
    c2a8:	b0 12 7e df 	call	#0xdf7e	
    c2ac:	21 52       	add	#4,	r1	;r2 As==10

            lcd_gfx_setTextColor(COLOR_LEGIT_PURPLE, COLOR_LEGIT_ORANGE);
    c2ae:	3e 40 e0 fb 	mov	#-1056,	r14	;#0xfbe0
    c2b2:	3f 40 48 28 	mov	#10312,	r15	;#0x2848
    c2b6:	b0 12 30 e4 	call	#0xe430	
        }
        if (button_next == 1) {
    c2ba:	d2 93 09 02 	cmp.b	#1,	&0x0209	;r3 As==01
    c2be:	4a 23       	jnz	$-362    	;abs 0xc154
            unsigned char stringbuf[32];
            button_next = 0;
    c2c0:	c2 43 09 02 	mov.b	#0,	&0x0209	;r3 As==00
            sprintf(stringbuf, "seconds: %d\n", seconds);
    c2c4:	12 12 0a 02 	push	&0x020a	
    c2c8:	30 12 39 c4 	push	#-15303	;#0xc439
    c2cc:	0b 12       	push	r11		
    c2ce:	b0 12 00 ea 	call	#0xea00	
    c2d2:	31 50 06 00 	add	#6,	r1	;#0x0006
    lcd_init_gfx( 160, 128 );
}

void testprint(char *s)
{
	printf("%s\r", s);
    c2d6:	0b 12       	push	r11		
    c2d8:	30 12 08 c4 	push	#-15352	;#0xc408
    c2dc:	b0 12 82 e9 	call	#0xe982	
    c2e0:	21 52       	add	#4,	r1	;r2 As==10
	lcd_gfx_print(s);
    c2e2:	0f 4b       	mov	r11,	r15	
    c2e4:	b0 12 30 e3 	call	#0xe330	
    c2e8:	35 3f       	jmp	$-404    	;abs 0xc154

0000c2ea <__ctors_end>:
    c2ea:	30 40 50 ef 	br	#0xef50	

0000c2ee <INT_Watchdog>:
it does not count days, but i think you'll get the idea.
*/
volatile int irq_counter, offset;
volatile uint8_t button_next, button_up, button_down, button_back;

wakeup interrupt (WDT_VECTOR) INT_Watchdog(void) {
    c2ee:	0e 12       	push	r14		
    c2f0:	0d 12       	push	r13		
    c2f2:	0c 12       	push	r12		
    c2f4:	0b 12       	push	r11		
    c2f6:	0a 12       	push	r10		
 
  irq_counter++;
    c2f8:	92 53 12 02 	inc	&0x0212	
  if (irq_counter == 300) {
    c2fc:	b2 90 2c 01 	cmp	#300,	&0x0212	;#0x012c
    c300:	12 02 
    c302:	0b 20       	jnz	$+24     	;abs 0xc31a
    irq_counter = 0;
    c304:	82 43 12 02 	mov	#0,	&0x0212	;r3 As==00
    offset = (offset+1) % 20;
    c308:	1c 42 0e 02 	mov	&0x020e,r12	
    c30c:	1c 53       	inc	r12		
    c30e:	3a 40 14 00 	mov	#20,	r10	;#0x0014
    c312:	b0 12 d4 ee 	call	#0xeed4	
    c316:	82 4e 0e 02 	mov	r14,	&0x020e	
  }
}
    c31a:	3a 41       	pop	r10		
    c31c:	3b 41       	pop	r11		
    c31e:	3c 41       	pop	r12		
    c320:	3d 41       	pop	r13		
    c322:	3e 41       	pop	r14		
    c324:	b1 c0 f0 00 	bic	#240,	0(r1)	;#0x00f0, 0x0000(r1)
    c328:	00 00 
    c32a:	00 13       	reti			

0000c32c <TimerA_Interrupt>:
volatile uint8_t timer_count;
volatile int seconds;

interrupt (TIMERA0_VECTOR) TimerA_Interrupt( void )
{
    timer_count++;
    c32c:	d2 53 11 02 	inc.b	&0x0211	
    if (timer_count == 100){
    c330:	f2 90 64 00 	cmp.b	#100,	&0x0211	;#0x0064
    c334:	11 02 
    c336:	01 24       	jz	$+4      	;abs 0xc33a
        seconds+=1;
        timer_count = 0;
    }

}
    c338:	00 13       	reti			

interrupt (TIMERA0_VECTOR) TimerA_Interrupt( void )
{
    timer_count++;
    if (timer_count == 100){
        seconds+=1;
    c33a:	92 53 0a 02 	inc	&0x020a	
        timer_count = 0;
    c33e:	c2 43 11 02 	mov.b	#0,	&0x0211	;r3 As==00
    }

}
    c342:	00 13       	reti			

0000c344 <putchar>:

int putchar (int txdata) {
    c344:	0e 4f       	mov	r15,	r14	
    while (UART_STAT & UART_TX_FULL);
    c346:	5f 42 81 00 	mov.b	&0x0081,r15	
    c34a:	3f f2       	and	#8,	r15	;r2 As==11
    c34c:	fc 23       	jnz	$-6      	;abs 0xc346
    UART_TXD = txdata;
    c34e:	c2 4e 84 00 	mov.b	r14,	&0x0084	
    return 0;
}
    c352:	30 41       	ret			

0000c354 <INT_button>:

//----------------------------------------------------//
// PORT1 Interrupt -- Button Depress
//----------------------------------------------------//
interrupt (PORT1_VECTOR) INT_button(void)
{
    c354:	0f 12       	push	r15		
    if ( BUTTON_FLAG & BUTTON_NEXT_BIT )
    c356:	5f 42 23 00 	mov.b	&0x0023,r15	
    c35a:	1f f3       	and	#1,	r15	;r3 As==01
    c35c:	04 24       	jz	$+10     	;abs 0xc366
    {
        button_next =1;
    c35e:	d2 43 09 02 	mov.b	#1,	&0x0209	;r3 As==01
        BUTTON_FLAG ^= BUTTON_NEXT_BIT;
    c362:	d2 e3 23 00 	xor.b	#1,	&0x0023	;r3 As==01
    }
    if (BUTTON_FLAG & BUTTON_DOWN_BIT){
    c366:	5f 42 23 00 	mov.b	&0x0023,r15	
    c36a:	2f f2       	and	#4,	r15	;r2 As==10
    c36c:	04 24       	jz	$+10     	;abs 0xc376
        button_down = 1;
    c36e:	d2 43 0c 02 	mov.b	#1,	&0x020c	;r3 As==01
        BUTTON_FLAG ^= BUTTON_DOWN_BIT;
    c372:	e2 e2 23 00 	xor.b	#4,	&0x0023	;r2 As==10
    }
    if ( BUTTON_FLAG & BUTTON_UP_BIT ){
    c376:	5f 42 23 00 	mov.b	&0x0023,r15	
    c37a:	2f f3       	and	#2,	r15	;r3 As==10
    c37c:	04 24       	jz	$+10     	;abs 0xc386
        button_up = 1;
    c37e:	d2 43 10 02 	mov.b	#1,	&0x0210	;r3 As==01
        BUTTON_FLAG ^= BUTTON_UP_BIT;
    c382:	e2 e3 23 00 	xor.b	#2,	&0x0023	;r3 As==10
    }
    if (BUTTON_FLAG & BUTTON_BACK_BIT){
    c386:	5f 42 23 00 	mov.b	&0x0023,r15	
    c38a:	3f f2       	and	#8,	r15	;r2 As==11
    c38c:	04 24       	jz	$+10     	;abs 0xc396
        button_back = 1;
    c38e:	d2 43 08 02 	mov.b	#1,	&0x0208	;r3 As==01
        BUTTON_FLAG ^= BUTTON_BACK_BIT;
    c392:	f2 e2 23 00 	xor.b	#8,	&0x0023	;r2 As==11
    }

    LPM0_EXIT;
    c396:	b1 c0 10 00 	bic	#16,	2(r1)	;#0x0010, 0x0002(r1)
    c39a:	02 00 
}
    c39c:	3f 41       	pop	r15		
    c39e:	00 13       	reti			

0000c3a0 <init>:




void init(void)
{ 
    c3a0:	0b 12       	push	r11		
    WDTCTL = WDTPW | WDTHOLD;          // Disable watchdog timer
    c3a2:	b2 40 80 5a 	mov	#23168,	&0x0120	;#0x5a80
    c3a6:	20 01 
 
    UART_BAUD = BAUD;                   // Init UART
    c3a8:	b2 40 8a 00 	mov	#138,	&0x0082	;#0x008a
    c3ac:	82 00 
    UART_CTL = UART_EN;                 //Enable UART Output
    c3ae:	3b 40 80 00 	mov	#128,	r11	;#0x0080
    c3b2:	db 43 00 00 	mov.b	#1,	0(r11)	;r3 As==01, 0x0000(r11)
    
    P1OUT  = 0x00;                     // Port data output
    c3b6:	c2 43 21 00 	mov.b	#0,	&0x0021	;r3 As==00
    P2OUT  = 0x00;
    c3ba:	c2 43 29 00 	mov.b	#0,	&0x0029	;r3 As==00
 
    P1DIR  = 0x00;                     // Port direction register
    c3be:	c2 43 22 00 	mov.b	#0,	&0x0022	;r3 As==00
    P2DIR  = 0xff;
    c3c2:	f2 43 2a 00 	mov.b	#-1,	&0x002a	;r3 As==11
 
    P1IES  = 0x00;                     // Port interrupt enable (0=dis 1=enabled)
    c3c6:	c2 43 24 00 	mov.b	#0,	&0x0024	;r3 As==00
    P2IES  = 0x00;
    c3ca:	c2 43 2c 00 	mov.b	#0,	&0x002c	;r3 As==00
    P1IE   = 0x0F;                     // Port interrupt Edge Select (0=pos 1=neg)
    c3ce:	f2 40 0f 00 	mov.b	#15,	&0x0025	;#0x000f
    c3d2:	25 00 
    P2IE   = 0x00;
    c3d4:	c2 43 2d 00 	mov.b	#0,	&0x002d	;r3 As==00
 
    //WDTCTL = WDTPW | WDTTMSEL | WDTCNTCL;// | WDTIS1  | WDTIS0 ;          // Configure watchdog interrupt
    
    timer_count = seconds = 0;
    c3d8:	82 43 0a 02 	mov	#0,	&0x020a	;r3 As==00
    c3dc:	c2 43 11 02 	mov.b	#0,	&0x0211	;r3 As==00

    CCR0 = 20000; 
    c3e0:	b2 40 20 4e 	mov	#20000,	&0x0172	;#0x4e20
    c3e4:	72 01 
    CCTL0 |= CCIE;
    c3e6:	b2 d0 10 00 	bis	#16,	&0x0162	;#0x0010
    c3ea:	62 01 
    TACTL = ID_3 | TASSEL_2 | MC_1; // ACLK, upmode 
    c3ec:	b2 40 d0 02 	mov	#720,	&0x0160	;#0x02d0
    c3f0:	60 01 

    

    eint();                            //enable interrupts
    c3f2:	32 d2       	eint			
    
    lcd_init_screen( INITR_BLACKTAB );
    c3f4:	6f 43       	mov.b	#2,	r15	;r3 As==10
    c3f6:	b0 12 0a c6 	call	#0xc60a	
    lcd_init_gfx( 160, 128 );
    c3fa:	0e 4b       	mov	r11,	r14	
    c3fc:	3f 40 a0 00 	mov	#160,	r15	;#0x00a0
    c400:	b0 12 42 ca 	call	#0xca42	
}
    c404:	3b 41       	pop	r11		
    c406:	30 41       	ret			
    c408:	25 73       	subc	#2,	r5	;r3 As==10
    c40a:	0d 00       	.word	0x000d;	????	

0000c40c <testprint>:

void testprint(char *s)
{
    c40c:	0b 12       	push	r11		
    c40e:	0b 4f       	mov	r15,	r11	
	printf("%s\r", s);
    c410:	0f 12       	push	r15		
    c412:	30 12 08 c4 	push	#-15352	;#0xc408
    c416:	b0 12 82 e9 	call	#0xe982	
    c41a:	21 52       	add	#4,	r1	;r2 As==10
	lcd_gfx_print(s);
    c41c:	0f 4b       	mov	r11,	r15	
    c41e:	b0 12 30 e3 	call	#0xe330	
}
    c422:	3b 41       	pop	r11		
    c424:	30 41       	ret			
    c426:	54 65 73 74 	addc.b	29811(r5),r4	;0x7473(r5)
    c42a:	69 6e       	addc.b	@r14,	r9	
    c42c:	67 20       	jnz	$+208    	;abs 0xc4fc
    c42e:	42 75       	subc.b	r5,	r2	
    c430:	74 74       	subc.b	@r4+,	r4	
    c432:	6f 6e       	addc.b	@r14,	r15	
    c434:	73 2e       	jc	$-792    	;abs 0xc11c
    c436:	2e 0a       	.word	0x0a2e;	????	
    c438:	00 73       	sbc	r0		
    c43a:	65 63       	addc.b	#2,	r5	;r3 As==10
    c43c:	6f 6e       	addc.b	@r14,	r15	
    c43e:	64 73       	subc.b	#2,	r4	;r3 As==10
    c440:	3a 20       	jnz	$+118    	;abs 0xc4b6
    c442:	25 64       	addc	@r4,	r5	
    c444:	0a 00       	.word	0x000a;	????	

0000c446 <nop>:
/**
Delay function.
*/
void nop(void)
{
}
    c446:	30 41       	ret			

0000c448 <delay>:

void delay(unsigned int c, unsigned int d)
{
    c448:	21 82       	sub	#4,	r1	;r2 As==10
  volatile int i, j;
  for (i = 0; i<c; i++) {
    c44a:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00, 0x0000(r1)
    c44e:	81 9f 00 00 	cmp	r15,	0(r1)	;0x0000(r1)
    c452:	0f 2c       	jc	$+32     	;abs 0xc472
    for (j = 0; j<d; j++) {
    c454:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00, 0x0002(r1)
    c458:	81 9e 02 00 	cmp	r14,	2(r1)	;0x0002(r1)
    c45c:	05 2c       	jc	$+12     	;abs 0xc468
    c45e:	91 53 02 00 	inc	2(r1)		;0x0002(r1)
    c462:	81 9e 02 00 	cmp	r14,	2(r1)	;0x0002(r1)
    c466:	fb 2b       	jnc	$-8      	;abs 0xc45e
}

void delay(unsigned int c, unsigned int d)
{
  volatile int i, j;
  for (i = 0; i<c; i++) {
    c468:	91 53 00 00 	inc	0(r1)		;0x0000(r1)
    c46c:	81 9f 00 00 	cmp	r15,	0(r1)	;0x0000(r1)
    c470:	f1 2b       	jnc	$-28     	;abs 0xc454
    for (j = 0; j<d; j++) {
      nop();
      nop();
    }
  }
}
    c472:	21 52       	add	#4,	r1	;r2 As==10
    c474:	30 41       	ret			

0000c476 <delay_ms>:

void delay_ms( unsigned int ms )
{
    c476:	21 82       	sub	#4,	r1	;r2 As==10
}

void delay(unsigned int c, unsigned int d)
{
  volatile int i, j;
  for (i = 0; i<c; i++) {
    c478:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00, 0x0000(r1)
    c47c:	81 9f 00 00 	cmp	r15,	0(r1)	;0x0000(r1)
    c480:	15 2c       	jc	$+44     	;abs 0xc4ac
    for (j = 0; j<d; j++) {
    c482:	3c 40 fe 07 	mov	#2046,	r12	;#0x07fe
    c486:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00, 0x0002(r1)
    c48a:	1e 41 02 00 	mov	2(r1),	r14	;0x0002(r1)
    c48e:	0c 9e       	cmp	r14,	r12	
    c490:	08 28       	jnc	$+18     	;abs 0xc4a2
    c492:	3d 40 fe 07 	mov	#2046,	r13	;#0x07fe
    c496:	91 53 02 00 	inc	2(r1)		;0x0002(r1)
    c49a:	1e 41 02 00 	mov	2(r1),	r14	;0x0002(r1)
    c49e:	0d 9e       	cmp	r14,	r13	
    c4a0:	fa 2f       	jc	$-10     	;abs 0xc496
}

void delay(unsigned int c, unsigned int d)
{
  volatile int i, j;
  for (i = 0; i<c; i++) {
    c4a2:	91 53 00 00 	inc	0(r1)		;0x0000(r1)
    c4a6:	81 9f 00 00 	cmp	r15,	0(r1)	;0x0000(r1)
    c4aa:	ed 2b       	jnc	$-36     	;abs 0xc486
}

void delay_ms( unsigned int ms )
{
        delay( ms, 0x7ff );
}
    c4ac:	21 52       	add	#4,	r1	;r2 As==10
    c4ae:	30 41       	ret			

0000c4b0 <lcd_spi_init>:


void lcd_spi_init( void )
{
	// Bring high the LCD Chip Select
	LCD_PORT |= LCD_CSN_BIT;
    c4b0:	e2 d2 29 00 	bis.b	#4,	&0x0029	;r2 As==10

	// Set everything low except the clock divider to 4Mhz
	LCDSPI_CTRL = (0x0000);
    c4b4:	82 43 90 00 	mov	#0,	&0x0090	;r3 As==00

	// Turn on backlight
//	LCD_PORT |= LCD_BACKLIGHT_BIT;
}
    c4b8:	30 41       	ret			

0000c4ba <lcd_spiwrite_byte>:

void lcd_spiwrite_byte( unsigned char data )
{
	LCDSPI_DATA = data;
    c4ba:	4f 4f       	mov.b	r15,	r15	
    c4bc:	82 4f 92 00 	mov	r15,	&0x0092	
	LCDSPI_CTRL |= LCDSPI_CTRL_EN;
    c4c0:	92 d3 90 00 	bis	#1,	&0x0090	;r3 As==01

	while ( LCDSPI_CTRL & LCDSPI_CTRL_EN )
    c4c4:	92 b3 90 00 	bit	#1,	&0x0090	;r3 As==01
    c4c8:	fd 23       	jnz	$-4      	;abs 0xc4c4
		;
}
    c4ca:	30 41       	ret			

0000c4cc <lcd_writecommand>:

void lcd_writecommand( unsigned char cmd )
{
	LCD_PORT &= ~LCD_RS_BIT;
    c4cc:	f2 f0 df ff 	and.b	#-33,	&0x0029	;#0xffdf
    c4d0:	29 00 
	LCD_PORT &= ~LCD_CSN_BIT;
    c4d2:	f2 f0 fb ff 	and.b	#-5,	&0x0029	;#0xfffb
    c4d6:	29 00 
//	LCD_PORT |= LCD_BACKLIGHT_BIT;
}

void lcd_spiwrite_byte( unsigned char data )
{
	LCDSPI_DATA = data;
    c4d8:	4f 4f       	mov.b	r15,	r15	
    c4da:	82 4f 92 00 	mov	r15,	&0x0092	
	LCDSPI_CTRL |= LCDSPI_CTRL_EN;
    c4de:	92 d3 90 00 	bis	#1,	&0x0090	;r3 As==01

	while ( LCDSPI_CTRL & LCDSPI_CTRL_EN )
    c4e2:	92 b3 90 00 	bit	#1,	&0x0090	;r3 As==01
    c4e6:	fd 23       	jnz	$-4      	;abs 0xc4e2
	LCD_PORT &= ~LCD_RS_BIT;
	LCD_PORT &= ~LCD_CSN_BIT;
	
	lcd_spiwrite_byte( cmd );

	LCD_PORT |= LCD_CSN_BIT;
    c4e8:	e2 d2 29 00 	bis.b	#4,	&0x0029	;r2 As==10
}
    c4ec:	30 41       	ret			

0000c4ee <lcd_writedata>:

void lcd_writedata( unsigned char data )
{
	LCD_PORT |= LCD_RS_BIT;
    c4ee:	f2 d0 20 00 	bis.b	#32,	&0x0029	;#0x0020
    c4f2:	29 00 
	LCD_PORT &= ~LCD_CSN_BIT;
    c4f4:	f2 f0 fb ff 	and.b	#-5,	&0x0029	;#0xfffb
    c4f8:	29 00 
//	LCD_PORT |= LCD_BACKLIGHT_BIT;
}

void lcd_spiwrite_byte( unsigned char data )
{
	LCDSPI_DATA = data;
    c4fa:	4f 4f       	mov.b	r15,	r15	
    c4fc:	82 4f 92 00 	mov	r15,	&0x0092	
	LCDSPI_CTRL |= LCDSPI_CTRL_EN;
    c500:	92 d3 90 00 	bis	#1,	&0x0090	;r3 As==01

	while ( LCDSPI_CTRL & LCDSPI_CTRL_EN )
    c504:	92 b3 90 00 	bit	#1,	&0x0090	;r3 As==01
    c508:	fd 23       	jnz	$-4      	;abs 0xc504
	LCD_PORT |= LCD_RS_BIT;
	LCD_PORT &= ~LCD_CSN_BIT;
	
	lcd_spiwrite_byte( data );

	LCD_PORT |= LCD_CSN_BIT;
    c50a:	e2 d2 29 00 	bis.b	#4,	&0x0029	;r2 As==10
}
    c50e:	30 41       	ret			

0000c510 <commandList>:

 
// Companion code to the above tables.  Reads and issues
// a series of LCD commands stored in PROGMEM byte array.
void commandList(const unsigned char *addr) 
{
    c510:	0b 12       	push	r11		
    c512:	0a 12       	push	r10		
    c514:	09 12       	push	r9		
    c516:	08 12       	push	r8		

  unsigned char  numCommands, numArgs;
  unsigned int ms;

  numCommands = *addr++;   // Number of commands to follow
    c518:	6a 4f       	mov.b	@r15,	r10	
    c51a:	0b 4f       	mov	r15,	r11	
    c51c:	1b 53       	inc	r11		
  while(numCommands--) {                 // For each command...
    c51e:	4a 93       	tst.b	r10		
    c520:	42 24       	jz	$+134    	;abs 0xc5a6
    lcd_writecommand( *addr++ ); //   Read, issue command
    c522:	6f 4b       	mov.b	@r11,	r15	
    c524:	0c 4b       	mov	r11,	r12	
    c526:	1c 53       	inc	r12		
		;
}

void lcd_writecommand( unsigned char cmd )
{
	LCD_PORT &= ~LCD_RS_BIT;
    c528:	f2 f0 df ff 	and.b	#-33,	&0x0029	;#0xffdf
    c52c:	29 00 
	LCD_PORT &= ~LCD_CSN_BIT;
    c52e:	f2 f0 fb ff 	and.b	#-5,	&0x0029	;#0xfffb
    c532:	29 00 
//	LCD_PORT |= LCD_BACKLIGHT_BIT;
}

void lcd_spiwrite_byte( unsigned char data )
{
	LCDSPI_DATA = data;
    c534:	82 4f 92 00 	mov	r15,	&0x0092	
	LCDSPI_CTRL |= LCDSPI_CTRL_EN;
    c538:	92 d3 90 00 	bis	#1,	&0x0090	;r3 As==01

	while ( LCDSPI_CTRL & LCDSPI_CTRL_EN )
    c53c:	92 b3 90 00 	bit	#1,	&0x0090	;r3 As==01
    c540:	fd 23       	jnz	$-4      	;abs 0xc53c
	LCD_PORT &= ~LCD_RS_BIT;
	LCD_PORT &= ~LCD_CSN_BIT;
	
	lcd_spiwrite_byte( cmd );

	LCD_PORT |= LCD_CSN_BIT;
    c542:	e2 d2 29 00 	bis.b	#4,	&0x0029	;r2 As==10
  unsigned int ms;

  numCommands = *addr++;   // Number of commands to follow
  while(numCommands--) {                 // For each command...
    lcd_writecommand( *addr++ ); //   Read, issue command
    numArgs  = *addr++;    //   Number of args to follow
    c546:	69 4c       	mov.b	@r12,	r9	
    c548:	1c 53       	inc	r12		
    ms       = numArgs & DELAY;          //   If hibit set, delay follows args
    c54a:	08 49       	mov	r9,	r8	
    c54c:	38 f0 80 00 	and	#128,	r8	;#0x0080
    numArgs &= ~DELAY;                   //   Mask out delay bit
    c550:	79 f0 7f 00 	and.b	#127,	r9	;#0x007f
    c554:	32 24       	jz	$+102    	;abs 0xc5ba
    while(numArgs--) {                   //   For each argument...
    c556:	79 53       	add.b	#-1,	r9	;r3 As==11


 
// Companion code to the above tables.  Reads and issues
// a series of LCD commands stored in PROGMEM byte array.
void commandList(const unsigned char *addr) 
    c558:	49 49       	mov.b	r9,	r9	
    c55a:	0d 4b       	mov	r11,	r13	
    c55c:	3d 50 03 00 	add	#3,	r13	;#0x0003
    c560:	0d 59       	add	r9,	r13	
  unsigned int ms;

  numCommands = *addr++;   // Number of commands to follow
  while(numCommands--) {                 // For each command...
    lcd_writecommand( *addr++ ); //   Read, issue command
    numArgs  = *addr++;    //   Number of args to follow
    c562:	0e 4c       	mov	r12,	r14	
    ms       = numArgs & DELAY;          //   If hibit set, delay follows args
    numArgs &= ~DELAY;                   //   Mask out delay bit
    while(numArgs--) {                   //   For each argument...
      lcd_writedata( *addr++ );  //     Read, issue argument
    c564:	6f 4e       	mov.b	@r14,	r15	
    c566:	1e 53       	inc	r14		
	LCD_PORT |= LCD_CSN_BIT;
}

void lcd_writedata( unsigned char data )
{
	LCD_PORT |= LCD_RS_BIT;
    c568:	f2 d0 20 00 	bis.b	#32,	&0x0029	;#0x0020
    c56c:	29 00 
	LCD_PORT &= ~LCD_CSN_BIT;
    c56e:	f2 f0 fb ff 	and.b	#-5,	&0x0029	;#0xfffb
    c572:	29 00 
//	LCD_PORT |= LCD_BACKLIGHT_BIT;
}

void lcd_spiwrite_byte( unsigned char data )
{
	LCDSPI_DATA = data;
    c574:	82 4f 92 00 	mov	r15,	&0x0092	
	LCDSPI_CTRL |= LCDSPI_CTRL_EN;
    c578:	92 d3 90 00 	bis	#1,	&0x0090	;r3 As==01

	while ( LCDSPI_CTRL & LCDSPI_CTRL_EN )
    c57c:	92 b3 90 00 	bit	#1,	&0x0090	;r3 As==01
    c580:	fd 23       	jnz	$-4      	;abs 0xc57c
	LCD_PORT |= LCD_RS_BIT;
	LCD_PORT &= ~LCD_CSN_BIT;
	
	lcd_spiwrite_byte( data );

	LCD_PORT |= LCD_CSN_BIT;
    c582:	e2 d2 29 00 	bis.b	#4,	&0x0029	;r2 As==10
  while(numCommands--) {                 // For each command...
    lcd_writecommand( *addr++ ); //   Read, issue command
    numArgs  = *addr++;    //   Number of args to follow
    ms       = numArgs & DELAY;          //   If hibit set, delay follows args
    numArgs &= ~DELAY;                   //   Mask out delay bit
    while(numArgs--) {                   //   For each argument...
    c586:	0e 9d       	cmp	r13,	r14	
    c588:	ed 23       	jnz	$-36     	;abs 0xc564


 
// Companion code to the above tables.  Reads and issues
// a series of LCD commands stored in PROGMEM byte array.
void commandList(const unsigned char *addr) 
    c58a:	0b 49       	mov	r9,	r11	
    c58c:	1b 53       	inc	r11		
  while(numCommands--) {                 // For each command...
    lcd_writecommand( *addr++ ); //   Read, issue command
    numArgs  = *addr++;    //   Number of args to follow
    ms       = numArgs & DELAY;          //   If hibit set, delay follows args
    numArgs &= ~DELAY;                   //   Mask out delay bit
    while(numArgs--) {                   //   For each argument...
    c58e:	0b 5c       	add	r12,	r11	
      lcd_writedata( *addr++ );  //     Read, issue argument
    }

    if(ms) {
    c590:	08 93       	tst	r8		
    c592:	07 24       	jz	$+16     	;abs 0xc5a2
      ms = *addr++; // Read post-command delay time (ms)
    c594:	6f 4b       	mov.b	@r11,	r15	
    c596:	1b 53       	inc	r11		
      if(ms == 255) ms = 500;     // If 255, delay for 500 ms
    c598:	3f 90 ff 00 	cmp	#255,	r15	;#0x00ff
    c59c:	09 24       	jz	$+20     	;abs 0xc5b0
      delay_ms(ms);
    c59e:	b0 12 76 c4 	call	#0xc476	
    c5a2:	7a 53       	add.b	#-1,	r10	;r3 As==11
    c5a4:	be 23       	jnz	$-130    	;abs 0xc522
    }
  }
}
    c5a6:	38 41       	pop	r8		
    c5a8:	39 41       	pop	r9		
    c5aa:	3a 41       	pop	r10		
    c5ac:	3b 41       	pop	r11		
    c5ae:	30 41       	ret			
      lcd_writedata( *addr++ );  //     Read, issue argument
    }

    if(ms) {
      ms = *addr++; // Read post-command delay time (ms)
      if(ms == 255) ms = 500;     // If 255, delay for 500 ms
    c5b0:	3f 50 f5 00 	add	#245,	r15	;#0x00f5
      delay_ms(ms);
    c5b4:	b0 12 76 c4 	call	#0xc476	
    c5b8:	f4 3f       	jmp	$-22     	;abs 0xc5a2
  unsigned int ms;

  numCommands = *addr++;   // Number of commands to follow
  while(numCommands--) {                 // For each command...
    lcd_writecommand( *addr++ ); //   Read, issue command
    numArgs  = *addr++;    //   Number of args to follow
    c5ba:	0b 4c       	mov	r12,	r11	
    c5bc:	e9 3f       	jmp	$-44     	;abs 0xc590

0000c5be <commonInit>:
  }
}


void commonInit(const unsigned char *cmdList) 
{
    c5be:	0b 12       	push	r11		
    c5c0:	0b 4f       	mov	r15,	r11	
	colstart  = rowstart = 0; // May be overridden in init func
    c5c2:	c2 43 16 02 	mov.b	#0,	&0x0216	;r3 As==00
    c5c6:	c2 43 15 02 	mov.b	#0,	&0x0215	;r3 As==00


void lcd_spi_init( void )
{
	// Bring high the LCD Chip Select
	LCD_PORT |= LCD_CSN_BIT;
    c5ca:	e2 d2 29 00 	bis.b	#4,	&0x0029	;r2 As==10

	// Set everything low except the clock divider to 4Mhz
	LCDSPI_CTRL = (0x0000);
    c5ce:	82 43 90 00 	mov	#0,	&0x0090	;r3 As==00
	colstart  = rowstart = 0; // May be overridden in init func

	lcd_spi_init();

	// Reset screen (TODO: Optimize this to reset faster)
	LCD_PORT |= LCD_RESET_BIT;
    c5d2:	f2 d0 40 00 	bis.b	#64,	&0x0029	;#0x0040
    c5d6:	29 00 
	delay_ms(500);
    c5d8:	3f 40 f4 01 	mov	#500,	r15	;#0x01f4
    c5dc:	b0 12 76 c4 	call	#0xc476	
	LCD_PORT &= ~LCD_RESET_BIT;
    c5e0:	f2 f0 bf ff 	and.b	#-65,	&0x0029	;#0xffbf
    c5e4:	29 00 
	delay_ms(500);
    c5e6:	3f 40 f4 01 	mov	#500,	r15	;#0x01f4
    c5ea:	b0 12 76 c4 	call	#0xc476	
	LCD_PORT |= LCD_RESET_BIT;
    c5ee:	f2 d0 40 00 	bis.b	#64,	&0x0029	;#0x0040
    c5f2:	29 00 
	delay_ms(500);
    c5f4:	3f 40 f4 01 	mov	#500,	r15	;#0x01f4
    c5f8:	b0 12 76 c4 	call	#0xc476	

	if(cmdList) 
    c5fc:	0b 93       	tst	r11		
    c5fe:	03 24       	jz	$+8      	;abs 0xc606
		commandList(cmdList);
    c600:	0f 4b       	mov	r11,	r15	
    c602:	b0 12 10 c5 	call	#0xc510	
}
    c606:	3b 41       	pop	r11		
    c608:	30 41       	ret			

0000c60a <lcd_init_screen>:


// Initialization for ST7735R screens (green or red tabs)
void lcd_init_screen(unsigned char options) 
{
    c60a:	0b 12       	push	r11		
    c60c:	4b 4f       	mov.b	r15,	r11	
}


void commonInit(const unsigned char *cmdList) 
{
	colstart  = rowstart = 0; // May be overridden in init func
    c60e:	c2 43 16 02 	mov.b	#0,	&0x0216	;r3 As==00
    c612:	c2 43 15 02 	mov.b	#0,	&0x0215	;r3 As==00


void lcd_spi_init( void )
{
	// Bring high the LCD Chip Select
	LCD_PORT |= LCD_CSN_BIT;
    c616:	e2 d2 29 00 	bis.b	#4,	&0x0029	;r2 As==10

	// Set everything low except the clock divider to 4Mhz
	LCDSPI_CTRL = (0x0000);
    c61a:	82 43 90 00 	mov	#0,	&0x0090	;r3 As==00
	colstart  = rowstart = 0; // May be overridden in init func

	lcd_spi_init();

	// Reset screen (TODO: Optimize this to reset faster)
	LCD_PORT |= LCD_RESET_BIT;
    c61e:	f2 d0 40 00 	bis.b	#64,	&0x0029	;#0x0040
    c622:	29 00 
	delay_ms(500);
    c624:	3f 40 f4 01 	mov	#500,	r15	;#0x01f4
    c628:	b0 12 76 c4 	call	#0xc476	
	LCD_PORT &= ~LCD_RESET_BIT;
    c62c:	f2 f0 bf ff 	and.b	#-65,	&0x0029	;#0xffbf
    c630:	29 00 
	delay_ms(500);
    c632:	3f 40 f4 01 	mov	#500,	r15	;#0x01f4
    c636:	b0 12 76 c4 	call	#0xc476	
	LCD_PORT |= LCD_RESET_BIT;
    c63a:	f2 d0 40 00 	bis.b	#64,	&0x0029	;#0x0040
    c63e:	29 00 
	delay_ms(500);
    c640:	3f 40 f4 01 	mov	#500,	r15	;#0x01f4
    c644:	b0 12 76 c4 	call	#0xc476	

	if(cmdList) 
		commandList(cmdList);
    c648:	3f 40 c2 c9 	mov	#-13886,r15	;#0xc9c2
    c64c:	b0 12 10 c5 	call	#0xc510	

// Initialization for ST7735R screens (green or red tabs)
void lcd_init_screen(unsigned char options) 
{
	commonInit(Rcmd1);
	if (options == INITR_GREENTAB) 
    c650:	4b 93       	tst.b	r11		
    c652:	13 20       	jnz	$+40     	;abs 0xc67a
	{
		commandList(Rcmd2green);
    c654:	3f 40 fd c9 	mov	#-13827,r15	;#0xc9fd
    c658:	b0 12 10 c5 	call	#0xc510	
		colstart = 2;
    c65c:	e2 43 15 02 	mov.b	#2,	&0x0215	;r3 As==10
		rowstart = 1;
    c660:	d2 43 16 02 	mov.b	#1,	&0x0216	;r3 As==01
	{
		// colstart, rowstart left at default '0' values
		commandList(Rcmd2red);
	}

	commandList(Rcmd3);
    c664:	3f 40 17 ca 	mov	#-13801,r15	;#0xca17
    c668:	b0 12 10 c5 	call	#0xc510	
    lcd_writecommand(ST7735_MADCTL);
    // TODO: OLD lcd_writedata(0xC0);
    lcd_writedata( 0x60 );
  }

  tabcolor = options;
    c66c:	c2 4b 14 02 	mov.b	r11,	&0x0214	
  // Turn on backlight
  LCD_PORT |= LCD_BACKLIGHT_BIT;
    c670:	f2 d0 10 00 	bis.b	#16,	&0x0029	;#0x0010
    c674:	29 00 
}
    c676:	3b 41       	pop	r11		
    c678:	30 41       	ret			
		rowstart = 1;
	} 
	else 
	{
		// colstart, rowstart left at default '0' values
		commandList(Rcmd2red);
    c67a:	3f 40 0a ca 	mov	#-13814,r15	;#0xca0a
    c67e:	b0 12 10 c5 	call	#0xc510	
	}

	commandList(Rcmd3);
    c682:	3f 40 17 ca 	mov	#-13801,r15	;#0xca17
    c686:	b0 12 10 c5 	call	#0xc510	

  // if black, change MADCTL color filter
  if (options == INITR_BLACKTAB) 
    c68a:	6b 93       	cmp.b	#2,	r11	;r3 As==10
    c68c:	ef 23       	jnz	$-32     	;abs 0xc66c
		;
}

void lcd_writecommand( unsigned char cmd )
{
	LCD_PORT &= ~LCD_RS_BIT;
    c68e:	f2 f0 df ff 	and.b	#-33,	&0x0029	;#0xffdf
    c692:	29 00 
	LCD_PORT &= ~LCD_CSN_BIT;
    c694:	f2 f0 fb ff 	and.b	#-5,	&0x0029	;#0xfffb
    c698:	29 00 
//	LCD_PORT |= LCD_BACKLIGHT_BIT;
}

void lcd_spiwrite_byte( unsigned char data )
{
	LCDSPI_DATA = data;
    c69a:	b2 40 36 00 	mov	#54,	&0x0092	;#0x0036
    c69e:	92 00 
	LCDSPI_CTRL |= LCDSPI_CTRL_EN;
    c6a0:	92 d3 90 00 	bis	#1,	&0x0090	;r3 As==01

	while ( LCDSPI_CTRL & LCDSPI_CTRL_EN )
    c6a4:	92 b3 90 00 	bit	#1,	&0x0090	;r3 As==01
    c6a8:	fd 23       	jnz	$-4      	;abs 0xc6a4
	LCD_PORT &= ~LCD_RS_BIT;
	LCD_PORT &= ~LCD_CSN_BIT;
	
	lcd_spiwrite_byte( cmd );

	LCD_PORT |= LCD_CSN_BIT;
    c6aa:	e2 d2 29 00 	bis.b	#4,	&0x0029	;r2 As==10
}

void lcd_writedata( unsigned char data )
{
	LCD_PORT |= LCD_RS_BIT;
    c6ae:	f2 d0 20 00 	bis.b	#32,	&0x0029	;#0x0020
    c6b2:	29 00 
	LCD_PORT &= ~LCD_CSN_BIT;
    c6b4:	f2 f0 fb ff 	and.b	#-5,	&0x0029	;#0xfffb
    c6b8:	29 00 
//	LCD_PORT |= LCD_BACKLIGHT_BIT;
}

void lcd_spiwrite_byte( unsigned char data )
{
	LCDSPI_DATA = data;
    c6ba:	b2 40 60 00 	mov	#96,	&0x0092	;#0x0060
    c6be:	92 00 
	LCDSPI_CTRL |= LCDSPI_CTRL_EN;
    c6c0:	92 d3 90 00 	bis	#1,	&0x0090	;r3 As==01

	while ( LCDSPI_CTRL & LCDSPI_CTRL_EN )
    c6c4:	92 b3 90 00 	bit	#1,	&0x0090	;r3 As==01
    c6c8:	fd 23       	jnz	$-4      	;abs 0xc6c4
	LCD_PORT |= LCD_RS_BIT;
	LCD_PORT &= ~LCD_CSN_BIT;
	
	lcd_spiwrite_byte( data );

	LCD_PORT |= LCD_CSN_BIT;
    c6ca:	e2 d2 29 00 	bis.b	#4,	&0x0029	;r2 As==10
    lcd_writecommand(ST7735_MADCTL);
    // TODO: OLD lcd_writedata(0xC0);
    lcd_writedata( 0x60 );
  }

  tabcolor = options;
    c6ce:	c2 4b 14 02 	mov.b	r11,	&0x0214	
  // Turn on backlight
  LCD_PORT |= LCD_BACKLIGHT_BIT;
    c6d2:	f2 d0 10 00 	bis.b	#16,	&0x0029	;#0x0010
    c6d6:	29 00 
}
    c6d8:	3b 41       	pop	r11		
    c6da:	30 41       	ret			

0000c6dc <lcd_setAddrWindow>:

void lcd_setAddrWindow( unsigned char x0, unsigned char y0, unsigned char x1, unsigned char y1 )
{
    c6dc:	0b 12       	push	r11		
		;
}

void lcd_writecommand( unsigned char cmd )
{
	LCD_PORT &= ~LCD_RS_BIT;
    c6de:	f2 f0 df ff 	and.b	#-33,	&0x0029	;#0xffdf
    c6e2:	29 00 
	LCD_PORT &= ~LCD_CSN_BIT;
    c6e4:	f2 f0 fb ff 	and.b	#-5,	&0x0029	;#0xfffb
    c6e8:	29 00 
//	LCD_PORT |= LCD_BACKLIGHT_BIT;
}

void lcd_spiwrite_byte( unsigned char data )
{
	LCDSPI_DATA = data;
    c6ea:	b2 40 2a 00 	mov	#42,	&0x0092	;#0x002a
    c6ee:	92 00 
	LCDSPI_CTRL |= LCDSPI_CTRL_EN;
    c6f0:	92 d3 90 00 	bis	#1,	&0x0090	;r3 As==01

	while ( LCDSPI_CTRL & LCDSPI_CTRL_EN )
    c6f4:	1b 42 90 00 	mov	&0x0090,r11	
    c6f8:	1b f3       	and	#1,	r11	;r3 As==01
    c6fa:	fc 23       	jnz	$-6      	;abs 0xc6f4
	LCD_PORT &= ~LCD_RS_BIT;
	LCD_PORT &= ~LCD_CSN_BIT;
	
	lcd_spiwrite_byte( cmd );

	LCD_PORT |= LCD_CSN_BIT;
    c6fc:	e2 d2 29 00 	bis.b	#4,	&0x0029	;r2 As==10
}

void lcd_writedata( unsigned char data )
{
	LCD_PORT |= LCD_RS_BIT;
    c700:	f2 d0 20 00 	bis.b	#32,	&0x0029	;#0x0020
    c704:	29 00 
	LCD_PORT &= ~LCD_CSN_BIT;
    c706:	f2 f0 fb ff 	and.b	#-5,	&0x0029	;#0xfffb
    c70a:	29 00 
//	LCD_PORT |= LCD_BACKLIGHT_BIT;
}

void lcd_spiwrite_byte( unsigned char data )
{
	LCDSPI_DATA = data;
    c70c:	82 4b 92 00 	mov	r11,	&0x0092	
	LCDSPI_CTRL |= LCDSPI_CTRL_EN;
    c710:	92 d3 90 00 	bis	#1,	&0x0090	;r3 As==01

	while ( LCDSPI_CTRL & LCDSPI_CTRL_EN )
    c714:	92 b3 90 00 	bit	#1,	&0x0090	;r3 As==01
    c718:	fd 23       	jnz	$-4      	;abs 0xc714
	LCD_PORT |= LCD_RS_BIT;
	LCD_PORT &= ~LCD_CSN_BIT;
	
	lcd_spiwrite_byte( data );

	LCD_PORT |= LCD_CSN_BIT;
    c71a:	e2 d2 29 00 	bis.b	#4,	&0x0029	;r2 As==10
void lcd_setAddrWindow( unsigned char x0, unsigned char y0, unsigned char x1, unsigned char y1 )
{

  lcd_writecommand(ST7735_CASET); // Column addr set
  lcd_writedata(0x00);
  lcd_writedata(x0+colstart);     // XSTART 
    c71e:	5f 52 15 02 	add.b	&0x0215,r15	
	LCD_PORT |= LCD_CSN_BIT;
}

void lcd_writedata( unsigned char data )
{
	LCD_PORT |= LCD_RS_BIT;
    c722:	f2 d0 20 00 	bis.b	#32,	&0x0029	;#0x0020
    c726:	29 00 
	LCD_PORT &= ~LCD_CSN_BIT;
    c728:	f2 f0 fb ff 	and.b	#-5,	&0x0029	;#0xfffb
    c72c:	29 00 
//	LCD_PORT |= LCD_BACKLIGHT_BIT;
}

void lcd_spiwrite_byte( unsigned char data )
{
	LCDSPI_DATA = data;
    c72e:	4f 4f       	mov.b	r15,	r15	
    c730:	82 4f 92 00 	mov	r15,	&0x0092	
	LCDSPI_CTRL |= LCDSPI_CTRL_EN;
    c734:	92 d3 90 00 	bis	#1,	&0x0090	;r3 As==01

	while ( LCDSPI_CTRL & LCDSPI_CTRL_EN )
    c738:	1f 42 90 00 	mov	&0x0090,r15	
    c73c:	1f f3       	and	#1,	r15	;r3 As==01
    c73e:	fc 23       	jnz	$-6      	;abs 0xc738
	LCD_PORT |= LCD_RS_BIT;
	LCD_PORT &= ~LCD_CSN_BIT;
	
	lcd_spiwrite_byte( data );

	LCD_PORT |= LCD_CSN_BIT;
    c740:	e2 d2 29 00 	bis.b	#4,	&0x0029	;r2 As==10
	LCD_PORT |= LCD_CSN_BIT;
}

void lcd_writedata( unsigned char data )
{
	LCD_PORT |= LCD_RS_BIT;
    c744:	f2 d0 20 00 	bis.b	#32,	&0x0029	;#0x0020
    c748:	29 00 
	LCD_PORT &= ~LCD_CSN_BIT;
    c74a:	f2 f0 fb ff 	and.b	#-5,	&0x0029	;#0xfffb
    c74e:	29 00 
//	LCD_PORT |= LCD_BACKLIGHT_BIT;
}

void lcd_spiwrite_byte( unsigned char data )
{
	LCDSPI_DATA = data;
    c750:	82 4f 92 00 	mov	r15,	&0x0092	
	LCDSPI_CTRL |= LCDSPI_CTRL_EN;
    c754:	92 d3 90 00 	bis	#1,	&0x0090	;r3 As==01

	while ( LCDSPI_CTRL & LCDSPI_CTRL_EN )
    c758:	92 b3 90 00 	bit	#1,	&0x0090	;r3 As==01
    c75c:	fd 23       	jnz	$-4      	;abs 0xc758
	LCD_PORT |= LCD_RS_BIT;
	LCD_PORT &= ~LCD_CSN_BIT;
	
	lcd_spiwrite_byte( data );

	LCD_PORT |= LCD_CSN_BIT;
    c75e:	e2 d2 29 00 	bis.b	#4,	&0x0029	;r2 As==10

  lcd_writecommand(ST7735_CASET); // Column addr set
  lcd_writedata(0x00);
  lcd_writedata(x0+colstart);     // XSTART 
  lcd_writedata(0x00);
  lcd_writedata(x1+colstart);     // XEND
    c762:	5d 52 15 02 	add.b	&0x0215,r13	
	LCD_PORT |= LCD_CSN_BIT;
}

void lcd_writedata( unsigned char data )
{
	LCD_PORT |= LCD_RS_BIT;
    c766:	f2 d0 20 00 	bis.b	#32,	&0x0029	;#0x0020
    c76a:	29 00 
	LCD_PORT &= ~LCD_CSN_BIT;
    c76c:	f2 f0 fb ff 	and.b	#-5,	&0x0029	;#0xfffb
    c770:	29 00 
//	LCD_PORT |= LCD_BACKLIGHT_BIT;
}

void lcd_spiwrite_byte( unsigned char data )
{
	LCDSPI_DATA = data;
    c772:	4d 4d       	mov.b	r13,	r13	
    c774:	82 4d 92 00 	mov	r13,	&0x0092	
	LCDSPI_CTRL |= LCDSPI_CTRL_EN;
    c778:	92 d3 90 00 	bis	#1,	&0x0090	;r3 As==01

	while ( LCDSPI_CTRL & LCDSPI_CTRL_EN )
    c77c:	92 b3 90 00 	bit	#1,	&0x0090	;r3 As==01
    c780:	fd 23       	jnz	$-4      	;abs 0xc77c
	LCD_PORT |= LCD_RS_BIT;
	LCD_PORT &= ~LCD_CSN_BIT;
	
	lcd_spiwrite_byte( data );

	LCD_PORT |= LCD_CSN_BIT;
    c782:	e2 d2 29 00 	bis.b	#4,	&0x0029	;r2 As==10
		;
}

void lcd_writecommand( unsigned char cmd )
{
	LCD_PORT &= ~LCD_RS_BIT;
    c786:	f2 f0 df ff 	and.b	#-33,	&0x0029	;#0xffdf
    c78a:	29 00 
	LCD_PORT &= ~LCD_CSN_BIT;
    c78c:	f2 f0 fb ff 	and.b	#-5,	&0x0029	;#0xfffb
    c790:	29 00 
//	LCD_PORT |= LCD_BACKLIGHT_BIT;
}

void lcd_spiwrite_byte( unsigned char data )
{
	LCDSPI_DATA = data;
    c792:	b2 40 2b 00 	mov	#43,	&0x0092	;#0x002b
    c796:	92 00 
	LCDSPI_CTRL |= LCDSPI_CTRL_EN;
    c798:	92 d3 90 00 	bis	#1,	&0x0090	;r3 As==01

	while ( LCDSPI_CTRL & LCDSPI_CTRL_EN )
    c79c:	1f 42 90 00 	mov	&0x0090,r15	
    c7a0:	1f f3       	and	#1,	r15	;r3 As==01
    c7a2:	fc 23       	jnz	$-6      	;abs 0xc79c
	LCD_PORT &= ~LCD_RS_BIT;
	LCD_PORT &= ~LCD_CSN_BIT;
	
	lcd_spiwrite_byte( cmd );

	LCD_PORT |= LCD_CSN_BIT;
    c7a4:	e2 d2 29 00 	bis.b	#4,	&0x0029	;r2 As==10
}

void lcd_writedata( unsigned char data )
{
	LCD_PORT |= LCD_RS_BIT;
    c7a8:	f2 d0 20 00 	bis.b	#32,	&0x0029	;#0x0020
    c7ac:	29 00 
	LCD_PORT &= ~LCD_CSN_BIT;
    c7ae:	f2 f0 fb ff 	and.b	#-5,	&0x0029	;#0xfffb
    c7b2:	29 00 
//	LCD_PORT |= LCD_BACKLIGHT_BIT;
}

void lcd_spiwrite_byte( unsigned char data )
{
	LCDSPI_DATA = data;
    c7b4:	82 4f 92 00 	mov	r15,	&0x0092	
	LCDSPI_CTRL |= LCDSPI_CTRL_EN;
    c7b8:	92 d3 90 00 	bis	#1,	&0x0090	;r3 As==01

	while ( LCDSPI_CTRL & LCDSPI_CTRL_EN )
    c7bc:	92 b3 90 00 	bit	#1,	&0x0090	;r3 As==01
    c7c0:	fd 23       	jnz	$-4      	;abs 0xc7bc
	LCD_PORT |= LCD_RS_BIT;
	LCD_PORT &= ~LCD_CSN_BIT;
	
	lcd_spiwrite_byte( data );

	LCD_PORT |= LCD_CSN_BIT;
    c7c2:	e2 d2 29 00 	bis.b	#4,	&0x0029	;r2 As==10
  lcd_writedata(0x00);
  lcd_writedata(x1+colstart);     // XEND

  lcd_writecommand(ST7735_RASET); // Row addr set
  lcd_writedata(0x00);
  lcd_writedata(y0+rowstart);     // YSTART
    c7c6:	5e 52 16 02 	add.b	&0x0216,r14	
	LCD_PORT |= LCD_CSN_BIT;
}

void lcd_writedata( unsigned char data )
{
	LCD_PORT |= LCD_RS_BIT;
    c7ca:	f2 d0 20 00 	bis.b	#32,	&0x0029	;#0x0020
    c7ce:	29 00 
	LCD_PORT &= ~LCD_CSN_BIT;
    c7d0:	f2 f0 fb ff 	and.b	#-5,	&0x0029	;#0xfffb
    c7d4:	29 00 
//	LCD_PORT |= LCD_BACKLIGHT_BIT;
}

void lcd_spiwrite_byte( unsigned char data )
{
	LCDSPI_DATA = data;
    c7d6:	4e 4e       	mov.b	r14,	r14	
    c7d8:	82 4e 92 00 	mov	r14,	&0x0092	
	LCDSPI_CTRL |= LCDSPI_CTRL_EN;
    c7dc:	92 d3 90 00 	bis	#1,	&0x0090	;r3 As==01

	while ( LCDSPI_CTRL & LCDSPI_CTRL_EN )
    c7e0:	1f 42 90 00 	mov	&0x0090,r15	
    c7e4:	1f f3       	and	#1,	r15	;r3 As==01
    c7e6:	fc 23       	jnz	$-6      	;abs 0xc7e0
	LCD_PORT |= LCD_RS_BIT;
	LCD_PORT &= ~LCD_CSN_BIT;
	
	lcd_spiwrite_byte( data );

	LCD_PORT |= LCD_CSN_BIT;
    c7e8:	e2 d2 29 00 	bis.b	#4,	&0x0029	;r2 As==10
	LCD_PORT |= LCD_CSN_BIT;
}

void lcd_writedata( unsigned char data )
{
	LCD_PORT |= LCD_RS_BIT;
    c7ec:	f2 d0 20 00 	bis.b	#32,	&0x0029	;#0x0020
    c7f0:	29 00 
	LCD_PORT &= ~LCD_CSN_BIT;
    c7f2:	f2 f0 fb ff 	and.b	#-5,	&0x0029	;#0xfffb
    c7f6:	29 00 
//	LCD_PORT |= LCD_BACKLIGHT_BIT;
}

void lcd_spiwrite_byte( unsigned char data )
{
	LCDSPI_DATA = data;
    c7f8:	82 4f 92 00 	mov	r15,	&0x0092	
	LCDSPI_CTRL |= LCDSPI_CTRL_EN;
    c7fc:	92 d3 90 00 	bis	#1,	&0x0090	;r3 As==01

	while ( LCDSPI_CTRL & LCDSPI_CTRL_EN )
    c800:	92 b3 90 00 	bit	#1,	&0x0090	;r3 As==01
    c804:	fd 23       	jnz	$-4      	;abs 0xc800
	LCD_PORT |= LCD_RS_BIT;
	LCD_PORT &= ~LCD_CSN_BIT;
	
	lcd_spiwrite_byte( data );

	LCD_PORT |= LCD_CSN_BIT;
    c806:	e2 d2 29 00 	bis.b	#4,	&0x0029	;r2 As==10

  lcd_writecommand(ST7735_RASET); // Row addr set
  lcd_writedata(0x00);
  lcd_writedata(y0+rowstart);     // YSTART
  lcd_writedata(0x00);
  lcd_writedata(y1+rowstart);     // YEND
    c80a:	5c 52 16 02 	add.b	&0x0216,r12	
	LCD_PORT |= LCD_CSN_BIT;
}

void lcd_writedata( unsigned char data )
{
	LCD_PORT |= LCD_RS_BIT;
    c80e:	f2 d0 20 00 	bis.b	#32,	&0x0029	;#0x0020
    c812:	29 00 
	LCD_PORT &= ~LCD_CSN_BIT;
    c814:	f2 f0 fb ff 	and.b	#-5,	&0x0029	;#0xfffb
    c818:	29 00 
//	LCD_PORT |= LCD_BACKLIGHT_BIT;
}

void lcd_spiwrite_byte( unsigned char data )
{
	LCDSPI_DATA = data;
    c81a:	4c 4c       	mov.b	r12,	r12	
    c81c:	82 4c 92 00 	mov	r12,	&0x0092	
	LCDSPI_CTRL |= LCDSPI_CTRL_EN;
    c820:	92 d3 90 00 	bis	#1,	&0x0090	;r3 As==01

	while ( LCDSPI_CTRL & LCDSPI_CTRL_EN )
    c824:	92 b3 90 00 	bit	#1,	&0x0090	;r3 As==01
    c828:	fd 23       	jnz	$-4      	;abs 0xc824
	LCD_PORT |= LCD_RS_BIT;
	LCD_PORT &= ~LCD_CSN_BIT;
	
	lcd_spiwrite_byte( data );

	LCD_PORT |= LCD_CSN_BIT;
    c82a:	e2 d2 29 00 	bis.b	#4,	&0x0029	;r2 As==10
		;
}

void lcd_writecommand( unsigned char cmd )
{
	LCD_PORT &= ~LCD_RS_BIT;
    c82e:	f2 f0 df ff 	and.b	#-33,	&0x0029	;#0xffdf
    c832:	29 00 
	LCD_PORT &= ~LCD_CSN_BIT;
    c834:	f2 f0 fb ff 	and.b	#-5,	&0x0029	;#0xfffb
    c838:	29 00 
//	LCD_PORT |= LCD_BACKLIGHT_BIT;
}

void lcd_spiwrite_byte( unsigned char data )
{
	LCDSPI_DATA = data;
    c83a:	b2 40 2c 00 	mov	#44,	&0x0092	;#0x002c
    c83e:	92 00 
	LCDSPI_CTRL |= LCDSPI_CTRL_EN;
    c840:	92 d3 90 00 	bis	#1,	&0x0090	;r3 As==01

	while ( LCDSPI_CTRL & LCDSPI_CTRL_EN )
    c844:	92 b3 90 00 	bit	#1,	&0x0090	;r3 As==01
    c848:	fd 23       	jnz	$-4      	;abs 0xc844
	LCD_PORT &= ~LCD_RS_BIT;
	LCD_PORT &= ~LCD_CSN_BIT;
	
	lcd_spiwrite_byte( cmd );

	LCD_PORT |= LCD_CSN_BIT;
    c84a:	e2 d2 29 00 	bis.b	#4,	&0x0029	;r2 As==10
  lcd_writedata(y0+rowstart);     // YSTART
  lcd_writedata(0x00);
  lcd_writedata(y1+rowstart);     // YEND

  lcd_writecommand(ST7735_RAMWR); // write to RAM
}
    c84e:	3b 41       	pop	r11		
    c850:	30 41       	ret			

0000c852 <lcd_fillRect>:



// fill a rectangle
void lcd_fillRect( unsigned int x, unsigned int y, unsigned int w, unsigned int h, unsigned int color )
{
    c852:	0b 12       	push	r11		
    c854:	0a 12       	push	r10		
    c856:	09 12       	push	r9		
    c858:	09 4d       	mov	r13,	r9	
    c85a:	0a 4c       	mov	r12,	r10	
  unsigned char hi, lo;

  // rudimentary clipping (drawChar w/big text requires this)
  if((x >= _width) || (y >= _height)) return;
    c85c:	5d 42 00 02 	mov.b	&0x0200,r13	
    c860:	0f 9d       	cmp	r13,	r15	
    c862:	42 2c       	jc	$+134    	;abs 0xc8e8
    c864:	5c 42 02 02 	mov.b	&0x0202,r12	
    c868:	0e 9c       	cmp	r12,	r14	
    c86a:	3e 2c       	jc	$+126    	;abs 0xc8e8
  if((x + w - 1) >= _width)  w = _width  - x;
    c86c:	0b 4f       	mov	r15,	r11	
    c86e:	3b 53       	add	#-1,	r11	;r3 As==11
    c870:	0b 59       	add	r9,	r11	
    c872:	0b 9d       	cmp	r13,	r11	
    c874:	02 28       	jnc	$+6      	;abs 0xc87a
    c876:	09 4d       	mov	r13,	r9	
    c878:	09 8f       	sub	r15,	r9	
  if((y + h - 1) >= _height) h = _height - y;
    c87a:	0d 4e       	mov	r14,	r13	
    c87c:	3d 53       	add	#-1,	r13	;r3 As==11
    c87e:	0d 5a       	add	r10,	r13	
    c880:	0d 9c       	cmp	r12,	r13	
    c882:	02 28       	jnc	$+6      	;abs 0xc888
    c884:	0a 4c       	mov	r12,	r10	
    c886:	0a 8e       	sub	r14,	r10	

  lcd_setAddrWindow(x, y, x+w-1, y+h-1);
    c888:	4c 4e       	mov.b	r14,	r12	
    c88a:	4d 4f       	mov.b	r15,	r13	
    c88c:	7c 53       	add.b	#-1,	r12	;r3 As==11
    c88e:	7d 53       	add.b	#-1,	r13	;r3 As==11
    c890:	4c 5a       	add.b	r10,	r12	
    c892:	4d 59       	add.b	r9,	r13	
    c894:	b0 12 dc c6 	call	#0xc6dc	

  hi = color >> 8, lo = color;
    c898:	1b 41 08 00 	mov	8(r1),	r11	;0x0008(r1)
    c89c:	8b 10       	swpb	r11		
    c89e:	5c 41 08 00 	mov.b	8(r1),	r12	;0x0008(r1)

  LCD_PORT |= LCD_RS_BIT;
    c8a2:	f2 d0 20 00 	bis.b	#32,	&0x0029	;#0x0020
    c8a6:	29 00 
  LCD_PORT &= ~LCD_CSN_BIT;
    c8a8:	f2 f0 fb ff 	and.b	#-5,	&0x0029	;#0xfffb
    c8ac:	29 00 
  
  for(y=h; y>0; y--) 
    c8ae:	0a 93       	tst	r10		
    c8b0:	19 24       	jz	$+52     	;abs 0xc8e4
  {
    for(x=w; x>0; x--) 
    c8b2:	4b 4b       	mov.b	r11,	r11	
    c8b4:	4c 4c       	mov.b	r12,	r12	
    c8b6:	09 93       	tst	r9		
    c8b8:	13 24       	jz	$+40     	;abs 0xc8e0
    c8ba:	0e 49       	mov	r9,	r14	
//	LCD_PORT |= LCD_BACKLIGHT_BIT;
}

void lcd_spiwrite_byte( unsigned char data )
{
	LCDSPI_DATA = data;
    c8bc:	82 4b 92 00 	mov	r11,	&0x0092	
	LCDSPI_CTRL |= LCDSPI_CTRL_EN;
    c8c0:	92 d3 90 00 	bis	#1,	&0x0090	;r3 As==01

	while ( LCDSPI_CTRL & LCDSPI_CTRL_EN )
    c8c4:	92 b3 90 00 	bit	#1,	&0x0090	;r3 As==01
    c8c8:	fd 23       	jnz	$-4      	;abs 0xc8c4
//	LCD_PORT |= LCD_BACKLIGHT_BIT;
}

void lcd_spiwrite_byte( unsigned char data )
{
	LCDSPI_DATA = data;
    c8ca:	82 4c 92 00 	mov	r12,	&0x0092	
	LCDSPI_CTRL |= LCDSPI_CTRL_EN;
    c8ce:	92 d3 90 00 	bis	#1,	&0x0090	;r3 As==01

	while ( LCDSPI_CTRL & LCDSPI_CTRL_EN )
    c8d2:	1f 42 90 00 	mov	&0x0090,r15	
    c8d6:	1f f3       	and	#1,	r15	;r3 As==01
    c8d8:	fc 23       	jnz	$-6      	;abs 0xc8d2
  LCD_PORT |= LCD_RS_BIT;
  LCD_PORT &= ~LCD_CSN_BIT;
  
  for(y=h; y>0; y--) 
  {
    for(x=w; x>0; x--) 
    c8da:	3e 53       	add	#-1,	r14	;r3 As==11
    c8dc:	0e 9f       	cmp	r15,	r14	
    c8de:	ee 23       	jnz	$-34     	;abs 0xc8bc
  hi = color >> 8, lo = color;

  LCD_PORT |= LCD_RS_BIT;
  LCD_PORT &= ~LCD_CSN_BIT;
  
  for(y=h; y>0; y--) 
    c8e0:	3a 53       	add	#-1,	r10	;r3 As==11
    c8e2:	e9 23       	jnz	$-44     	;abs 0xc8b6
      lcd_spiwrite_byte(hi);
      lcd_spiwrite_byte(lo);
    }
  }

  LCD_PORT |= LCD_CSN_BIT;
    c8e4:	e2 d2 29 00 	bis.b	#4,	&0x0029	;r2 As==10
}
    c8e8:	39 41       	pop	r9		
    c8ea:	3a 41       	pop	r10		
    c8ec:	3b 41       	pop	r11		
    c8ee:	30 41       	ret			

0000c8f0 <lcd_fillScreen>:
 
void lcd_fillScreen( unsigned int color ) 
{
    c8f0:	0b 12       	push	r11		
    c8f2:	0a 12       	push	r10		
    c8f4:	09 12       	push	r9		
    c8f6:	09 4f       	mov	r15,	r9	
  lcd_fillRect(0, 0,  _width, _height, color);
    c8f8:	5c 42 02 02 	mov.b	&0x0202,r12	
    c8fc:	5d 42 00 02 	mov.b	&0x0200,r13	
    c900:	4a 4d       	mov.b	r13,	r10	
void lcd_fillRect( unsigned int x, unsigned int y, unsigned int w, unsigned int h, unsigned int color )
{
  unsigned char hi, lo;

  // rudimentary clipping (drawChar w/big text requires this)
  if((x >= _width) || (y >= _height)) return;
    c902:	4d 93       	tst.b	r13		
    c904:	2c 24       	jz	$+90     	;abs 0xc95e
    c906:	4c 93       	tst.b	r12		
    c908:	2a 24       	jz	$+86     	;abs 0xc95e
  LCD_PORT |= LCD_CSN_BIT;
}
 
void lcd_fillScreen( unsigned int color ) 
{
  lcd_fillRect(0, 0,  _width, _height, color);
    c90a:	4b 4c       	mov.b	r12,	r11	
  // rudimentary clipping (drawChar w/big text requires this)
  if((x >= _width) || (y >= _height)) return;
  if((x + w - 1) >= _width)  w = _width  - x;
  if((y + h - 1) >= _height) h = _height - y;

  lcd_setAddrWindow(x, y, x+w-1, y+h-1);
    c90c:	7c 53       	add.b	#-1,	r12	;r3 As==11
    c90e:	7d 53       	add.b	#-1,	r13	;r3 As==11
    c910:	4e 43       	clr.b	r14		
    c912:	4f 4e       	mov.b	r14,	r15	
    c914:	b0 12 dc c6 	call	#0xc6dc	

  hi = color >> 8, lo = color;
    c918:	0c 49       	mov	r9,	r12	
    c91a:	8c 10       	swpb	r12		

  LCD_PORT |= LCD_RS_BIT;
    c91c:	f2 d0 20 00 	bis.b	#32,	&0x0029	;#0x0020
    c920:	29 00 
  LCD_PORT &= ~LCD_CSN_BIT;
    c922:	f2 f0 fb ff 	and.b	#-5,	&0x0029	;#0xfffb
    c926:	29 00 
  
  for(y=h; y>0; y--) 
  {
    for(x=w; x>0; x--) 
    c928:	4c 4c       	mov.b	r12,	r12	
    c92a:	4d 49       	mov.b	r9,	r13	
    c92c:	0a 93       	tst	r10		
    c92e:	13 24       	jz	$+40     	;abs 0xc956
    c930:	0e 4a       	mov	r10,	r14	
//	LCD_PORT |= LCD_BACKLIGHT_BIT;
}

void lcd_spiwrite_byte( unsigned char data )
{
	LCDSPI_DATA = data;
    c932:	82 4c 92 00 	mov	r12,	&0x0092	
	LCDSPI_CTRL |= LCDSPI_CTRL_EN;
    c936:	92 d3 90 00 	bis	#1,	&0x0090	;r3 As==01

	while ( LCDSPI_CTRL & LCDSPI_CTRL_EN )
    c93a:	92 b3 90 00 	bit	#1,	&0x0090	;r3 As==01
    c93e:	fd 23       	jnz	$-4      	;abs 0xc93a
//	LCD_PORT |= LCD_BACKLIGHT_BIT;
}

void lcd_spiwrite_byte( unsigned char data )
{
	LCDSPI_DATA = data;
    c940:	82 4d 92 00 	mov	r13,	&0x0092	
	LCDSPI_CTRL |= LCDSPI_CTRL_EN;
    c944:	92 d3 90 00 	bis	#1,	&0x0090	;r3 As==01

	while ( LCDSPI_CTRL & LCDSPI_CTRL_EN )
    c948:	1f 42 90 00 	mov	&0x0090,r15	
    c94c:	1f f3       	and	#1,	r15	;r3 As==01
    c94e:	fc 23       	jnz	$-6      	;abs 0xc948
  LCD_PORT |= LCD_RS_BIT;
  LCD_PORT &= ~LCD_CSN_BIT;
  
  for(y=h; y>0; y--) 
  {
    for(x=w; x>0; x--) 
    c950:	3e 53       	add	#-1,	r14	;r3 As==11
    c952:	0e 9f       	cmp	r15,	r14	
    c954:	ee 23       	jnz	$-34     	;abs 0xc932
  hi = color >> 8, lo = color;

  LCD_PORT |= LCD_RS_BIT;
  LCD_PORT &= ~LCD_CSN_BIT;
  
  for(y=h; y>0; y--) 
    c956:	3b 53       	add	#-1,	r11	;r3 As==11
    c958:	e9 23       	jnz	$-44     	;abs 0xc92c
      lcd_spiwrite_byte(hi);
      lcd_spiwrite_byte(lo);
    }
  }

  LCD_PORT |= LCD_CSN_BIT;
    c95a:	e2 d2 29 00 	bis.b	#4,	&0x0029	;r2 As==10
}
 
void lcd_fillScreen( unsigned int color ) 
{
  lcd_fillRect(0, 0,  _width, _height, color);
}
    c95e:	39 41       	pop	r9		
    c960:	3a 41       	pop	r10		
    c962:	3b 41       	pop	r11		
    c964:	30 41       	ret			

0000c966 <lcd_drawPixel>:

void lcd_drawPixel( unsigned int x, unsigned int y, unsigned int color) 
{
    c966:	0b 12       	push	r11		
    c968:	0b 4d       	mov	r13,	r11	

  if ((x >= _width) || (y >= _height)) return;
    c96a:	5c 42 00 02 	mov.b	&0x0200,r12	
    c96e:	0f 9c       	cmp	r12,	r15	
    c970:	04 2c       	jc	$+10     	;abs 0xc97a
    c972:	5d 42 02 02 	mov.b	&0x0202,r13	
    c976:	0e 9d       	cmp	r13,	r14	
    c978:	02 28       	jnc	$+6      	;abs 0xc97e
  
  lcd_spiwrite_byte(color >> 8);
  lcd_spiwrite_byte(color);

  LCD_PORT |= LCD_CSN_BIT;
}
    c97a:	3b 41       	pop	r11		
    c97c:	30 41       	ret			
void lcd_drawPixel( unsigned int x, unsigned int y, unsigned int color) 
{

  if ((x >= _width) || (y >= _height)) return;

  lcd_setAddrWindow(x,y,x+1,y+1);
    c97e:	4c 4e       	mov.b	r14,	r12	
    c980:	4d 4f       	mov.b	r15,	r13	
    c982:	5c 53       	inc.b	r12		
    c984:	5d 53       	inc.b	r13		
    c986:	b0 12 dc c6 	call	#0xc6dc	

  LCD_PORT |= LCD_RS_BIT;
    c98a:	f2 d0 20 00 	bis.b	#32,	&0x0029	;#0x0020
    c98e:	29 00 
  LCD_PORT &= ~LCD_CSN_BIT;
    c990:	f2 f0 fb ff 	and.b	#-5,	&0x0029	;#0xfffb
    c994:	29 00 
  
  lcd_spiwrite_byte(color >> 8);
    c996:	0f 4b       	mov	r11,	r15	
    c998:	8f 10       	swpb	r15		
//	LCD_PORT |= LCD_BACKLIGHT_BIT;
}

void lcd_spiwrite_byte( unsigned char data )
{
	LCDSPI_DATA = data;
    c99a:	4f 4f       	mov.b	r15,	r15	
    c99c:	82 4f 92 00 	mov	r15,	&0x0092	
	LCDSPI_CTRL |= LCDSPI_CTRL_EN;
    c9a0:	92 d3 90 00 	bis	#1,	&0x0090	;r3 As==01

	while ( LCDSPI_CTRL & LCDSPI_CTRL_EN )
    c9a4:	92 b3 90 00 	bit	#1,	&0x0090	;r3 As==01
    c9a8:	fd 23       	jnz	$-4      	;abs 0xc9a4
//	LCD_PORT |= LCD_BACKLIGHT_BIT;
}

void lcd_spiwrite_byte( unsigned char data )
{
	LCDSPI_DATA = data;
    c9aa:	4b 4b       	mov.b	r11,	r11	
    c9ac:	82 4b 92 00 	mov	r11,	&0x0092	
	LCDSPI_CTRL |= LCDSPI_CTRL_EN;
    c9b0:	92 d3 90 00 	bis	#1,	&0x0090	;r3 As==01

	while ( LCDSPI_CTRL & LCDSPI_CTRL_EN )
    c9b4:	92 b3 90 00 	bit	#1,	&0x0090	;r3 As==01
    c9b8:	fd 23       	jnz	$-4      	;abs 0xc9b4
  LCD_PORT &= ~LCD_CSN_BIT;
  
  lcd_spiwrite_byte(color >> 8);
  lcd_spiwrite_byte(color);

  LCD_PORT |= LCD_CSN_BIT;
    c9ba:	e2 d2 29 00 	bis.b	#4,	&0x0029	;r2 As==10
}
    c9be:	3b 41       	pop	r11		
    c9c0:	30 41       	ret			

0000c9c2 <Rcmd1>:
    c9c2:	0f 01 80 96 11 80 ff b1 03 01 2c 2d b2 03 01 2c     ..........,-...,
    c9d2:	2d b3 06 01 2c 2d 01 2c 2d b4 01 07 c0 03 a2 02     -...,-.,-.......
    c9e2:	84 c1 01 c5 c2 02 0a 00 c3 02 8a 2a c4 02 8a ee     ...........*....
    c9f2:	c5 01 0e 20 00 36 01 c8 3a 01 05                    ... .6..:..

0000c9fd <Rcmd2green>:
    c9fd:	02 2a 04 00 02 00 81 2b 04 00 01 00 a0              .*.....+.....

0000ca0a <Rcmd2red>:
    ca0a:	02 2a 04 00 00 00 7f 2b 04 00 00 00 9f              .*.....+.....

0000ca17 <Rcmd3>:
    ca17:	04 e0 10 02 1c 07 12 37 32 29 2d 29 25 2b 39 00     .......72)-)%+9.
    ca27:	01 03 10 e1 10 03 1d 07 06 2e 2c 29 2d 2e 2e 37     ..........,)-..7
    ca37:	3f 00 00 02 10 13 80 0a 29 80 64                    ?.......).d

0000ca42 <lcd_init_gfx>:
uint16_t textcolor, textbgcolor;
uint8_t textsize, rotation;

void lcd_init_gfx(int16_t w, int16_t h)
{
  CONST_WIDTH = w;
    ca42:	82 4f 1e 02 	mov	r15,	&0x021e	
  CONST_HEIGHT = h;
    ca46:	82 4e 18 02 	mov	r14,	&0x0218	
  cur_width    = w;
    ca4a:	82 4f 1c 02 	mov	r15,	&0x021c	
  cur_height   = h;
    ca4e:	82 4e 20 02 	mov	r14,	&0x0220	
  rotation  = 0;
    ca52:	c2 43 22 02 	mov.b	#0,	&0x0222	;r3 As==00
  cursor_y  = cursor_x    = 0;
    ca56:	82 43 24 02 	mov	#0,	&0x0224	;r3 As==00
    ca5a:	82 43 1a 02 	mov	#0,	&0x021a	;r3 As==00
  textsize  = 1;
    ca5e:	d2 43 26 02 	mov.b	#1,	&0x0226	;r3 As==01
  textcolor = textbgcolor = 0xFFFF;
    ca62:	b2 43 28 02 	mov	#-1,	&0x0228	;r3 As==11
    ca66:	b2 43 2a 02 	mov	#-1,	&0x022a	;r3 As==11
}
    ca6a:	30 41       	ret			

0000ca6c <lcd_gfx_drawCircle>:

// Draw a circle outline
void lcd_gfx_drawCircle(int16_t x0, int16_t y0, int16_t r, uint16_t color) 
{
    ca6c:	0b 12       	push	r11		
    ca6e:	0a 12       	push	r10		
    ca70:	09 12       	push	r9		
    ca72:	08 12       	push	r8		
    ca74:	07 12       	push	r7		
    ca76:	06 12       	push	r6		
    ca78:	05 12       	push	r5		
    ca7a:	04 12       	push	r4		
    ca7c:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    ca80:	04 4f       	mov	r15,	r4	
    ca82:	05 4e       	mov	r14,	r5	
    ca84:	0b 4d       	mov	r13,	r11	
    ca86:	08 4c       	mov	r12,	r8	
  int16_t ddF_x = 1;
  int16_t ddF_y = -2 * r;
  int16_t x = 0;
  int16_t y = r;

  lcd_drawPixel(x0  , y0+r, color);
    ca88:	0d 4c       	mov	r12,	r13	
    ca8a:	0e 4b       	mov	r11,	r14	
    ca8c:	0e 55       	add	r5,	r14	
    ca8e:	b0 12 66 c9 	call	#0xc966	
  lcd_drawPixel(x0  , y0-r, color);
    ca92:	0d 48       	mov	r8,	r13	
    ca94:	0e 45       	mov	r5,	r14	
    ca96:	0e 8b       	sub	r11,	r14	
    ca98:	0f 44       	mov	r4,	r15	
    ca9a:	b0 12 66 c9 	call	#0xc966	
  lcd_drawPixel(x0+r, y0  , color);
    ca9e:	0d 48       	mov	r8,	r13	
    caa0:	0e 45       	mov	r5,	r14	
    caa2:	0f 4b       	mov	r11,	r15	
    caa4:	0f 54       	add	r4,	r15	
    caa6:	b0 12 66 c9 	call	#0xc966	
  lcd_drawPixel(x0-r, y0  , color);
    caaa:	0d 48       	mov	r8,	r13	
    caac:	0e 45       	mov	r5,	r14	
    caae:	0f 44       	mov	r4,	r15	
    cab0:	0f 8b       	sub	r11,	r15	
    cab2:	b0 12 66 c9 	call	#0xc966	

  while (x<y) {
    cab6:	0a 43       	clr	r10		
    cab8:	0a 9b       	cmp	r11,	r10	
    caba:	5b 34       	jge	$+184    	;abs 0xcb72
}

// Draw a circle outline
void lcd_gfx_drawCircle(int16_t x0, int16_t y0, int16_t r, uint16_t color) 
{
  int16_t f = 1 - r;
    cabc:	19 43       	mov	#1,	r9	;r3 As==01
    cabe:	0c 49       	mov	r9,	r12	
    cac0:	0c 8b       	sub	r11,	r12	
  int16_t ddF_x = 1;
  int16_t ddF_y = -2 * r;
    cac2:	0f 4b       	mov	r11,	r15	
    cac4:	0f 11       	rra	r15		
    cac6:	0f 43       	clr	r15		
    cac8:	0f 10       	rrc	r15		
    caca:	0f 8b       	sub	r11,	r15	
    cacc:	81 4f 04 00 	mov	r15,	4(r1)	;0x0004(r1)
    cad0:	91 51 04 00 	rla	4(r1)		;0x0004(r1)
    cad4:	04 00 
    cad6:	06 4b       	mov	r11,	r6	
  int16_t x = 0;
    cad8:	07 4a       	mov	r10,	r7	

// Draw a circle outline
void lcd_gfx_drawCircle(int16_t x0, int16_t y0, int16_t r, uint16_t color) 
{
  int16_t f = 1 - r;
  int16_t ddF_x = 1;
    cada:	81 49 02 00 	mov	r9,	2(r1)	;0x0002(r1)
    cade:	81 45 00 00 	mov	r5,	0(r1)	;0x0000(r1)
    cae2:	05 4c       	mov	r12,	r5	
    cae4:	04 3c       	jmp	$+10     	;abs 0xcaee
      y--;
      ddF_y += 2;
      f += ddF_y;
    }
    x++;
    ddF_x += 2;
    cae6:	a1 53 02 00 	incd	2(r1)		;0x0002(r1)
    f += ddF_x;
    caea:	15 51 02 00 	add	2(r1),	r5	;0x0002(r1)
  lcd_drawPixel(x0  , y0-r, color);
  lcd_drawPixel(x0+r, y0  , color);
  lcd_drawPixel(x0-r, y0  , color);

  while (x<y) {
    if (f >= 0) {
    caee:	05 93       	tst	r5		
    caf0:	05 38       	jl	$+12     	;abs 0xcafc
      y--;
    caf2:	36 53       	add	#-1,	r6	;r3 As==11
      ddF_y += 2;
    caf4:	a1 53 04 00 	incd	4(r1)		;0x0004(r1)
      f += ddF_y;
    caf8:	15 51 04 00 	add	4(r1),	r5	;0x0004(r1)
    }
    x++;
    cafc:	17 53       	inc	r7		
    ddF_x += 2;
    f += ddF_x;
  
    lcd_drawPixel(x0 + x, y0 + y, color);
    cafe:	2b 41       	mov	@r1,	r11	
    cb00:	0b 56       	add	r6,	r11	
  textsize  = 1;
  textcolor = textbgcolor = 0xFFFF;
}

// Draw a circle outline
void lcd_gfx_drawCircle(int16_t x0, int16_t y0, int16_t r, uint16_t color) 
    cb02:	09 44       	mov	r4,	r9	
    cb04:	09 57       	add	r7,	r9	
    }
    x++;
    ddF_x += 2;
    f += ddF_x;
  
    lcd_drawPixel(x0 + x, y0 + y, color);
    cb06:	0d 48       	mov	r8,	r13	
    cb08:	0e 4b       	mov	r11,	r14	
    cb0a:	0f 49       	mov	r9,	r15	
    cb0c:	b0 12 66 c9 	call	#0xc966	
    cb10:	0a 44       	mov	r4,	r10	
    cb12:	0a 87       	sub	r7,	r10	
    lcd_drawPixel(x0 - x, y0 + y, color);
    cb14:	0d 48       	mov	r8,	r13	
    cb16:	0e 4b       	mov	r11,	r14	
    cb18:	0f 4a       	mov	r10,	r15	
    cb1a:	b0 12 66 c9 	call	#0xc966	
    lcd_drawPixel(x0 + x, y0 - y, color);
    cb1e:	2b 41       	mov	@r1,	r11	
    cb20:	0b 86       	sub	r6,	r11	
    cb22:	0d 48       	mov	r8,	r13	
    cb24:	0e 4b       	mov	r11,	r14	
    cb26:	0f 49       	mov	r9,	r15	
    cb28:	b0 12 66 c9 	call	#0xc966	
    lcd_drawPixel(x0 - x, y0 - y, color);
    cb2c:	0d 48       	mov	r8,	r13	
    cb2e:	0e 4b       	mov	r11,	r14	
    cb30:	0f 4a       	mov	r10,	r15	
    cb32:	b0 12 66 c9 	call	#0xc966	
    cb36:	2b 41       	mov	@r1,	r11	
    cb38:	0b 57       	add	r7,	r11	
    lcd_drawPixel(x0 + y, y0 + x, color);
    cb3a:	09 46       	mov	r6,	r9	
    cb3c:	09 54       	add	r4,	r9	
    cb3e:	0d 48       	mov	r8,	r13	
    cb40:	0e 4b       	mov	r11,	r14	
    cb42:	0f 49       	mov	r9,	r15	
    cb44:	b0 12 66 c9 	call	#0xc966	
    lcd_drawPixel(x0 - y, y0 + x, color);
    cb48:	0a 44       	mov	r4,	r10	
    cb4a:	0a 86       	sub	r6,	r10	
    cb4c:	0d 48       	mov	r8,	r13	
    cb4e:	0e 4b       	mov	r11,	r14	
    cb50:	0f 4a       	mov	r10,	r15	
    cb52:	b0 12 66 c9 	call	#0xc966	
    cb56:	2b 41       	mov	@r1,	r11	
    cb58:	0b 87       	sub	r7,	r11	
    lcd_drawPixel(x0 + y, y0 - x, color);
    cb5a:	0d 48       	mov	r8,	r13	
    cb5c:	0e 4b       	mov	r11,	r14	
    cb5e:	0f 49       	mov	r9,	r15	
    cb60:	b0 12 66 c9 	call	#0xc966	
    lcd_drawPixel(x0 - y, y0 - x, color);
    cb64:	0d 48       	mov	r8,	r13	
    cb66:	0e 4b       	mov	r11,	r14	
    cb68:	0f 4a       	mov	r10,	r15	
    cb6a:	b0 12 66 c9 	call	#0xc966	
  lcd_drawPixel(x0  , y0+r, color);
  lcd_drawPixel(x0  , y0-r, color);
  lcd_drawPixel(x0+r, y0  , color);
  lcd_drawPixel(x0-r, y0  , color);

  while (x<y) {
    cb6e:	07 96       	cmp	r6,	r7	
    cb70:	ba 3b       	jl	$-138    	;abs 0xcae6
    lcd_drawPixel(x0 + y, y0 + x, color);
    lcd_drawPixel(x0 - y, y0 + x, color);
    lcd_drawPixel(x0 + y, y0 - x, color);
    lcd_drawPixel(x0 - y, y0 - x, color);
  }
}
    cb72:	31 50 06 00 	add	#6,	r1	;#0x0006
    cb76:	34 41       	pop	r4		
    cb78:	35 41       	pop	r5		
    cb7a:	36 41       	pop	r6		
    cb7c:	37 41       	pop	r7		
    cb7e:	38 41       	pop	r8		
    cb80:	39 41       	pop	r9		
    cb82:	3a 41       	pop	r10		
    cb84:	3b 41       	pop	r11		
    cb86:	30 41       	ret			

0000cb88 <lcd_gfx_drawCircleHelper>:

void lcd_gfx_drawCircleHelper( int16_t x0, int16_t y0, int16_t r, uint8_t cornername, uint16_t color) 
{
    cb88:	0b 12       	push	r11		
    cb8a:	0a 12       	push	r10		
    cb8c:	09 12       	push	r9		
    cb8e:	08 12       	push	r8		
    cb90:	07 12       	push	r7		
    cb92:	06 12       	push	r6		
    cb94:	05 12       	push	r5		
    cb96:	04 12       	push	r4		
    cb98:	31 50 f0 ff 	add	#-16,	r1	;#0xfff0
    cb9c:	81 4f 04 00 	mov	r15,	4(r1)	;0x0004(r1)
    cba0:	81 4e 06 00 	mov	r14,	6(r1)	;0x0006(r1)
    cba4:	0b 4d       	mov	r13,	r11	
    cba6:	16 41 22 00 	mov	34(r1),	r6	;0x0022(r1)
  int16_t ddF_x = 1;
  int16_t ddF_y = -2 * r;
  int16_t x     = 0;
  int16_t y     = r;

  while (x<y) {
    cbaa:	08 43       	clr	r8		
    cbac:	08 9d       	cmp	r13,	r8	
    cbae:	88 34       	jge	$+274    	;abs 0xccc0
    cbb0:	0d 4f       	mov	r15,	r13	
    cbb2:	05 4f       	mov	r15,	r5	
  }
}

void lcd_gfx_drawCircleHelper( int16_t x0, int16_t y0, int16_t r, uint8_t cornername, uint16_t color) 
{
  int16_t f     = 1 - r;
    cbb4:	17 43       	mov	#1,	r7	;r3 As==01
    cbb6:	0a 47       	mov	r7,	r10	
    cbb8:	0a 8b       	sub	r11,	r10	
  int16_t ddF_x = 1;
  int16_t ddF_y = -2 * r;
    cbba:	09 4b       	mov	r11,	r9	
    cbbc:	09 11       	rra	r9		
    cbbe:	09 43       	clr	r9		
    cbc0:	09 10       	rrc	r9		
    cbc2:	09 8b       	sub	r11,	r9	
    cbc4:	09 59       	rla	r9		
    cbc6:	4c 4c       	mov.b	r12,	r12	
    cbc8:	0f 4c       	mov	r12,	r15	
    cbca:	2f f2       	and	#4,	r15	;r2 As==10
    cbcc:	81 4f 08 00 	mov	r15,	8(r1)	;0x0008(r1)
    cbd0:	0f 4c       	mov	r12,	r15	
    cbd2:	2f f3       	and	#2,	r15	;r3 As==10
    cbd4:	81 4f 0a 00 	mov	r15,	10(r1)	;0x000a(r1)
    cbd8:	0f 4c       	mov	r12,	r15	
    cbda:	3f f2       	and	#8,	r15	;r2 As==11
    cbdc:	81 4f 0c 00 	mov	r15,	12(r1)	;0x000c(r1)
    cbe0:	0c f7       	and	r7,	r12	
    cbe2:	81 4c 0e 00 	mov	r12,	14(r1)	;0x000e(r1)
    lcd_drawPixel(x0 + y, y0 - x, color);
    lcd_drawPixel(x0 - y, y0 - x, color);
  }
}

void lcd_gfx_drawCircleHelper( int16_t x0, int16_t y0, int16_t r, uint8_t cornername, uint16_t color) 
    cbe6:	0c 4e       	mov	r14,	r12	
    cbe8:	3c 53       	add	#-1,	r12	;r3 As==11
    cbea:	3d 53       	add	#-1,	r13	;r3 As==11
    cbec:	04 4e       	mov	r14,	r4	
    cbee:	04 57       	add	r7,	r4	
    cbf0:	05 57       	add	r7,	r5	
{
  int16_t f     = 1 - r;
  int16_t ddF_x = 1;
    cbf2:	81 49 02 00 	mov	r9,	2(r1)	;0x0002(r1)
    cbf6:	81 47 00 00 	mov	r7,	0(r1)	;0x0000(r1)
    cbfa:	07 48       	mov	r8,	r7	
    cbfc:	09 4d       	mov	r13,	r9	
    cbfe:	08 4c       	mov	r12,	r8	
    cc00:	12 3c       	jmp	$+38     	;abs 0xcc26
    f     += ddF_x;
    if (cornername & 0x4) {
      lcd_drawPixel(x0 + x, y0 + y, color);
      lcd_drawPixel(x0 + y, y0 + x, color);
    } 
    if (cornername & 0x2) {
    cc02:	81 93 0a 00 	tst	10(r1)		;0x000a(r1)
    cc06:	2b 20       	jnz	$+88     	;abs 0xcc5e
      lcd_drawPixel(x0 + x, y0 - y, color);
      lcd_drawPixel(x0 + y, y0 - x, color);
    }
    if (cornername & 0x8) {
    cc08:	81 93 0c 00 	tst	12(r1)		;0x000c(r1)
    cc0c:	39 20       	jnz	$+116    	;abs 0xcc80
      lcd_drawPixel(x0 - y, y0 + x, color);
      lcd_drawPixel(x0 - x, y0 + y, color);
    }
    if (cornername & 0x1) {
    cc0e:	81 93 0e 00 	tst	14(r1)		;0x000e(r1)
    cc12:	47 20       	jnz	$+144    	;abs 0xcca2
      lcd_drawPixel(x0 - y, y0 - x, color);
      lcd_drawPixel(x0 - x, y0 - y, color);
    cc14:	38 53       	add	#-1,	r8	;r3 As==11
    cc16:	39 53       	add	#-1,	r9	;r3 As==11
    cc18:	14 53       	inc	r4		
    cc1a:	15 53       	inc	r5		
  int16_t ddF_x = 1;
  int16_t ddF_y = -2 * r;
  int16_t x     = 0;
  int16_t y     = r;

  while (x<y) {
    cc1c:	07 9b       	cmp	r11,	r7	
    cc1e:	50 34       	jge	$+162    	;abs 0xccc0
      y--;
      ddF_y += 2;
      f     += ddF_y;
    }
    x++;
    ddF_x += 2;
    cc20:	a1 53 00 00 	incd	0(r1)		;0x0000(r1)
    f     += ddF_x;
    cc24:	2a 51       	add	@r1,	r10	
  int16_t ddF_y = -2 * r;
  int16_t x     = 0;
  int16_t y     = r;

  while (x<y) {
    if (f >= 0) {
    cc26:	0a 93       	tst	r10		
    cc28:	05 38       	jl	$+12     	;abs 0xcc34
      y--;
    cc2a:	3b 53       	add	#-1,	r11	;r3 As==11
      ddF_y += 2;
    cc2c:	a1 53 02 00 	incd	2(r1)		;0x0002(r1)
      f     += ddF_y;
    cc30:	1a 51 02 00 	add	2(r1),	r10	;0x0002(r1)
    }
    x++;
    cc34:	17 53       	inc	r7		
    ddF_x += 2;
    f     += ddF_x;
    if (cornername & 0x4) {
    cc36:	81 93 08 00 	tst	8(r1)		;0x0008(r1)
    cc3a:	e3 27       	jz	$-56     	;abs 0xcc02
      lcd_drawPixel(x0 + x, y0 + y, color);
    cc3c:	0d 46       	mov	r6,	r13	
    cc3e:	1e 41 06 00 	mov	6(r1),	r14	;0x0006(r1)
    cc42:	0e 5b       	add	r11,	r14	
    cc44:	0f 45       	mov	r5,	r15	
    cc46:	b0 12 66 c9 	call	#0xc966	
      lcd_drawPixel(x0 + y, y0 + x, color);
    cc4a:	0d 46       	mov	r6,	r13	
    cc4c:	0e 44       	mov	r4,	r14	
    cc4e:	1f 41 04 00 	mov	4(r1),	r15	;0x0004(r1)
    cc52:	0f 5b       	add	r11,	r15	
    cc54:	b0 12 66 c9 	call	#0xc966	
    } 
    if (cornername & 0x2) {
    cc58:	81 93 0a 00 	tst	10(r1)		;0x000a(r1)
    cc5c:	d5 27       	jz	$-84     	;abs 0xcc08
      lcd_drawPixel(x0 + x, y0 - y, color);
    cc5e:	0d 46       	mov	r6,	r13	
    cc60:	1e 41 06 00 	mov	6(r1),	r14	;0x0006(r1)
    cc64:	0e 8b       	sub	r11,	r14	
    cc66:	0f 45       	mov	r5,	r15	
    cc68:	b0 12 66 c9 	call	#0xc966	
      lcd_drawPixel(x0 + y, y0 - x, color);
    cc6c:	0d 46       	mov	r6,	r13	
    cc6e:	0e 48       	mov	r8,	r14	
    cc70:	1f 41 04 00 	mov	4(r1),	r15	;0x0004(r1)
    cc74:	0f 5b       	add	r11,	r15	
    cc76:	b0 12 66 c9 	call	#0xc966	
    }
    if (cornername & 0x8) {
    cc7a:	81 93 0c 00 	tst	12(r1)		;0x000c(r1)
    cc7e:	c7 27       	jz	$-112    	;abs 0xcc0e
      lcd_drawPixel(x0 - y, y0 + x, color);
    cc80:	0d 46       	mov	r6,	r13	
    cc82:	0e 44       	mov	r4,	r14	
    cc84:	1f 41 04 00 	mov	4(r1),	r15	;0x0004(r1)
    cc88:	0f 8b       	sub	r11,	r15	
    cc8a:	b0 12 66 c9 	call	#0xc966	
      lcd_drawPixel(x0 - x, y0 + y, color);
    cc8e:	0d 46       	mov	r6,	r13	
    cc90:	1e 41 06 00 	mov	6(r1),	r14	;0x0006(r1)
    cc94:	0e 5b       	add	r11,	r14	
    cc96:	0f 49       	mov	r9,	r15	
    cc98:	b0 12 66 c9 	call	#0xc966	
    }
    if (cornername & 0x1) {
    cc9c:	81 93 0e 00 	tst	14(r1)		;0x000e(r1)
    cca0:	b9 27       	jz	$-140    	;abs 0xcc14
      lcd_drawPixel(x0 - y, y0 - x, color);
    cca2:	0d 46       	mov	r6,	r13	
    cca4:	0e 48       	mov	r8,	r14	
    cca6:	1f 41 04 00 	mov	4(r1),	r15	;0x0004(r1)
    ccaa:	0f 8b       	sub	r11,	r15	
    ccac:	b0 12 66 c9 	call	#0xc966	
      lcd_drawPixel(x0 - x, y0 - y, color);
    ccb0:	0d 46       	mov	r6,	r13	
    ccb2:	1e 41 06 00 	mov	6(r1),	r14	;0x0006(r1)
    ccb6:	0e 8b       	sub	r11,	r14	
    ccb8:	0f 49       	mov	r9,	r15	
    ccba:	b0 12 66 c9 	call	#0xc966	
    ccbe:	aa 3f       	jmp	$-170    	;abs 0xcc14
    }
  }
}
    ccc0:	31 50 10 00 	add	#16,	r1	;#0x0010
    ccc4:	34 41       	pop	r4		
    ccc6:	35 41       	pop	r5		
    ccc8:	36 41       	pop	r6		
    ccca:	37 41       	pop	r7		
    cccc:	38 41       	pop	r8		
    ccce:	39 41       	pop	r9		
    ccd0:	3a 41       	pop	r10		
    ccd2:	3b 41       	pop	r11		
    ccd4:	30 41       	ret			

0000ccd6 <lcd_gfx_fillCircleHelper>:
  lcd_gfx_fillCircleHelper(x0, y0, r, 3, 0, color);
}

// Used to do circles and roundrects
void lcd_gfx_fillCircleHelper(int16_t x0, int16_t y0, int16_t r, uint8_t cornername, int16_t delta, uint16_t color) 
{
    ccd6:	0b 12       	push	r11		
    ccd8:	0a 12       	push	r10		
    ccda:	09 12       	push	r9		
    ccdc:	08 12       	push	r8		
    ccde:	07 12       	push	r7		
    cce0:	06 12       	push	r6		
    cce2:	05 12       	push	r5		
    cce4:	04 12       	push	r4		
    cce6:	31 50 e6 ff 	add	#-26,	r1	;#0xffe6
    ccea:	81 4f 14 00 	mov	r15,	20(r1)	;0x0014(r1)
    ccee:	81 4e 12 00 	mov	r14,	18(r1)	;0x0012(r1)
    ccf2:	0b 4d       	mov	r13,	r11	
    ccf4:	14 41 2e 00 	mov	46(r1),	r4	;0x002e(r1)
  int16_t ddF_x = 1;
  int16_t ddF_y = -2 * r;
  int16_t x     = 0;
  int16_t y     = r;

  while (x<y) {
    ccf8:	0d 43       	clr	r13		
    ccfa:	0d 9b       	cmp	r11,	r13	
    ccfc:	02 38       	jl	$+6      	;abs 0xcd02
    ccfe:	30 40 ce cf 	br	#0xcfce	

// Used to do circles and roundrects
void lcd_gfx_fillCircleHelper(int16_t x0, int16_t y0, int16_t r, uint8_t cornername, int16_t delta, uint16_t color) 
{

  int16_t f     = 1 - r;
    cd02:	1a 43       	mov	#1,	r10	;r3 As==01
    cd04:	0f 4a       	mov	r10,	r15	
    cd06:	0f 8b       	sub	r11,	r15	
    cd08:	81 4f 00 00 	mov	r15,	0(r1)	;0x0000(r1)
  int16_t ddF_x = 1;
  int16_t ddF_y = -2 * r;
    cd0c:	0f 4b       	mov	r11,	r15	
    cd0e:	0f 11       	rra	r15		
    cd10:	0f 43       	clr	r15		
    cd12:	0f 10       	rrc	r15		
    cd14:	0f 8b       	sub	r11,	r15	
    cd16:	81 4f 10 00 	mov	r15,	16(r1)	;0x0010(r1)
    cd1a:	91 51 10 00 	rla	16(r1)		;0x0010(r1)
    cd1e:	10 00 
    cd20:	4c 4c       	mov.b	r12,	r12	
    cd22:	0f 4c       	mov	r12,	r15	
    cd24:	0f fa       	and	r10,	r15	
    cd26:	81 4f 16 00 	mov	r15,	22(r1)	;0x0016(r1)
    cd2a:	2c f3       	and	#2,	r12	;r3 As==10
    cd2c:	81 4c 18 00 	mov	r12,	24(r1)	;0x0018(r1)
  lcd_gfx_drawFastVLine(x0, y0-r, 2*r+1, color);
  lcd_gfx_fillCircleHelper(x0, y0, r, 3, 0, color);
}

// Used to do circles and roundrects
void lcd_gfx_fillCircleHelper(int16_t x0, int16_t y0, int16_t r, uint8_t cornername, int16_t delta, uint16_t color) 
    cd30:	0f 4e       	mov	r14,	r15	
    cd32:	0f 5a       	add	r10,	r15	
    cd34:	1f 51 2c 00 	add	44(r1),	r15	;0x002c(r1)
    cd38:	81 4f 08 00 	mov	r15,	8(r1)	;0x0008(r1)
    cd3c:	0f 4e       	mov	r14,	r15	
    cd3e:	3f 53       	add	#-1,	r15	;r3 As==11
    cd40:	81 4f 0a 00 	mov	r15,	10(r1)	;0x000a(r1)
    cd44:	b1 40 fe ff 	mov	#-2,	12(r1)	;#0xfffe, 0x000c(r1)
    cd48:	0c 00 
    cd4a:	91 81 2c 00 	sub	44(r1),	12(r1)	;0x002c(r1), 0x000c(r1)
    cd4e:	0c 00 
    cd50:	1f 41 2c 00 	mov	44(r1),	r15	;0x002c(r1)
    cd54:	2f 53       	incd	r15		
    cd56:	81 4f 04 00 	mov	r15,	4(r1)	;0x0004(r1)
    cd5a:	81 4b 02 00 	mov	r11,	2(r1)	;0x0002(r1)
{

  int16_t f     = 1 - r;
  int16_t ddF_x = 1;
  int16_t ddF_y = -2 * r;
  int16_t x     = 0;
    cd5e:	81 4d 06 00 	mov	r13,	6(r1)	;0x0006(r1)
// Used to do circles and roundrects
void lcd_gfx_fillCircleHelper(int16_t x0, int16_t y0, int16_t r, uint8_t cornername, int16_t delta, uint16_t color) 
{

  int16_t f     = 1 - r;
  int16_t ddF_x = 1;
    cd62:	81 4a 0e 00 	mov	r10,	14(r1)	;0x000e(r1)
    cd66:	16 3c       	jmp	$+46     	;abs 0xcd94

    if (cornername & 0x1) {
      lcd_gfx_drawFastVLine(x0+x, y0-y, 2*y+1+delta, color);
      lcd_gfx_drawFastVLine(x0+y, y0-x, 2*x+1+delta, color);
    }
    if (cornername & 0x2) {
    cd68:	81 93 18 00 	tst	24(r1)		;0x0018(r1)
    cd6c:	7b 20       	jnz	$+248    	;abs 0xce64
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    cd6e:	b1 53 0a 00 	add	#-1,	10(r1)	;r3 As==11, 0x000a(r1)
    cd72:	91 53 08 00 	inc	8(r1)		;0x0008(r1)
    cd76:	a1 83 0c 00 	decd	12(r1)		;0x000c(r1)
    cd7a:	a1 53 04 00 	incd	4(r1)		;0x0004(r1)
  int16_t ddF_x = 1;
  int16_t ddF_y = -2 * r;
  int16_t x     = 0;
  int16_t y     = r;

  while (x<y) {
    cd7e:	91 91 02 00 	cmp	2(r1),	6(r1)	;0x0002(r1), 0x0006(r1)
    cd82:	06 00 
    cd84:	02 38       	jl	$+6      	;abs 0xcd8a
    cd86:	30 40 ce cf 	br	#0xcfce	
      y--;
      ddF_y += 2;
      f     += ddF_y;
    }
    x++;
    ddF_x += 2;
    cd8a:	a1 53 0e 00 	incd	14(r1)		;0x000e(r1)
    f     += ddF_x;
    cd8e:	91 51 0e 00 	add	14(r1),	0(r1)	;0x000e(r1), 0x0000(r1)
    cd92:	00 00 
  int16_t ddF_y = -2 * r;
  int16_t x     = 0;
  int16_t y     = r;

  while (x<y) {
    if (f >= 0) {
    cd94:	81 93 00 00 	tst	0(r1)		;0x0000(r1)
    cd98:	07 38       	jl	$+16     	;abs 0xcda8
      y--;
    cd9a:	b1 53 02 00 	add	#-1,	2(r1)	;r3 As==11, 0x0002(r1)
      ddF_y += 2;
    cd9e:	a1 53 10 00 	incd	16(r1)		;0x0010(r1)
      f     += ddF_y;
    cda2:	91 51 10 00 	add	16(r1),	0(r1)	;0x0010(r1), 0x0000(r1)
    cda6:	00 00 
    }
    x++;
    cda8:	91 53 06 00 	inc	6(r1)		;0x0006(r1)
    ddF_x += 2;
    f     += ddF_x;

    if (cornername & 0x1) {
    cdac:	81 93 16 00 	tst	22(r1)		;0x0016(r1)
    cdb0:	db 27       	jz	$-72     	;abs 0xcd68
  lcd_gfx_drawFastVLine(x0, y0-r, 2*r+1, color);
  lcd_gfx_fillCircleHelper(x0, y0, r, 3, 0, color);
}

// Used to do circles and roundrects
void lcd_gfx_fillCircleHelper(int16_t x0, int16_t y0, int16_t r, uint8_t cornername, int16_t delta, uint16_t color) 
    cdb2:	19 41 06 00 	mov	6(r1),	r9	;0x0006(r1)
    cdb6:	19 51 14 00 	add	20(r1),	r9	;0x0014(r1)
    x++;
    ddF_x += 2;
    f     += ddF_x;

    if (cornername & 0x1) {
      lcd_gfx_drawFastVLine(x0+x, y0-y, 2*y+1+delta, color);
    cdba:	18 41 12 00 	mov	18(r1),	r8	;0x0012(r1)
    cdbe:	18 81 02 00 	sub	2(r1),	r8	;0x0002(r1)
}

void lcd_gfx_drawFastVLine(int16_t x, int16_t y, int16_t h, uint16_t color) 
{
  // Update in subclasses if desired!
  lcd_gfx_drawLine(x, y, x, y+h-1, color);
    cdc2:	1a 41 02 00 	mov	2(r1),	r10	;0x0002(r1)
    cdc6:	1a 51 12 00 	add	18(r1),	r10	;0x0012(r1)
    cdca:	1a 51 2c 00 	add	44(r1),	r10	;0x002c(r1)
}

// Bresenham's algorithm - thx wikpedia
void lcd_gfx_drawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint16_t color) 
{
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
    cdce:	07 4a       	mov	r10,	r7	
    cdd0:	07 88       	sub	r8,	r7	
    cdd2:	02 20       	jnz	$+6      	;abs 0xcdd8
    cdd4:	30 40 76 cf 	br	#0xcf76	
  if (steep) {
    swap(x0, y0);
    swap(x1, y1);
  }

  if (x0 > x1) {
    cdd8:	0a 98       	cmp	r8,	r10	
    cdda:	02 38       	jl	$+6      	;abs 0xcde0
    cddc:	30 40 e4 cf 	br	#0xcfe4	
    swap(x0, x1);
    swap(y0, y1);
  }

  int16_t dx, dy;
  dx = x1 - x0;
    cde0:	06 48       	mov	r8,	r6	
    cde2:	06 8a       	sub	r10,	r6	
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
    cde4:	0b 46       	mov	r6,	r11	
    cde6:	36 b0 00 80 	bit	#-32768,r6	;#0x8000
    cdea:	01 34       	jge	$+4      	;abs 0xcdee
    cdec:	1b 53       	inc	r11		
    cdee:	0b 11       	rra	r11		
    cdf0:	03 3c       	jmp	$+8      	;abs 0xcdf8
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    cdf2:	1a 53       	inc	r10		
    cdf4:	08 9a       	cmp	r10,	r8	
    cdf6:	0c 38       	jl	$+26     	;abs 0xce10
    if (steep) {
      lcd_drawPixel(y0, x0, color);
    cdf8:	0d 44       	mov	r4,	r13	
    cdfa:	0e 4a       	mov	r10,	r14	
    cdfc:	0f 49       	mov	r9,	r15	
    cdfe:	b0 12 66 c9 	call	#0xc966	
    } else {
      lcd_drawPixel(x0, y0, color);
    }
    err -= dy;
    if (err < 0) {
    ce02:	0b 93       	tst	r11		
    ce04:	f6 37       	jge	$-18     	;abs 0xcdf2
      y0 += ystep;
    ce06:	39 53       	add	#-1,	r9	;r3 As==11
      err += dx;
    ce08:	0b 56       	add	r6,	r11	
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    ce0a:	1a 53       	inc	r10		
    ce0c:	08 9a       	cmp	r10,	r8	
    ce0e:	f4 37       	jge	$-22     	;abs 0xcdf8
    ce10:	19 41 0a 00 	mov	10(r1),	r9	;0x000a(r1)
    ddF_x += 2;
    f     += ddF_x;

    if (cornername & 0x1) {
      lcd_gfx_drawFastVLine(x0+x, y0-y, 2*y+1+delta, color);
      lcd_gfx_drawFastVLine(x0+y, y0-x, 2*x+1+delta, color);
    ce14:	1b 41 02 00 	mov	2(r1),	r11	;0x0002(r1)
    ce18:	1b 51 14 00 	add	20(r1),	r11	;0x0014(r1)
    ce1c:	18 41 08 00 	mov	8(r1),	r8	;0x0008(r1)
    ce20:	17 41 04 00 	mov	4(r1),	r7	;0x0004(r1)
}

// Bresenham's algorithm - thx wikpedia
void lcd_gfx_drawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint16_t color) 
{
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
    ce24:	07 93       	tst	r7		
    ce26:	71 24       	jz	$+228    	;abs 0xcf0a
  if (steep) {
    swap(x0, y0);
    swap(x1, y1);
  }

  if (x0 > x1) {
    ce28:	08 99       	cmp	r9,	r8	
    ce2a:	02 38       	jl	$+6      	;abs 0xce30
    ce2c:	30 40 2a d0 	br	#0xd02a	

  int16_t dx, dy;
  dx = x1 - x0;
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
    ce30:	16 41 0c 00 	mov	12(r1),	r6	;0x000c(r1)
    ce34:	0a 46       	mov	r6,	r10	
    ce36:	06 93       	tst	r6		
    ce38:	01 34       	jge	$+4      	;abs 0xce3c
    ce3a:	1a 53       	inc	r10		
    ce3c:	0a 11       	rra	r10		
    ce3e:	18 41 0a 00 	mov	10(r1),	r8	;0x000a(r1)
void lcd_gfx_drawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint16_t color) 
{
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
  if (steep) {
    swap(x0, y0);
    swap(x1, y1);
    ce42:	09 4b       	mov	r11,	r9	

  int16_t dx, dy;
  dx = x1 - x0;
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
    ce44:	1b 41 08 00 	mov	8(r1),	r11	;0x0008(r1)
    ce48:	03 3c       	jmp	$+8      	;abs 0xce50
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    ce4a:	1b 53       	inc	r11		
    ce4c:	08 9b       	cmp	r11,	r8	
    ce4e:	8c 3b       	jl	$-230    	;abs 0xcd68
    if (steep) {
      lcd_drawPixel(y0, x0, color);
    ce50:	0d 44       	mov	r4,	r13	
    ce52:	0e 4b       	mov	r11,	r14	
    ce54:	0f 49       	mov	r9,	r15	
    ce56:	b0 12 66 c9 	call	#0xc966	
    } else {
      lcd_drawPixel(x0, y0, color);
    }
    err -= dy;
    if (err < 0) {
    ce5a:	0a 93       	tst	r10		
    ce5c:	f6 37       	jge	$-18     	;abs 0xce4a
      y0 += ystep;
    ce5e:	39 53       	add	#-1,	r9	;r3 As==11
      err += dx;
    ce60:	0a 56       	add	r6,	r10	
    ce62:	f3 3f       	jmp	$-24     	;abs 0xce4a
  lcd_gfx_drawFastVLine(x0, y0-r, 2*r+1, color);
  lcd_gfx_fillCircleHelper(x0, y0, r, 3, 0, color);
}

// Used to do circles and roundrects
void lcd_gfx_fillCircleHelper(int16_t x0, int16_t y0, int16_t r, uint8_t cornername, int16_t delta, uint16_t color) 
    ce64:	17 41 14 00 	mov	20(r1),	r7	;0x0014(r1)
    ce68:	17 81 06 00 	sub	6(r1),	r7	;0x0006(r1)
    if (cornername & 0x1) {
      lcd_gfx_drawFastVLine(x0+x, y0-y, 2*y+1+delta, color);
      lcd_gfx_drawFastVLine(x0+y, y0-x, 2*x+1+delta, color);
    }
    if (cornername & 0x2) {
      lcd_gfx_drawFastVLine(x0-x, y0-y, 2*y+1+delta, color);
    ce6c:	19 41 12 00 	mov	18(r1),	r9	;0x0012(r1)
    ce70:	19 81 02 00 	sub	2(r1),	r9	;0x0002(r1)
}

void lcd_gfx_drawFastVLine(int16_t x, int16_t y, int16_t h, uint16_t color) 
{
  // Update in subclasses if desired!
  lcd_gfx_drawLine(x, y, x, y+h-1, color);
    ce74:	1b 41 02 00 	mov	2(r1),	r11	;0x0002(r1)
    ce78:	1b 51 12 00 	add	18(r1),	r11	;0x0012(r1)
    ce7c:	1b 51 2c 00 	add	44(r1),	r11	;0x002c(r1)
}

// Bresenham's algorithm - thx wikpedia
void lcd_gfx_drawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint16_t color) 
{
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
    ce80:	08 4b       	mov	r11,	r8	
    ce82:	08 89       	sub	r9,	r8	
    ce84:	8e 24       	jz	$+286    	;abs 0xcfa2
  if (steep) {
    swap(x0, y0);
    swap(x1, y1);
  }

  if (x0 > x1) {
    ce86:	0b 99       	cmp	r9,	r11	
    ce88:	02 38       	jl	$+6      	;abs 0xce8e
    ce8a:	30 40 5c d0 	br	#0xd05c	
    swap(x0, x1);
    swap(y0, y1);
  }

  int16_t dx, dy;
  dx = x1 - x0;
    ce8e:	06 49       	mov	r9,	r6	
    ce90:	06 8b       	sub	r11,	r6	
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
    ce92:	0a 46       	mov	r6,	r10	
    ce94:	36 b0 00 80 	bit	#-32768,r6	;#0x8000
    ce98:	01 34       	jge	$+4      	;abs 0xce9c
    ce9a:	1a 53       	inc	r10		
    ce9c:	0a 11       	rra	r10		
    ce9e:	03 3c       	jmp	$+8      	;abs 0xcea6
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    cea0:	1b 53       	inc	r11		
    cea2:	09 9b       	cmp	r11,	r9	
    cea4:	0c 38       	jl	$+26     	;abs 0xcebe
    if (steep) {
      lcd_drawPixel(y0, x0, color);
    cea6:	0d 44       	mov	r4,	r13	
    cea8:	0e 4b       	mov	r11,	r14	
    ceaa:	0f 47       	mov	r7,	r15	
    ceac:	b0 12 66 c9 	call	#0xc966	
    } else {
      lcd_drawPixel(x0, y0, color);
    }
    err -= dy;
    if (err < 0) {
    ceb0:	0a 93       	tst	r10		
    ceb2:	f6 37       	jge	$-18     	;abs 0xcea0
      y0 += ystep;
    ceb4:	37 53       	add	#-1,	r7	;r3 As==11
      err += dx;
    ceb6:	0a 56       	add	r6,	r10	
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    ceb8:	1b 53       	inc	r11		
    ceba:	09 9b       	cmp	r11,	r9	
    cebc:	f4 37       	jge	$-22     	;abs 0xcea6
    cebe:	19 41 0a 00 	mov	10(r1),	r9	;0x000a(r1)
      lcd_gfx_drawFastVLine(x0+x, y0-y, 2*y+1+delta, color);
      lcd_gfx_drawFastVLine(x0+y, y0-x, 2*x+1+delta, color);
    }
    if (cornername & 0x2) {
      lcd_gfx_drawFastVLine(x0-x, y0-y, 2*y+1+delta, color);
      lcd_gfx_drawFastVLine(x0-y, y0-x, 2*x+1+delta, color);
    cec2:	18 41 14 00 	mov	20(r1),	r8	;0x0014(r1)
    cec6:	18 81 02 00 	sub	2(r1),	r8	;0x0002(r1)
    ceca:	1b 41 08 00 	mov	8(r1),	r11	;0x0008(r1)
    cece:	17 41 04 00 	mov	4(r1),	r7	;0x0004(r1)
}

// Bresenham's algorithm - thx wikpedia
void lcd_gfx_drawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint16_t color) 
{
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
    ced2:	07 93       	tst	r7		
    ced4:	35 24       	jz	$+108    	;abs 0xcf40
  if (steep) {
    swap(x0, y0);
    swap(x1, y1);
  }

  if (x0 > x1) {
    ced6:	0b 99       	cmp	r9,	r11	
    ced8:	b4 34       	jge	$+362    	;abs 0xd042

  int16_t dx, dy;
  dx = x1 - x0;
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
    ceda:	15 41 0c 00 	mov	12(r1),	r5	;0x000c(r1)
    cede:	0a 45       	mov	r5,	r10	
    cee0:	05 93       	tst	r5		
    cee2:	01 34       	jge	$+4      	;abs 0xcee6
    cee4:	1a 53       	inc	r10		
    cee6:	0a 11       	rra	r10		
    cee8:	09 48       	mov	r8,	r9	
    ceea:	18 41 0a 00 	mov	10(r1),	r8	;0x000a(r1)
    ceee:	03 3c       	jmp	$+8      	;abs 0xcef6
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    cef0:	1b 53       	inc	r11		
    cef2:	08 9b       	cmp	r11,	r8	
    cef4:	3c 3b       	jl	$-390    	;abs 0xcd6e
    if (steep) {
      lcd_drawPixel(y0, x0, color);
    cef6:	0d 44       	mov	r4,	r13	
    cef8:	0e 4b       	mov	r11,	r14	
    cefa:	0f 49       	mov	r9,	r15	
    cefc:	b0 12 66 c9 	call	#0xc966	
    } else {
      lcd_drawPixel(x0, y0, color);
    }
    err -= dy;
    if (err < 0) {
    cf00:	0a 93       	tst	r10		
    cf02:	f6 37       	jge	$-18     	;abs 0xcef0
      y0 += ystep;
    cf04:	39 53       	add	#-1,	r9	;r3 As==11
      err += dx;
    cf06:	0a 55       	add	r5,	r10	
    cf08:	f3 3f       	jmp	$-24     	;abs 0xcef0
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
  int16_t ystep;

  if (y0 < y1) {
    cf0a:	91 91 08 00 	cmp	8(r1),	10(r1)	;0x0008(r1), 0x000a(r1)
    cf0e:	0a 00 
    cf10:	86 34       	jge	$+270    	;abs 0xd01e
    cf12:	08 4b       	mov	r11,	r8	
    cf14:	1a 41 04 00 	mov	4(r1),	r10	;0x0004(r1)
    cf18:	06 4a       	mov	r10,	r6	
    ystep = 1;
    cf1a:	15 43       	mov	#1,	r5	;r3 As==01
    cf1c:	05 3c       	jmp	$+12     	;abs 0xcf28
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    cf1e:	1b 53       	inc	r11		
    cf20:	08 9b       	cmp	r11,	r8	
    cf22:	02 34       	jge	$+6      	;abs 0xcf28
    cf24:	30 40 68 cd 	br	#0xcd68	
    if (steep) {
      lcd_drawPixel(y0, x0, color);
    } else {
      lcd_drawPixel(x0, y0, color);
    cf28:	0d 44       	mov	r4,	r13	
    cf2a:	0e 49       	mov	r9,	r14	
    cf2c:	0f 4b       	mov	r11,	r15	
    cf2e:	b0 12 66 c9 	call	#0xc966	
    }
    err -= dy;
    cf32:	0a 87       	sub	r7,	r10	
    if (err < 0) {
    cf34:	3a b0 00 80 	bit	#-32768,r10	;#0x8000
    cf38:	f2 37       	jge	$-26     	;abs 0xcf1e
      y0 += ystep;
    cf3a:	09 55       	add	r5,	r9	
      err += dx;
    cf3c:	0a 56       	add	r6,	r10	
    cf3e:	ef 3f       	jmp	$-32     	;abs 0xcf1e
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
  int16_t ystep;

  if (y0 < y1) {
    cf40:	91 91 08 00 	cmp	8(r1),	10(r1)	;0x0008(r1), 0x000a(r1)
    cf44:	0a 00 
    cf46:	65 34       	jge	$+204    	;abs 0xd012
    cf48:	0b 48       	mov	r8,	r11	
    cf4a:	1a 41 04 00 	mov	4(r1),	r10	;0x0004(r1)
    cf4e:	05 4a       	mov	r10,	r5	
    ystep = 1;
    cf50:	16 43       	mov	#1,	r6	;r3 As==01
    cf52:	05 3c       	jmp	$+12     	;abs 0xcf5e
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    cf54:	1b 53       	inc	r11		
    cf56:	08 9b       	cmp	r11,	r8	
    cf58:	02 34       	jge	$+6      	;abs 0xcf5e
    cf5a:	30 40 6e cd 	br	#0xcd6e	
    if (steep) {
      lcd_drawPixel(y0, x0, color);
    } else {
      lcd_drawPixel(x0, y0, color);
    cf5e:	0d 44       	mov	r4,	r13	
    cf60:	0e 49       	mov	r9,	r14	
    cf62:	0f 4b       	mov	r11,	r15	
    cf64:	b0 12 66 c9 	call	#0xc966	
    }
    err -= dy;
    cf68:	0a 87       	sub	r7,	r10	
    if (err < 0) {
    cf6a:	3a b0 00 80 	bit	#-32768,r10	;#0x8000
    cf6e:	f2 37       	jge	$-26     	;abs 0xcf54
      y0 += ystep;
    cf70:	09 56       	add	r6,	r9	
      err += dx;
    cf72:	0a 55       	add	r5,	r10	
    cf74:	ef 3f       	jmp	$-32     	;abs 0xcf54
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
  int16_t ystep;

  if (y0 < y1) {
    cf76:	08 9a       	cmp	r10,	r8	
    cf78:	47 34       	jge	$+144    	;abs 0xd008
    cf7a:	0a 49       	mov	r9,	r10	
    cf7c:	0b 47       	mov	r7,	r11	
    cf7e:	06 47       	mov	r7,	r6	
    ystep = 1;
    cf80:	15 43       	mov	#1,	r5	;r3 As==01
    cf82:	03 3c       	jmp	$+8      	;abs 0xcf8a
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    cf84:	19 53       	inc	r9		
    cf86:	0a 99       	cmp	r9,	r10	
    cf88:	43 3b       	jl	$-376    	;abs 0xce10
    if (steep) {
      lcd_drawPixel(y0, x0, color);
    } else {
      lcd_drawPixel(x0, y0, color);
    cf8a:	0d 44       	mov	r4,	r13	
    cf8c:	0e 48       	mov	r8,	r14	
    cf8e:	0f 49       	mov	r9,	r15	
    cf90:	b0 12 66 c9 	call	#0xc966	
    }
    err -= dy;
    cf94:	0b 87       	sub	r7,	r11	
    if (err < 0) {
    cf96:	3b b0 00 80 	bit	#-32768,r11	;#0x8000
    cf9a:	f4 37       	jge	$-22     	;abs 0xcf84
      y0 += ystep;
    cf9c:	08 55       	add	r5,	r8	
      err += dx;
    cf9e:	0b 56       	add	r6,	r11	
    cfa0:	f1 3f       	jmp	$-28     	;abs 0xcf84
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
  int16_t ystep;

  if (y0 < y1) {
    cfa2:	09 9b       	cmp	r11,	r9	
    cfa4:	2c 34       	jge	$+90     	;abs 0xcffe
    cfa6:	0b 47       	mov	r7,	r11	
    cfa8:	0a 48       	mov	r8,	r10	
    cfaa:	06 48       	mov	r8,	r6	
    ystep = 1;
    cfac:	15 43       	mov	#1,	r5	;r3 As==01
    cfae:	03 3c       	jmp	$+8      	;abs 0xcfb6
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    cfb0:	1b 53       	inc	r11		
    cfb2:	07 9b       	cmp	r11,	r7	
    cfb4:	84 3b       	jl	$-246    	;abs 0xcebe
    if (steep) {
      lcd_drawPixel(y0, x0, color);
    } else {
      lcd_drawPixel(x0, y0, color);
    cfb6:	0d 44       	mov	r4,	r13	
    cfb8:	0e 49       	mov	r9,	r14	
    cfba:	0f 4b       	mov	r11,	r15	
    cfbc:	b0 12 66 c9 	call	#0xc966	
    }
    err -= dy;
    cfc0:	0a 88       	sub	r8,	r10	
    if (err < 0) {
    cfc2:	3a b0 00 80 	bit	#-32768,r10	;#0x8000
    cfc6:	f4 37       	jge	$-22     	;abs 0xcfb0
      y0 += ystep;
    cfc8:	09 55       	add	r5,	r9	
      err += dx;
    cfca:	0a 56       	add	r6,	r10	
    cfcc:	f1 3f       	jmp	$-28     	;abs 0xcfb0
    if (cornername & 0x2) {
      lcd_gfx_drawFastVLine(x0-x, y0-y, 2*y+1+delta, color);
      lcd_gfx_drawFastVLine(x0-y, y0-x, 2*x+1+delta, color);
    }
  }
}
    cfce:	31 50 1a 00 	add	#26,	r1	;#0x001a
    cfd2:	34 41       	pop	r4		
    cfd4:	35 41       	pop	r5		
    cfd6:	36 41       	pop	r6		
    cfd8:	37 41       	pop	r7		
    cfda:	38 41       	pop	r8		
    cfdc:	39 41       	pop	r9		
    cfde:	3a 41       	pop	r10		
    cfe0:	3b 41       	pop	r11		
    cfe2:	30 41       	ret			
  if (steep) {
    swap(x0, y0);
    swap(x1, y1);
  }

  if (x0 > x1) {
    cfe4:	0b 47       	mov	r7,	r11	
    cfe6:	07 93       	tst	r7		
    cfe8:	01 34       	jge	$+4      	;abs 0xcfec
    cfea:	1b 53       	inc	r11		
    cfec:	0b 11       	rra	r11		
    cfee:	06 47       	mov	r7,	r6	
    cff0:	0f 49       	mov	r9,	r15	
    cff2:	09 48       	mov	r8,	r9	
  int16_t ystep;

  if (y0 < y1) {
    ystep = 1;
  } else {
    ystep = -1;
    cff4:	08 4a       	mov	r10,	r8	
    cff6:	0a 49       	mov	r9,	r10	
    cff8:	09 4f       	mov	r15,	r9	
    cffa:	30 40 f8 cd 	br	#0xcdf8	
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
  int16_t ystep;

  if (y0 < y1) {
    cffe:	0b 47       	mov	r7,	r11	
    d000:	0a 48       	mov	r8,	r10	
    d002:	06 48       	mov	r8,	r6	
    ystep = 1;
  } else {
    ystep = -1;
    d004:	35 43       	mov	#-1,	r5	;r3 As==11
    d006:	d7 3f       	jmp	$-80     	;abs 0xcfb6
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
  int16_t ystep;

  if (y0 < y1) {
    d008:	0a 49       	mov	r9,	r10	
    d00a:	0b 47       	mov	r7,	r11	
    d00c:	06 47       	mov	r7,	r6	
    ystep = 1;
  } else {
    ystep = -1;
    d00e:	35 43       	mov	#-1,	r5	;r3 As==11
    d010:	bc 3f       	jmp	$-134    	;abs 0xcf8a
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
  int16_t ystep;

  if (y0 < y1) {
    d012:	0b 48       	mov	r8,	r11	
    d014:	1a 41 04 00 	mov	4(r1),	r10	;0x0004(r1)
    d018:	05 4a       	mov	r10,	r5	
    ystep = 1;
  } else {
    ystep = -1;
    d01a:	36 43       	mov	#-1,	r6	;r3 As==11
    d01c:	a0 3f       	jmp	$-190    	;abs 0xcf5e
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
  int16_t ystep;

  if (y0 < y1) {
    d01e:	08 4b       	mov	r11,	r8	
    d020:	1a 41 04 00 	mov	4(r1),	r10	;0x0004(r1)
    d024:	06 4a       	mov	r10,	r6	
    ystep = 1;
  } else {
    ystep = -1;
    d026:	35 43       	mov	#-1,	r5	;r3 As==11
    d028:	7f 3f       	jmp	$-256    	;abs 0xcf28
  if (steep) {
    swap(x0, y0);
    swap(x1, y1);
  }

  if (x0 > x1) {
    d02a:	0a 47       	mov	r7,	r10	
    d02c:	07 93       	tst	r7		
    d02e:	01 34       	jge	$+4      	;abs 0xd032
    d030:	1a 53       	inc	r10		
    d032:	0a 11       	rra	r10		
    d034:	16 41 04 00 	mov	4(r1),	r6	;0x0004(r1)
    d038:	09 4b       	mov	r11,	r9	
    d03a:	1b 41 0a 00 	mov	10(r1),	r11	;0x000a(r1)
    d03e:	30 40 50 ce 	br	#0xce50	
    d042:	0a 47       	mov	r7,	r10	
    d044:	07 93       	tst	r7		
    d046:	01 34       	jge	$+4      	;abs 0xd04a
    d048:	1a 53       	inc	r10		
    d04a:	0a 11       	rra	r10		
    d04c:	15 41 04 00 	mov	4(r1),	r5	;0x0004(r1)
    d050:	09 48       	mov	r8,	r9	
    d052:	18 41 08 00 	mov	8(r1),	r8	;0x0008(r1)
    d056:	1b 41 0a 00 	mov	10(r1),	r11	;0x000a(r1)
    d05a:	4d 3f       	jmp	$-356    	;abs 0xcef6
    d05c:	0a 48       	mov	r8,	r10	
    d05e:	08 93       	tst	r8		
    d060:	01 34       	jge	$+4      	;abs 0xd064
    d062:	1a 53       	inc	r10		
    d064:	0a 11       	rra	r10		
    d066:	06 48       	mov	r8,	r6	
    d068:	0f 47       	mov	r7,	r15	
    d06a:	07 4b       	mov	r11,	r7	
    d06c:	0b 49       	mov	r9,	r11	
  int16_t ystep;

  if (y0 < y1) {
    ystep = 1;
  } else {
    ystep = -1;
    d06e:	09 47       	mov	r7,	r9	
    d070:	07 4f       	mov	r15,	r7	
    d072:	30 40 a6 ce 	br	#0xcea6	

0000d076 <lcd_gfx_fillCircle>:
    }
  }
}

void lcd_gfx_fillCircle(int16_t x0, int16_t y0, int16_t r, uint16_t color) 
{
    d076:	0b 12       	push	r11		
    d078:	0a 12       	push	r10		
    d07a:	09 12       	push	r9		
    d07c:	08 12       	push	r8		
    d07e:	07 12       	push	r7		
    d080:	06 12       	push	r6		
    d082:	05 12       	push	r5		
    d084:	04 12       	push	r4		
    d086:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    d08a:	81 4f 04 00 	mov	r15,	4(r1)	;0x0004(r1)
    d08e:	81 4e 00 00 	mov	r14,	0(r1)	;0x0000(r1)
    d092:	81 4d 02 00 	mov	r13,	2(r1)	;0x0002(r1)
    d096:	07 4c       	mov	r12,	r7	
  lcd_gfx_drawFastVLine(x0, y0-r, 2*r+1, color);
    d098:	08 4e       	mov	r14,	r8	
    d09a:	08 8d       	sub	r13,	r8	
}

void lcd_gfx_drawFastVLine(int16_t x, int16_t y, int16_t h, uint16_t color) 
{
  // Update in subclasses if desired!
  lcd_gfx_drawLine(x, y, x, y+h-1, color);
    d09c:	0a 4e       	mov	r14,	r10	
    d09e:	0a 5d       	add	r13,	r10	
}

// Bresenham's algorithm - thx wikpedia
void lcd_gfx_drawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint16_t color) 
{
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
    d0a0:	06 4a       	mov	r10,	r6	
    d0a2:	06 88       	sub	r8,	r6	
    d0a4:	1b 43       	mov	#1,	r11	;r3 As==01
    d0a6:	30 24       	jz	$+98     	;abs 0xd108
  if (steep) {
    swap(x0, y0);
    swap(x1, y1);
  }

  if (x0 > x1) {
    d0a8:	0a 98       	cmp	r8,	r10	
    d0aa:	47 34       	jge	$+144    	;abs 0xd13a
    swap(x0, x1);
    swap(y0, y1);
  }

  int16_t dx, dy;
  dx = x1 - x0;
    d0ac:	05 48       	mov	r8,	r5	
    d0ae:	05 8a       	sub	r10,	r5	
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
    d0b0:	09 45       	mov	r5,	r9	
    d0b2:	41 30       	jn	$+132    	;abs 0xd136
    d0b4:	09 11       	rra	r9		
void lcd_gfx_drawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint16_t color) 
{
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
  if (steep) {
    swap(x0, y0);
    swap(x1, y1);
    d0b6:	1b 41 04 00 	mov	4(r1),	r11	;0x0004(r1)
    d0ba:	03 3c       	jmp	$+8      	;abs 0xd0c2
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    d0bc:	1a 53       	inc	r10		
    d0be:	08 9a       	cmp	r10,	r8	
    d0c0:	0c 38       	jl	$+26     	;abs 0xd0da
    if (steep) {
      lcd_drawPixel(y0, x0, color);
    d0c2:	0d 47       	mov	r7,	r13	
    d0c4:	0e 4a       	mov	r10,	r14	
    d0c6:	0f 4b       	mov	r11,	r15	
    d0c8:	b0 12 66 c9 	call	#0xc966	
    } else {
      lcd_drawPixel(x0, y0, color);
    }
    err -= dy;
    if (err < 0) {
    d0cc:	09 93       	tst	r9		
    d0ce:	f6 37       	jge	$-18     	;abs 0xd0bc
      y0 += ystep;
    d0d0:	3b 53       	add	#-1,	r11	;r3 As==11
      err += dx;
    d0d2:	09 55       	add	r5,	r9	
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    d0d4:	1a 53       	inc	r10		
    d0d6:	08 9a       	cmp	r10,	r8	
    d0d8:	f4 37       	jge	$-22     	;abs 0xd0c2
}

void lcd_gfx_fillCircle(int16_t x0, int16_t y0, int16_t r, uint16_t color) 
{
  lcd_gfx_drawFastVLine(x0, y0-r, 2*r+1, color);
  lcd_gfx_fillCircleHelper(x0, y0, r, 3, 0, color);
    d0da:	07 12       	push	r7		
    d0dc:	03 12       	push	#0		;r3 As==00
    d0de:	7c 40 03 00 	mov.b	#3,	r12	;#0x0003
    d0e2:	1d 41 06 00 	mov	6(r1),	r13	;0x0006(r1)
    d0e6:	1e 41 04 00 	mov	4(r1),	r14	;0x0004(r1)
    d0ea:	1f 41 08 00 	mov	8(r1),	r15	;0x0008(r1)
    d0ee:	b0 12 d6 cc 	call	#0xccd6	
}
    d0f2:	31 50 0a 00 	add	#10,	r1	;#0x000a
    d0f6:	34 41       	pop	r4		
    d0f8:	35 41       	pop	r5		
    d0fa:	36 41       	pop	r6		
    d0fc:	37 41       	pop	r7		
    d0fe:	38 41       	pop	r8		
    d100:	39 41       	pop	r9		
    d102:	3a 41       	pop	r10		
    d104:	3b 41       	pop	r11		
    d106:	30 41       	ret			
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
  int16_t ystep;

  if (y0 < y1) {
    d108:	08 9a       	cmp	r10,	r8	
    d10a:	27 34       	jge	$+80     	;abs 0xd15a
    d10c:	1a 41 04 00 	mov	4(r1),	r10	;0x0004(r1)
    d110:	04 4a       	mov	r10,	r4	
    d112:	09 46       	mov	r6,	r9	
    d114:	05 46       	mov	r6,	r5	
    d116:	03 3c       	jmp	$+8      	;abs 0xd11e
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    d118:	1a 53       	inc	r10		
    d11a:	04 9a       	cmp	r10,	r4	
    d11c:	de 3b       	jl	$-66     	;abs 0xd0da
    if (steep) {
      lcd_drawPixel(y0, x0, color);
    } else {
      lcd_drawPixel(x0, y0, color);
    d11e:	0d 47       	mov	r7,	r13	
    d120:	0e 48       	mov	r8,	r14	
    d122:	0f 4a       	mov	r10,	r15	
    d124:	b0 12 66 c9 	call	#0xc966	
    }
    err -= dy;
    d128:	09 86       	sub	r6,	r9	
    if (err < 0) {
    d12a:	39 b0 00 80 	bit	#-32768,r9	;#0x8000
    d12e:	f4 37       	jge	$-22     	;abs 0xd118
      y0 += ystep;
    d130:	08 5b       	add	r11,	r8	
      err += dx;
    d132:	09 55       	add	r5,	r9	
    d134:	f1 3f       	jmp	$-28     	;abs 0xd118

  int16_t dx, dy;
  dx = x1 - x0;
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
    d136:	19 53       	inc	r9		
    d138:	bd 3f       	jmp	$-132    	;abs 0xd0b4
  if (steep) {
    swap(x0, y0);
    swap(x1, y1);
  }

  if (x0 > x1) {
    d13a:	09 46       	mov	r6,	r9	
    d13c:	06 93       	tst	r6		
    d13e:	01 34       	jge	$+4      	;abs 0xd142
    d140:	09 5b       	add	r11,	r9	
    d142:	09 11       	rra	r9		
    d144:	05 46       	mov	r6,	r5	
    d146:	04 4a       	mov	r10,	r4	
    d148:	0a 48       	mov	r8,	r10	
// Bresenham's algorithm - thx wikpedia
void lcd_gfx_drawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint16_t color) 
{
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
  if (steep) {
    swap(x0, y0);
    d14a:	18 41 04 00 	mov	4(r1),	r8	;0x0004(r1)
    swap(x1, y1);
  }

  if (x0 > x1) {
    d14e:	06 43       	clr	r6		
  int16_t ystep;

  if (y0 < y1) {
    ystep = 1;
  } else {
    ystep = -1;
    d150:	3c 43       	mov	#-1,	r12	;r3 As==11
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
  int16_t ystep;

  if (y0 < y1) {
    d152:	0b 96       	cmp	r6,	r11	
    d154:	09 20       	jnz	$+20     	;abs 0xd168
    d156:	0b 4c       	mov	r12,	r11	
    d158:	e2 3f       	jmp	$-58     	;abs 0xd11e
    d15a:	1a 41 04 00 	mov	4(r1),	r10	;0x0004(r1)
    d15e:	04 4a       	mov	r10,	r4	
    d160:	09 46       	mov	r6,	r9	
    d162:	05 46       	mov	r6,	r5	
    ystep = 1;
  } else {
    ystep = -1;
    d164:	3b 43       	mov	#-1,	r11	;r3 As==11
    d166:	db 3f       	jmp	$-72     	;abs 0xd11e
    d168:	1b 41 04 00 	mov	4(r1),	r11	;0x0004(r1)
    d16c:	08 44       	mov	r4,	r8	
    d16e:	a9 3f       	jmp	$-172    	;abs 0xd0c2

0000d170 <abs>:
}

uint16_t abs(uint16_t x)
{
  return x>=0? x : -x;
}
    d170:	30 41       	ret			

0000d172 <lcd_gfx_drawLine>:

// Bresenham's algorithm - thx wikpedia
void lcd_gfx_drawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint16_t color) 
{
    d172:	0b 12       	push	r11		
    d174:	0a 12       	push	r10		
    d176:	09 12       	push	r9		
    d178:	08 12       	push	r8		
    d17a:	07 12       	push	r7		
    d17c:	06 12       	push	r6		
    d17e:	05 12       	push	r5		
    d180:	04 12       	push	r4		
    d182:	0b 4f       	mov	r15,	r11	
    d184:	09 4e       	mov	r14,	r9	
    d186:	08 4d       	mov	r13,	r8	
    d188:	15 41 12 00 	mov	18(r1),	r5	;0x0012(r1)
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
    d18c:	06 4c       	mov	r12,	r6	
    d18e:	06 8e       	sub	r14,	r6	
    d190:	07 4d       	mov	r13,	r7	
    d192:	07 8f       	sub	r15,	r7	
    d194:	1f 43       	mov	#1,	r15	;r3 As==01
    d196:	07 96       	cmp	r6,	r7	
    d198:	45 28       	jnc	$+140    	;abs 0xd224
    d19a:	0f 43       	clr	r15		
  if (steep) {
    d19c:	0e 46       	mov	r6,	r14	
    d19e:	06 47       	mov	r7,	r6	
    d1a0:	07 4e       	mov	r14,	r7	
    swap(x0, y0);
    swap(x1, y1);
  }

  if (x0 > x1) {
    d1a2:	08 9b       	cmp	r11,	r8	
    d1a4:	0a 34       	jge	$+22     	;abs 0xd1ba
    d1a6:	06 4b       	mov	r11,	r6	
    d1a8:	06 88       	sub	r8,	r6	
    d1aa:	07 49       	mov	r9,	r7	
    d1ac:	07 8c       	sub	r12,	r7	
    d1ae:	0e 49       	mov	r9,	r14	
    swap(x0, x1);
    swap(y0, y1);
    d1b0:	09 4c       	mov	r12,	r9	
    d1b2:	0c 4e       	mov	r14,	r12	
  if (steep) {
    swap(x0, y0);
    swap(x1, y1);
  }

  if (x0 > x1) {
    d1b4:	0e 4b       	mov	r11,	r14	
    d1b6:	0b 48       	mov	r8,	r11	
    d1b8:	08 4e       	mov	r14,	r8	
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
  int16_t ystep;

  if (y0 < y1) {
    d1ba:	09 9c       	cmp	r12,	r9	
    d1bc:	31 34       	jge	$+100    	;abs 0xd220
    ystep = 1;
    d1be:	14 43       	mov	#1,	r4	;r3 As==01
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    d1c0:	08 9b       	cmp	r11,	r8	
    d1c2:	16 38       	jl	$+46     	;abs 0xd1f0

  int16_t dx, dy;
  dx = x1 - x0;
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
    d1c4:	0a 46       	mov	r6,	r10	
    d1c6:	06 93       	tst	r6		
    d1c8:	33 38       	jl	$+104    	;abs 0xd230
    d1ca:	0a 11       	rra	r10		
    d1cc:	0f 93       	tst	r15		
    d1ce:	1e 20       	jnz	$+62     	;abs 0xd20c
    d1d0:	05 3c       	jmp	$+12     	;abs 0xd1dc
    } else {
      lcd_drawPixel(x0, y0, color);
    }
    err -= dy;
    if (err < 0) {
      y0 += ystep;
    d1d2:	09 54       	add	r4,	r9	
      err += dx;
    d1d4:	0a 56       	add	r6,	r10	
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    d1d6:	1b 53       	inc	r11		
    d1d8:	08 9b       	cmp	r11,	r8	
    d1da:	0a 38       	jl	$+22     	;abs 0xd1f0
    if (steep) {
      lcd_drawPixel(y0, x0, color);
    } else {
      lcd_drawPixel(x0, y0, color);
    d1dc:	0d 45       	mov	r5,	r13	
    d1de:	0e 49       	mov	r9,	r14	
    d1e0:	0f 4b       	mov	r11,	r15	
    d1e2:	b0 12 66 c9 	call	#0xc966	
    }
    err -= dy;
    d1e6:	0a 87       	sub	r7,	r10	
    d1e8:	f4 33       	jn	$-22     	;abs 0xd1d2
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    d1ea:	1b 53       	inc	r11		
    d1ec:	08 9b       	cmp	r11,	r8	
    d1ee:	f6 37       	jge	$-18     	;abs 0xd1dc
    if (err < 0) {
      y0 += ystep;
      err += dx;
    }
  }
}
    d1f0:	34 41       	pop	r4		
    d1f2:	35 41       	pop	r5		
    d1f4:	36 41       	pop	r6		
    d1f6:	37 41       	pop	r7		
    d1f8:	38 41       	pop	r8		
    d1fa:	39 41       	pop	r9		
    d1fc:	3a 41       	pop	r10		
    d1fe:	3b 41       	pop	r11		
    d200:	30 41       	ret			
    } else {
      lcd_drawPixel(x0, y0, color);
    }
    err -= dy;
    if (err < 0) {
      y0 += ystep;
    d202:	09 54       	add	r4,	r9	
      err += dx;
    d204:	0a 56       	add	r6,	r10	
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    d206:	1b 53       	inc	r11		
    d208:	08 9b       	cmp	r11,	r8	
    d20a:	f2 3b       	jl	$-26     	;abs 0xd1f0
    if (steep) {
      lcd_drawPixel(y0, x0, color);
    d20c:	0d 45       	mov	r5,	r13	
    d20e:	0e 4b       	mov	r11,	r14	
    d210:	0f 49       	mov	r9,	r15	
    d212:	b0 12 66 c9 	call	#0xc966	
    } else {
      lcd_drawPixel(x0, y0, color);
    }
    err -= dy;
    d216:	0a 87       	sub	r7,	r10	
    if (err < 0) {
    d218:	3a b0 00 80 	bit	#-32768,r10	;#0x8000
    d21c:	f4 37       	jge	$-22     	;abs 0xd206
    d21e:	f1 3f       	jmp	$-28     	;abs 0xd202
  int16_t ystep;

  if (y0 < y1) {
    ystep = 1;
  } else {
    ystep = -1;
    d220:	34 43       	mov	#-1,	r4	;r3 As==11
    d222:	ce 3f       	jmp	$-98     	;abs 0xd1c0
void lcd_gfx_drawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint16_t color) 
{
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
  if (steep) {
    swap(x0, y0);
    swap(x1, y1);
    d224:	08 4c       	mov	r12,	r8	
    d226:	0c 4d       	mov	r13,	r12	

// Bresenham's algorithm - thx wikpedia
void lcd_gfx_drawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint16_t color) 
{
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
  if (steep) {
    d228:	0e 4b       	mov	r11,	r14	
    swap(x0, y0);
    d22a:	0b 49       	mov	r9,	r11	
    d22c:	09 4e       	mov	r14,	r9	
    d22e:	b9 3f       	jmp	$-140    	;abs 0xd1a2

  int16_t dx, dy;
  dx = x1 - x0;
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
    d230:	1a 53       	inc	r10		
    d232:	0a 11       	rra	r10		
    d234:	0f 93       	tst	r15		
    d236:	ea 23       	jnz	$-42     	;abs 0xd20c
    d238:	d1 3f       	jmp	$-92     	;abs 0xd1dc

0000d23a <lcd_gfx_drawRect>:
  }
}

// Draw a rectangle
void lcd_gfx_drawRect(int16_t x, int16_t y, int16_t w, int16_t h, uint16_t color) 
{
    d23a:	0b 12       	push	r11		
    d23c:	0a 12       	push	r10		
    d23e:	09 12       	push	r9		
    d240:	08 12       	push	r8		
    d242:	07 12       	push	r7		
    d244:	06 12       	push	r6		
    d246:	05 12       	push	r5		
    d248:	04 12       	push	r4		
    d24a:	31 50 f6 ff 	add	#-10,	r1	;#0xfff6
    d24e:	04 4f       	mov	r15,	r4	
    d250:	05 4e       	mov	r14,	r5	
    d252:	81 4c 02 00 	mov	r12,	2(r1)	;0x0002(r1)
}

void lcd_gfx_drawFastHLine(int16_t x, int16_t y, int16_t w, uint16_t color) 
{
  // Update in subclasses if desired!
  lcd_gfx_drawLine(x, y, x+w-1, y, color);
    d256:	06 4f       	mov	r15,	r6	
    d258:	36 53       	add	#-1,	r6	;r3 As==11
    d25a:	06 5d       	add	r13,	r6	
  if (steep) {
    swap(x0, y0);
    swap(x1, y1);
  }

  if (x0 > x1) {
    d25c:	06 9f       	cmp	r15,	r6	
    d25e:	a2 38       	jl	$+326    	;abs 0xd3a4
    d260:	0a 46       	mov	r6,	r10	
    d262:	0b 4f       	mov	r15,	r11	
    swap(x0, x1);
    swap(y0, y1);
  }

  int16_t dx, dy;
  dx = x1 - x0;
    d264:	07 4a       	mov	r10,	r7	
    d266:	07 8b       	sub	r11,	r7	
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
    d268:	09 47       	mov	r7,	r9	
    d26a:	a4 30       	jn	$+330    	;abs 0xd3b4
    d26c:	09 11       	rra	r9		
    d26e:	08 45       	mov	r5,	r8	
    d270:	81 45 00 00 	mov	r5,	0(r1)	;0x0000(r1)
    d274:	05 46       	mov	r6,	r5	
    d276:	06 47       	mov	r7,	r6	
    d278:	17 41 1c 00 	mov	28(r1),	r7	;0x001c(r1)

  for (; x0<=x1; x0++) {
    if (steep) {
      lcd_drawPixel(y0, x0, color);
    } else {
      lcd_drawPixel(x0, y0, color);
    d27c:	0d 47       	mov	r7,	r13	
    d27e:	0e 48       	mov	r8,	r14	
    d280:	0f 4b       	mov	r11,	r15	
    d282:	b0 12 66 c9 	call	#0xc966	
    }
    err -= dy;
    if (err < 0) {
    d286:	09 93       	tst	r9		
    d288:	02 34       	jge	$+6      	;abs 0xd28e
      y0 += ystep;
    d28a:	38 53       	add	#-1,	r8	;r3 As==11
      err += dx;
    d28c:	09 56       	add	r6,	r9	
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    d28e:	1b 53       	inc	r11		
    d290:	0a 9b       	cmp	r11,	r10	
    d292:	f4 37       	jge	$-22     	;abs 0xd27c
    d294:	06 45       	mov	r5,	r6	
    d296:	25 41       	mov	@r1,	r5	

// Draw a rectangle
void lcd_gfx_drawRect(int16_t x, int16_t y, int16_t w, int16_t h, uint16_t color) 
{
  lcd_gfx_drawFastHLine(x, y, w, color);
  lcd_gfx_drawFastHLine(x, y+h-1, w, color);
    d298:	0f 45       	mov	r5,	r15	
    d29a:	3f 53       	add	#-1,	r15	;r3 As==11
    d29c:	1f 51 02 00 	add	2(r1),	r15	;0x0002(r1)
    d2a0:	81 4f 00 00 	mov	r15,	0(r1)	;0x0000(r1)
  if (steep) {
    swap(x0, y0);
    swap(x1, y1);
  }

  if (x0 > x1) {
    d2a4:	06 94       	cmp	r4,	r6	
    d2a6:	74 38       	jl	$+234    	;abs 0xd390
    d2a8:	0a 46       	mov	r6,	r10	
    d2aa:	0b 44       	mov	r4,	r11	
    swap(x0, x1);
    swap(y0, y1);
  }

  int16_t dx, dy;
  dx = x1 - x0;
    d2ac:	07 4a       	mov	r10,	r7	
    d2ae:	07 8b       	sub	r11,	r7	
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
    d2b0:	09 47       	mov	r7,	r9	
    d2b2:	76 30       	jn	$+238    	;abs 0xd3a0
    d2b4:	09 11       	rra	r9		

// Draw a rectangle
void lcd_gfx_drawRect(int16_t x, int16_t y, int16_t w, int16_t h, uint16_t color) 
{
  lcd_gfx_drawFastHLine(x, y, w, color);
  lcd_gfx_drawFastHLine(x, y+h-1, w, color);
    d2b6:	28 41       	mov	@r1,	r8	
    d2b8:	81 45 02 00 	mov	r5,	2(r1)	;0x0002(r1)
    d2bc:	05 46       	mov	r6,	r5	
    d2be:	06 47       	mov	r7,	r6	
    d2c0:	17 41 1c 00 	mov	28(r1),	r7	;0x001c(r1)

  for (; x0<=x1; x0++) {
    if (steep) {
      lcd_drawPixel(y0, x0, color);
    } else {
      lcd_drawPixel(x0, y0, color);
    d2c4:	0d 47       	mov	r7,	r13	
    d2c6:	0e 48       	mov	r8,	r14	
    d2c8:	0f 4b       	mov	r11,	r15	
    d2ca:	b0 12 66 c9 	call	#0xc966	
    }
    err -= dy;
    if (err < 0) {
    d2ce:	09 93       	tst	r9		
    d2d0:	02 34       	jge	$+6      	;abs 0xd2d6
      y0 += ystep;
    d2d2:	38 53       	add	#-1,	r8	;r3 As==11
      err += dx;
    d2d4:	09 56       	add	r6,	r9	
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    d2d6:	1b 53       	inc	r11		
    d2d8:	0a 9b       	cmp	r11,	r10	
    d2da:	f4 37       	jge	$-22     	;abs 0xd2c4
    d2dc:	06 45       	mov	r5,	r6	
    d2de:	15 41 02 00 	mov	2(r1),	r5	;0x0002(r1)
}

// Bresenham's algorithm - thx wikpedia
void lcd_gfx_drawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint16_t color) 
{
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
    d2e2:	27 41       	mov	@r1,	r7	
    d2e4:	07 85       	sub	r5,	r7	
    d2e6:	91 43 02 00 	mov	#1,	2(r1)	;r3 As==01, 0x0002(r1)
    d2ea:	7c 24       	jz	$+250    	;abs 0xd3e4
  if (steep) {
    swap(x0, y0);
    swap(x1, y1);
  }

  if (x0 > x1) {
    d2ec:	81 95 00 00 	cmp	r5,	0(r1)	;0x0000(r1)
    d2f0:	c5 34       	jge	$+396    	;abs 0xd47c
    swap(x0, x1);
    swap(y0, y1);
  }

  int16_t dx, dy;
  dx = x1 - x0;
    d2f2:	08 45       	mov	r5,	r8	
    d2f4:	28 81       	sub	@r1,	r8	
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
    d2f6:	0c 48       	mov	r8,	r12	
    d2f8:	73 30       	jn	$+232    	;abs 0xd3e0
    d2fa:	0a 4c       	mov	r12,	r10	
    d2fc:	0a 11       	rra	r10		
    d2fe:	2b 41       	mov	@r1,	r11	
    d300:	09 44       	mov	r4,	r9	
    d302:	04 45       	mov	r5,	r4	
    d304:	81 45 04 00 	mov	r5,	4(r1)	;0x0004(r1)
    d308:	05 47       	mov	r7,	r5	
    d30a:	07 48       	mov	r8,	r7	
    d30c:	18 41 1c 00 	mov	28(r1),	r8	;0x001c(r1)
    d310:	03 3c       	jmp	$+8      	;abs 0xd318
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    d312:	1b 53       	inc	r11		
    d314:	04 9b       	cmp	r11,	r4	
    d316:	0c 38       	jl	$+26     	;abs 0xd330
    if (steep) {
      lcd_drawPixel(y0, x0, color);
    d318:	0d 48       	mov	r8,	r13	
    d31a:	0e 4b       	mov	r11,	r14	
    d31c:	0f 49       	mov	r9,	r15	
    d31e:	b0 12 66 c9 	call	#0xc966	
    } else {
      lcd_drawPixel(x0, y0, color);
    }
    err -= dy;
    if (err < 0) {
    d322:	0a 93       	tst	r10		
    d324:	f6 37       	jge	$-18     	;abs 0xd312
      y0 += ystep;
    d326:	39 53       	add	#-1,	r9	;r3 As==11
      err += dx;
    d328:	0a 57       	add	r7,	r10	
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    d32a:	1b 53       	inc	r11		
    d32c:	04 9b       	cmp	r11,	r4	
    d32e:	f4 37       	jge	$-22     	;abs 0xd318
    d330:	07 45       	mov	r5,	r7	
    d332:	15 41 04 00 	mov	4(r1),	r5	;0x0004(r1)
  if (steep) {
    swap(x0, y0);
    swap(x1, y1);
  }

  if (x0 > x1) {
    d336:	81 95 00 00 	cmp	r5,	0(r1)	;0x0000(r1)
    d33a:	94 34       	jge	$+298    	;abs 0xd464
    swap(x0, x1);
    swap(y0, y1);
  }

  int16_t dx, dy;
  dx = x1 - x0;
    d33c:	09 45       	mov	r5,	r9	
    d33e:	29 81       	sub	@r1,	r9	
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
    d340:	0b 49       	mov	r9,	r11	
    d342:	4c 30       	jn	$+154    	;abs 0xd3dc
    d344:	0b 11       	rra	r11		
    d346:	2a 41       	mov	@r1,	r10	
    swap(y0, y1);
  }

  int16_t dx, dy;
  dx = x1 - x0;
  dy = abs(y1 - y0);
    d348:	07 43       	clr	r7		
  int16_t ystep;

  if (y0 < y1) {
    ystep = 1;
  } else {
    ystep = -1;
    d34a:	38 43       	mov	#-1,	r8	;r3 As==11
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
  int16_t ystep;

  if (y0 < y1) {
    d34c:	81 93 02 00 	tst	2(r1)		;0x0002(r1)
    d350:	33 20       	jnz	$+104    	;abs 0xd3b8
    d352:	14 41 1c 00 	mov	28(r1),	r4	;0x001c(r1)
    d356:	03 3c       	jmp	$+8      	;abs 0xd35e
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    d358:	1a 53       	inc	r10		
    d35a:	05 9a       	cmp	r10,	r5	
    d35c:	0e 38       	jl	$+30     	;abs 0xd37a
    if (steep) {
      lcd_drawPixel(y0, x0, color);
    } else {
      lcd_drawPixel(x0, y0, color);
    d35e:	0d 44       	mov	r4,	r13	
    d360:	0e 46       	mov	r6,	r14	
    d362:	0f 4a       	mov	r10,	r15	
    d364:	b0 12 66 c9 	call	#0xc966	
    }
    err -= dy;
    d368:	0b 87       	sub	r7,	r11	
    if (err < 0) {
    d36a:	3b b0 00 80 	bit	#-32768,r11	;#0x8000
    d36e:	f4 37       	jge	$-22     	;abs 0xd358
      y0 += ystep;
    d370:	06 58       	add	r8,	r6	
      err += dx;
    d372:	0b 59       	add	r9,	r11	
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    d374:	1a 53       	inc	r10		
    d376:	05 9a       	cmp	r10,	r5	
    d378:	f2 37       	jge	$-26     	;abs 0xd35e
{
  lcd_gfx_drawFastHLine(x, y, w, color);
  lcd_gfx_drawFastHLine(x, y+h-1, w, color);
  lcd_gfx_drawFastVLine(x, y, h, color);
  lcd_gfx_drawFastVLine(x+w-1, y, h, color);
}
    d37a:	31 50 0a 00 	add	#10,	r1	;#0x000a
    d37e:	34 41       	pop	r4		
    d380:	35 41       	pop	r5		
    d382:	36 41       	pop	r6		
    d384:	37 41       	pop	r7		
    d386:	38 41       	pop	r8		
    d388:	39 41       	pop	r9		
    d38a:	3a 41       	pop	r10		
    d38c:	3b 41       	pop	r11		
    d38e:	30 41       	ret			
  if (steep) {
    swap(x0, y0);
    swap(x1, y1);
  }

  if (x0 > x1) {
    d390:	0a 44       	mov	r4,	r10	
    d392:	0b 46       	mov	r6,	r11	
    swap(x0, x1);
    swap(y0, y1);
  }

  int16_t dx, dy;
  dx = x1 - x0;
    d394:	07 4a       	mov	r10,	r7	
    d396:	07 8b       	sub	r11,	r7	
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
    d398:	09 47       	mov	r7,	r9	
    d39a:	37 b0 00 80 	bit	#-32768,r7	;#0x8000
    d39e:	8a 37       	jge	$-234    	;abs 0xd2b4
    d3a0:	19 53       	inc	r9		
    d3a2:	88 3f       	jmp	$-238    	;abs 0xd2b4
  if (steep) {
    swap(x0, y0);
    swap(x1, y1);
  }

  if (x0 > x1) {
    d3a4:	0a 4f       	mov	r15,	r10	
    d3a6:	0b 46       	mov	r6,	r11	
    swap(x0, x1);
    swap(y0, y1);
  }

  int16_t dx, dy;
  dx = x1 - x0;
    d3a8:	07 4a       	mov	r10,	r7	
    d3aa:	07 8b       	sub	r11,	r7	
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
    d3ac:	09 47       	mov	r7,	r9	
    d3ae:	37 b0 00 80 	bit	#-32768,r7	;#0x8000
    d3b2:	5c 37       	jge	$-326    	;abs 0xd26c
    d3b4:	19 53       	inc	r9		
    d3b6:	5a 3f       	jmp	$-330    	;abs 0xd26c
    d3b8:	14 41 1c 00 	mov	28(r1),	r4	;0x001c(r1)
    d3bc:	03 3c       	jmp	$+8      	;abs 0xd3c4
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    d3be:	1a 53       	inc	r10		
    d3c0:	05 9a       	cmp	r10,	r5	
    d3c2:	db 3b       	jl	$-72     	;abs 0xd37a
    if (steep) {
      lcd_drawPixel(y0, x0, color);
    d3c4:	0d 44       	mov	r4,	r13	
    d3c6:	0e 4a       	mov	r10,	r14	
    d3c8:	0f 46       	mov	r6,	r15	
    d3ca:	b0 12 66 c9 	call	#0xc966	
    } else {
      lcd_drawPixel(x0, y0, color);
    }
    err -= dy;
    d3ce:	0b 87       	sub	r7,	r11	
    if (err < 0) {
    d3d0:	3b b0 00 80 	bit	#-32768,r11	;#0x8000
    d3d4:	f4 37       	jge	$-22     	;abs 0xd3be
      y0 += ystep;
    d3d6:	06 58       	add	r8,	r6	
      err += dx;
    d3d8:	0b 59       	add	r9,	r11	
    d3da:	f1 3f       	jmp	$-28     	;abs 0xd3be

  int16_t dx, dy;
  dx = x1 - x0;
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
    d3dc:	1b 53       	inc	r11		
    d3de:	b2 3f       	jmp	$-154    	;abs 0xd344
    d3e0:	1c 53       	inc	r12		
    d3e2:	8b 3f       	jmp	$-232    	;abs 0xd2fa
}

// Bresenham's algorithm - thx wikpedia
void lcd_gfx_drawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint16_t color) 
{
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
    d3e4:	81 47 02 00 	mov	r7,	2(r1)	;0x0002(r1)
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
  int16_t ystep;

  if (y0 < y1) {
    d3e8:	25 91       	cmp	@r1,	r5	
    d3ea:	30 34       	jge	$+98     	;abs 0xd44c
    d3ec:	09 45       	mov	r5,	r9	
    d3ee:	0b 44       	mov	r4,	r11	
    d3f0:	0a 47       	mov	r7,	r10	
    d3f2:	08 47       	mov	r7,	r8	
    ystep = 1;
    d3f4:	91 43 04 00 	mov	#1,	4(r1)	;r3 As==01, 0x0004(r1)
  } else {
    ystep = -1;
    d3f8:	81 47 06 00 	mov	r7,	6(r1)	;0x0006(r1)
    d3fc:	81 45 08 00 	mov	r5,	8(r1)	;0x0008(r1)
    d400:	05 46       	mov	r6,	r5	
    d402:	06 48       	mov	r8,	r6	
    d404:	17 41 1c 00 	mov	28(r1),	r7	;0x001c(r1)
    d408:	03 3c       	jmp	$+8      	;abs 0xd410
  }

  for (; x0<=x1; x0++) {
    d40a:	1b 53       	inc	r11		
    d40c:	04 9b       	cmp	r11,	r4	
    d40e:	0f 38       	jl	$+32     	;abs 0xd42e
    if (steep) {
      lcd_drawPixel(y0, x0, color);
    } else {
      lcd_drawPixel(x0, y0, color);
    d410:	0d 47       	mov	r7,	r13	
    d412:	0e 49       	mov	r9,	r14	
    d414:	0f 4b       	mov	r11,	r15	
    d416:	b0 12 66 c9 	call	#0xc966	
    }
    err -= dy;
    d41a:	0a 88       	sub	r8,	r10	
    if (err < 0) {
    d41c:	3a b0 00 80 	bit	#-32768,r10	;#0x8000
    d420:	f4 37       	jge	$-22     	;abs 0xd40a
      y0 += ystep;
    d422:	19 51 04 00 	add	4(r1),	r9	;0x0004(r1)
      err += dx;
    d426:	0a 56       	add	r6,	r10	
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    d428:	1b 53       	inc	r11		
    d42a:	04 9b       	cmp	r11,	r4	
    d42c:	f1 37       	jge	$-28     	;abs 0xd410
    d42e:	06 45       	mov	r5,	r6	
    d430:	17 41 06 00 	mov	6(r1),	r7	;0x0006(r1)
    d434:	15 41 08 00 	mov	8(r1),	r5	;0x0008(r1)
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
  int16_t ystep;

  if (y0 < y1) {
    d438:	25 91       	cmp	@r1,	r5	
    d43a:	0f 34       	jge	$+32     	;abs 0xd45a
    d43c:	0a 46       	mov	r6,	r10	
    d43e:	0b 43       	clr	r11		
    d440:	09 4b       	mov	r11,	r9	
    ystep = 1;
    d442:	18 43       	mov	#1,	r8	;r3 As==01
  } else {
    ystep = -1;
    d444:	0c 46       	mov	r6,	r12	
    d446:	06 45       	mov	r5,	r6	
    d448:	05 4c       	mov	r12,	r5	
    d44a:	80 3f       	jmp	$-254    	;abs 0xd34c
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
  int16_t ystep;

  if (y0 < y1) {
    d44c:	09 45       	mov	r5,	r9	
    d44e:	0b 44       	mov	r4,	r11	
    d450:	0a 47       	mov	r7,	r10	
    d452:	08 47       	mov	r7,	r8	
    ystep = 1;
  } else {
    ystep = -1;
    d454:	b1 43 04 00 	mov	#-1,	4(r1)	;r3 As==11, 0x0004(r1)
    d458:	cf 3f       	jmp	$-96     	;abs 0xd3f8
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
  int16_t ystep;

  if (y0 < y1) {
    d45a:	0a 46       	mov	r6,	r10	
    d45c:	0b 43       	clr	r11		
    d45e:	09 4b       	mov	r11,	r9	
    ystep = 1;
  } else {
    ystep = -1;
    d460:	38 43       	mov	#-1,	r8	;r3 As==11
    d462:	f0 3f       	jmp	$-30     	;abs 0xd444
  if (steep) {
    swap(x0, y0);
    swap(x1, y1);
  }

  if (x0 > x1) {
    d464:	0b 47       	mov	r7,	r11	
    d466:	07 93       	tst	r7		
    d468:	01 34       	jge	$+4      	;abs 0xd46c
    d46a:	1b 53       	inc	r11		
    d46c:	0b 11       	rra	r11		
    d46e:	09 47       	mov	r7,	r9	
    d470:	0a 45       	mov	r5,	r10	
}

void lcd_gfx_drawFastHLine(int16_t x, int16_t y, int16_t w, uint16_t color) 
{
  // Update in subclasses if desired!
  lcd_gfx_drawLine(x, y, x+w-1, y, color);
    d472:	05 46       	mov	r6,	r5	
  if (steep) {
    swap(x0, y0);
    swap(x1, y1);
  }

  if (x0 > x1) {
    d474:	26 41       	mov	@r1,	r6	
    d476:	07 43       	clr	r7		
  int16_t ystep;

  if (y0 < y1) {
    ystep = 1;
  } else {
    ystep = -1;
    d478:	38 43       	mov	#-1,	r8	;r3 As==11
    d47a:	e4 3f       	jmp	$-54     	;abs 0xd444
  if (steep) {
    swap(x0, y0);
    swap(x1, y1);
  }

  if (x0 > x1) {
    d47c:	0a 47       	mov	r7,	r10	
    d47e:	07 93       	tst	r7		
    d480:	01 34       	jge	$+4      	;abs 0xd484
    d482:	1a 53       	inc	r10		
    d484:	0a 11       	rra	r10		
    d486:	09 44       	mov	r4,	r9	
    d488:	08 47       	mov	r7,	r8	
    d48a:	0b 45       	mov	r5,	r11	
    d48c:	24 41       	mov	@r1,	r4	
    d48e:	0f 43       	clr	r15		
  int16_t ystep;

  if (y0 < y1) {
    ystep = 1;
  } else {
    ystep = -1;
    d490:	b1 43 04 00 	mov	#-1,	4(r1)	;r3 As==11, 0x0004(r1)
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
  int16_t ystep;

  if (y0 < y1) {
    d494:	81 9f 02 00 	cmp	r15,	2(r1)	;0x0002(r1)
    d498:	35 23       	jnz	$-404    	;abs 0xd304
    d49a:	81 47 06 00 	mov	r7,	6(r1)	;0x0006(r1)
    d49e:	81 45 08 00 	mov	r5,	8(r1)	;0x0008(r1)
    d4a2:	05 46       	mov	r6,	r5	
    d4a4:	06 47       	mov	r7,	r6	
    d4a6:	08 4f       	mov	r15,	r8	
    d4a8:	17 41 1c 00 	mov	28(r1),	r7	;0x001c(r1)
    d4ac:	b1 3f       	jmp	$-156    	;abs 0xd410

0000d4ae <lcd_gfx_drawFastVLine>:
  lcd_gfx_drawFastVLine(x, y, h, color);
  lcd_gfx_drawFastVLine(x+w-1, y, h, color);
}

void lcd_gfx_drawFastVLine(int16_t x, int16_t y, int16_t h, uint16_t color) 
{
    d4ae:	0b 12       	push	r11		
    d4b0:	0a 12       	push	r10		
    d4b2:	09 12       	push	r9		
    d4b4:	08 12       	push	r8		
    d4b6:	07 12       	push	r7		
    d4b8:	06 12       	push	r6		
    d4ba:	05 12       	push	r5		
    d4bc:	04 12       	push	r4		
    d4be:	08 4f       	mov	r15,	r8	
    d4c0:	09 4e       	mov	r14,	r9	
    d4c2:	06 4c       	mov	r12,	r6	
  // Update in subclasses if desired!
  lcd_gfx_drawLine(x, y, x, y+h-1, color);
    d4c4:	0b 4e       	mov	r14,	r11	
    d4c6:	3b 53       	add	#-1,	r11	;r3 As==11
    d4c8:	0b 5d       	add	r13,	r11	
}

// Bresenham's algorithm - thx wikpedia
void lcd_gfx_drawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint16_t color) 
{
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
    d4ca:	07 4b       	mov	r11,	r7	
    d4cc:	07 8e       	sub	r14,	r7	
    d4ce:	1f 43       	mov	#1,	r15	;r3 As==01
    d4d0:	23 24       	jz	$+72     	;abs 0xd518
  if (steep) {
    swap(x0, y0);
    swap(x1, y1);
  }

  if (x0 > x1) {
    d4d2:	0b 9e       	cmp	r14,	r11	
    d4d4:	39 34       	jge	$+116    	;abs 0xd548
    swap(x0, x1);
    swap(y0, y1);
  }

  int16_t dx, dy;
  dx = x1 - x0;
    d4d6:	05 4e       	mov	r14,	r5	
    d4d8:	05 8b       	sub	r11,	r5	
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
    d4da:	0a 45       	mov	r5,	r10	
    d4dc:	33 30       	jn	$+104    	;abs 0xd544
    d4de:	0a 11       	rra	r10		
    d4e0:	0f 48       	mov	r8,	r15	
    d4e2:	08 49       	mov	r9,	r8	
void lcd_gfx_drawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint16_t color) 
{
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
  if (steep) {
    swap(x0, y0);
    swap(x1, y1);
    d4e4:	09 4f       	mov	r15,	r9	
    d4e6:	03 3c       	jmp	$+8      	;abs 0xd4ee
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    d4e8:	1b 53       	inc	r11		
    d4ea:	08 9b       	cmp	r11,	r8	
    d4ec:	0c 38       	jl	$+26     	;abs 0xd506
    if (steep) {
      lcd_drawPixel(y0, x0, color);
    d4ee:	0d 46       	mov	r6,	r13	
    d4f0:	0e 4b       	mov	r11,	r14	
    d4f2:	0f 49       	mov	r9,	r15	
    d4f4:	b0 12 66 c9 	call	#0xc966	
    } else {
      lcd_drawPixel(x0, y0, color);
    }
    err -= dy;
    if (err < 0) {
    d4f8:	0a 93       	tst	r10		
    d4fa:	f6 37       	jge	$-18     	;abs 0xd4e8
      y0 += ystep;
    d4fc:	39 53       	add	#-1,	r9	;r3 As==11
      err += dx;
    d4fe:	0a 55       	add	r5,	r10	
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    d500:	1b 53       	inc	r11		
    d502:	08 9b       	cmp	r11,	r8	
    d504:	f4 37       	jge	$-22     	;abs 0xd4ee

void lcd_gfx_drawFastVLine(int16_t x, int16_t y, int16_t h, uint16_t color) 
{
  // Update in subclasses if desired!
  lcd_gfx_drawLine(x, y, x, y+h-1, color);
}
    d506:	34 41       	pop	r4		
    d508:	35 41       	pop	r5		
    d50a:	36 41       	pop	r6		
    d50c:	37 41       	pop	r7		
    d50e:	38 41       	pop	r8		
    d510:	39 41       	pop	r9		
    d512:	3a 41       	pop	r10		
    d514:	3b 41       	pop	r11		
    d516:	30 41       	ret			
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
  int16_t ystep;

  if (y0 < y1) {
    d518:	0e 9b       	cmp	r11,	r14	
    d51a:	25 34       	jge	$+76     	;abs 0xd566
    d51c:	0b 48       	mov	r8,	r11	
    d51e:	0a 47       	mov	r7,	r10	
    d520:	05 47       	mov	r7,	r5	
    ystep = 1;
    d522:	04 4f       	mov	r15,	r4	
    d524:	03 3c       	jmp	$+8      	;abs 0xd52c
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    d526:	1b 53       	inc	r11		
    d528:	08 9b       	cmp	r11,	r8	
    d52a:	ed 3b       	jl	$-36     	;abs 0xd506
    if (steep) {
      lcd_drawPixel(y0, x0, color);
    } else {
      lcd_drawPixel(x0, y0, color);
    d52c:	0d 46       	mov	r6,	r13	
    d52e:	0e 49       	mov	r9,	r14	
    d530:	0f 4b       	mov	r11,	r15	
    d532:	b0 12 66 c9 	call	#0xc966	
    }
    err -= dy;
    d536:	0a 87       	sub	r7,	r10	
    if (err < 0) {
    d538:	3a b0 00 80 	bit	#-32768,r10	;#0x8000
    d53c:	f4 37       	jge	$-22     	;abs 0xd526
      y0 += ystep;
    d53e:	09 54       	add	r4,	r9	
      err += dx;
    d540:	0a 55       	add	r5,	r10	
    d542:	f1 3f       	jmp	$-28     	;abs 0xd526

  int16_t dx, dy;
  dx = x1 - x0;
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
    d544:	1a 53       	inc	r10		
    d546:	cb 3f       	jmp	$-104    	;abs 0xd4de
  if (steep) {
    swap(x0, y0);
    swap(x1, y1);
  }

  if (x0 > x1) {
    d548:	0a 47       	mov	r7,	r10	
    d54a:	07 93       	tst	r7		
    d54c:	01 34       	jge	$+4      	;abs 0xd550
    d54e:	0a 5f       	add	r15,	r10	
    d550:	0a 11       	rra	r10		
    d552:	05 47       	mov	r7,	r5	
    d554:	0e 48       	mov	r8,	r14	
    d556:	08 4b       	mov	r11,	r8	
    d558:	0b 49       	mov	r9,	r11	
// Bresenham's algorithm - thx wikpedia
void lcd_gfx_drawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint16_t color) 
{
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
  if (steep) {
    swap(x0, y0);
    d55a:	09 4e       	mov	r14,	r9	
    swap(x1, y1);
  }

  if (x0 > x1) {
    d55c:	07 43       	clr	r7		
  int16_t ystep;

  if (y0 < y1) {
    ystep = 1;
  } else {
    ystep = -1;
    d55e:	34 43       	mov	#-1,	r4	;r3 As==11
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
  int16_t ystep;

  if (y0 < y1) {
    d560:	0f 97       	cmp	r7,	r15	
    d562:	e4 27       	jz	$-54     	;abs 0xd52c
    d564:	c4 3f       	jmp	$-118    	;abs 0xd4ee
    d566:	0b 48       	mov	r8,	r11	
    d568:	0a 47       	mov	r7,	r10	
    d56a:	05 47       	mov	r7,	r5	
    ystep = 1;
  } else {
    ystep = -1;
    d56c:	34 43       	mov	#-1,	r4	;r3 As==11
    d56e:	de 3f       	jmp	$-66     	;abs 0xd52c

0000d570 <lcd_gfx_drawFastHLine>:
  // Update in subclasses if desired!
  lcd_gfx_drawLine(x, y, x, y+h-1, color);
}

void lcd_gfx_drawFastHLine(int16_t x, int16_t y, int16_t w, uint16_t color) 
{
    d570:	0b 12       	push	r11		
    d572:	0a 12       	push	r10		
    d574:	09 12       	push	r9		
    d576:	08 12       	push	r8		
    d578:	07 12       	push	r7		
    d57a:	06 12       	push	r6		
    d57c:	0b 4f       	mov	r15,	r11	
    d57e:	08 4e       	mov	r14,	r8	
    d580:	06 4c       	mov	r12,	r6	
  // Update in subclasses if desired!
  lcd_gfx_drawLine(x, y, x+w-1, y, color);
    d582:	0a 4f       	mov	r15,	r10	
    d584:	3a 53       	add	#-1,	r10	;r3 As==11
    d586:	0a 5d       	add	r13,	r10	
  if (steep) {
    swap(x0, y0);
    swap(x1, y1);
  }

  if (x0 > x1) {
    d588:	0a 9f       	cmp	r15,	r10	
    d58a:	02 34       	jge	$+6      	;abs 0xd590
    d58c:	0b 4a       	mov	r10,	r11	
    d58e:	0a 4f       	mov	r15,	r10	
    swap(x0, x1);
    swap(y0, y1);
  }

  int16_t dx, dy;
  dx = x1 - x0;
    d590:	07 4a       	mov	r10,	r7	
    d592:	07 8b       	sub	r11,	r7	
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
    d594:	09 47       	mov	r7,	r9	
    d596:	14 30       	jn	$+42     	;abs 0xd5c0
    d598:	09 11       	rra	r9		

  for (; x0<=x1; x0++) {
    if (steep) {
      lcd_drawPixel(y0, x0, color);
    } else {
      lcd_drawPixel(x0, y0, color);
    d59a:	0d 46       	mov	r6,	r13	
    d59c:	0e 48       	mov	r8,	r14	
    d59e:	0f 4b       	mov	r11,	r15	
    d5a0:	b0 12 66 c9 	call	#0xc966	
    }
    err -= dy;
    if (err < 0) {
    d5a4:	09 93       	tst	r9		
    d5a6:	02 34       	jge	$+6      	;abs 0xd5ac
      y0 += ystep;
    d5a8:	38 53       	add	#-1,	r8	;r3 As==11
      err += dx;
    d5aa:	09 57       	add	r7,	r9	
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    d5ac:	1b 53       	inc	r11		
    d5ae:	0a 9b       	cmp	r11,	r10	
    d5b0:	f4 37       	jge	$-22     	;abs 0xd59a

void lcd_gfx_drawFastHLine(int16_t x, int16_t y, int16_t w, uint16_t color) 
{
  // Update in subclasses if desired!
  lcd_gfx_drawLine(x, y, x+w-1, y, color);
}
    d5b2:	36 41       	pop	r6		
    d5b4:	37 41       	pop	r7		
    d5b6:	38 41       	pop	r8		
    d5b8:	39 41       	pop	r9		
    d5ba:	3a 41       	pop	r10		
    d5bc:	3b 41       	pop	r11		
    d5be:	30 41       	ret			

  int16_t dx, dy;
  dx = x1 - x0;
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
    d5c0:	19 53       	inc	r9		
    d5c2:	ea 3f       	jmp	$-42     	;abs 0xd598

0000d5c4 <lcd_gfx_drawRoundRect>:
  lcd_gfx_drawLine(x, y, x+w-1, y, color);
}

// Draw a rounded rectangle
void lcd_gfx_drawRoundRect(int16_t x, int16_t y, int16_t w, int16_t h, int16_t r, uint16_t color) 
{
    d5c4:	0b 12       	push	r11		
    d5c6:	0a 12       	push	r10		
    d5c8:	09 12       	push	r9		
    d5ca:	08 12       	push	r8		
    d5cc:	07 12       	push	r7		
    d5ce:	06 12       	push	r6		
    d5d0:	05 12       	push	r5		
    d5d2:	04 12       	push	r4		
    d5d4:	31 50 f0 ff 	add	#-16,	r1	;#0xfff0
    d5d8:	81 4f 02 00 	mov	r15,	2(r1)	;0x0002(r1)
    d5dc:	81 4e 00 00 	mov	r14,	0(r1)	;0x0000(r1)
    d5e0:	81 4d 0a 00 	mov	r13,	10(r1)	;0x000a(r1)
    d5e4:	81 4c 06 00 	mov	r12,	6(r1)	;0x0006(r1)
    d5e8:	14 41 24 00 	mov	36(r1),	r4	;0x0024(r1)
  // smarter version
  lcd_gfx_drawFastHLine(x+r  , y    , w-2*r, color); // Top
    d5ec:	1a 41 22 00 	mov	34(r1),	r10	;0x0022(r1)
    d5f0:	0a 11       	rra	r10		
    d5f2:	0a 43       	clr	r10		
    d5f4:	0a 10       	rrc	r10		
    d5f6:	1a 81 22 00 	sub	34(r1),	r10	;0x0022(r1)
    d5fa:	0a 5a       	rla	r10		
    d5fc:	1f 41 22 00 	mov	34(r1),	r15	;0x0022(r1)
    d600:	1f 51 02 00 	add	2(r1),	r15	;0x0002(r1)
    d604:	81 4f 04 00 	mov	r15,	4(r1)	;0x0004(r1)
    d608:	09 4d       	mov	r13,	r9	
    d60a:	39 53       	add	#-1,	r9	;r3 As==11
}

void lcd_gfx_drawFastHLine(int16_t x, int16_t y, int16_t w, uint16_t color) 
{
  // Update in subclasses if desired!
  lcd_gfx_drawLine(x, y, x+w-1, y, color);
    d60c:	09 5a       	add	r10,	r9	
    d60e:	09 5f       	add	r15,	r9	
  if (steep) {
    swap(x0, y0);
    swap(x1, y1);
  }

  if (x0 > x1) {
    d610:	09 9f       	cmp	r15,	r9	
    d612:	d0 38       	jl	$+418    	;abs 0xd7b4
    d614:	05 49       	mov	r9,	r5	
    d616:	0b 4f       	mov	r15,	r11	
    swap(x0, x1);
    swap(y0, y1);
  }

  int16_t dx, dy;
  dx = x1 - x0;
    d618:	07 45       	mov	r5,	r7	
    d61a:	07 8b       	sub	r11,	r7	
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
    d61c:	08 47       	mov	r7,	r8	
    d61e:	07 93       	tst	r7		
    d620:	d0 38       	jl	$+418    	;abs 0xd7c2
    d622:	08 11       	rra	r8		
    d624:	26 41       	mov	@r1,	r6	

  for (; x0<=x1; x0++) {
    if (steep) {
      lcd_drawPixel(y0, x0, color);
    } else {
      lcd_drawPixel(x0, y0, color);
    d626:	0d 44       	mov	r4,	r13	
    d628:	0e 46       	mov	r6,	r14	
    d62a:	0f 4b       	mov	r11,	r15	
    d62c:	b0 12 66 c9 	call	#0xc966	
    }
    err -= dy;
    if (err < 0) {
    d630:	08 93       	tst	r8		
    d632:	02 34       	jge	$+6      	;abs 0xd638
      y0 += ystep;
    d634:	36 53       	add	#-1,	r6	;r3 As==11
      err += dx;
    d636:	08 57       	add	r7,	r8	
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    d638:	1b 53       	inc	r11		
    d63a:	05 9b       	cmp	r11,	r5	
    d63c:	f4 37       	jge	$-22     	;abs 0xd626
// Draw a rounded rectangle
void lcd_gfx_drawRoundRect(int16_t x, int16_t y, int16_t w, int16_t h, int16_t r, uint16_t color) 
{
  // smarter version
  lcd_gfx_drawFastHLine(x+r  , y    , w-2*r, color); // Top
  lcd_gfx_drawFastHLine(x+r  , y+h-1, w-2*r, color); // Bottom
    d63e:	2f 41       	mov	@r1,	r15	
    d640:	3f 53       	add	#-1,	r15	;r3 As==11
    d642:	1f 51 06 00 	add	6(r1),	r15	;0x0006(r1)
    d646:	81 4f 08 00 	mov	r15,	8(r1)	;0x0008(r1)
  if (steep) {
    swap(x0, y0);
    swap(x1, y1);
  }

  if (x0 > x1) {
    d64a:	19 91 04 00 	cmp	4(r1),	r9	;0x0004(r1)
    d64e:	a8 38       	jl	$+338    	;abs 0xd7a0
    d650:	05 49       	mov	r9,	r5	
    d652:	19 41 04 00 	mov	4(r1),	r9	;0x0004(r1)
    swap(x0, x1);
    swap(y0, y1);
  }

  int16_t dx, dy;
  dx = x1 - x0;
    d656:	0b 45       	mov	r5,	r11	
    d658:	0b 89       	sub	r9,	r11	
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
    d65a:	08 4b       	mov	r11,	r8	
    d65c:	a9 30       	jn	$+340    	;abs 0xd7b0
    d65e:	08 11       	rra	r8		
    d660:	16 41 08 00 	mov	8(r1),	r6	;0x0008(r1)

  for (; x0<=x1; x0++) {
    if (steep) {
      lcd_drawPixel(y0, x0, color);
    } else {
      lcd_drawPixel(x0, y0, color);
    d664:	0d 44       	mov	r4,	r13	
    d666:	0e 46       	mov	r6,	r14	
    d668:	0f 49       	mov	r9,	r15	
    d66a:	b0 12 66 c9 	call	#0xc966	
    }
    err -= dy;
    if (err < 0) {
    d66e:	08 93       	tst	r8		
    d670:	02 34       	jge	$+6      	;abs 0xd676
      y0 += ystep;
    d672:	36 53       	add	#-1,	r6	;r3 As==11
      err += dx;
    d674:	08 5b       	add	r11,	r8	
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    d676:	19 53       	inc	r9		
    d678:	05 99       	cmp	r9,	r5	
    d67a:	f4 37       	jge	$-22     	;abs 0xd664
void lcd_gfx_drawRoundRect(int16_t x, int16_t y, int16_t w, int16_t h, int16_t r, uint16_t color) 
{
  // smarter version
  lcd_gfx_drawFastHLine(x+r  , y    , w-2*r, color); // Top
  lcd_gfx_drawFastHLine(x+r  , y+h-1, w-2*r, color); // Bottom
  lcd_gfx_drawFastVLine(x    , y+r  , h-2*r, color); // Left
    d67c:	1f 41 22 00 	mov	34(r1),	r15	;0x0022(r1)
    d680:	2f 51       	add	@r1,	r15	
    d682:	81 4f 00 00 	mov	r15,	0(r1)	;0x0000(r1)
    d686:	17 41 06 00 	mov	6(r1),	r7	;0x0006(r1)
    d68a:	37 53       	add	#-1,	r7	;r3 As==11
}

void lcd_gfx_drawFastVLine(int16_t x, int16_t y, int16_t h, uint16_t color) 
{
  // Update in subclasses if desired!
  lcd_gfx_drawLine(x, y, x, y+h-1, color);
    d68c:	07 5a       	add	r10,	r7	
    d68e:	07 5f       	add	r15,	r7	
}

// Bresenham's algorithm - thx wikpedia
void lcd_gfx_drawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint16_t color) 
{
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
    d690:	05 47       	mov	r7,	r5	
    d692:	05 8f       	sub	r15,	r5	
    d694:	91 43 0c 00 	mov	#1,	12(r1)	;r3 As==01, 0x000c(r1)
    d698:	a8 24       	jz	$+338    	;abs 0xd7ea
  if (steep) {
    swap(x0, y0);
    swap(x1, y1);
  }

  if (x0 > x1) {
    d69a:	27 91       	cmp	@r1,	r7	
    d69c:	02 38       	jl	$+6      	;abs 0xd6a2
    d69e:	30 40 84 d8 	br	#0xd884	
    swap(x0, x1);
    swap(y0, y1);
  }

  int16_t dx, dy;
  dx = x1 - x0;
    d6a2:	2f 41       	mov	@r1,	r15	
    d6a4:	0f 87       	sub	r7,	r15	
    d6a6:	81 4f 06 00 	mov	r15,	6(r1)	;0x0006(r1)
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
    d6aa:	09 4f       	mov	r15,	r9	
    d6ac:	8c 30       	jn	$+282    	;abs 0xd7c6
    d6ae:	09 11       	rra	r9		
void lcd_gfx_drawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint16_t color) 
{
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
  if (steep) {
    swap(x0, y0);
    swap(x1, y1);
    d6b0:	16 41 02 00 	mov	2(r1),	r6	;0x0002(r1)

  int16_t dx, dy;
  dx = x1 - x0;
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
    d6b4:	08 47       	mov	r7,	r8	
    d6b6:	2a 41       	mov	@r1,	r10	
    d6b8:	1b 41 06 00 	mov	6(r1),	r11	;0x0006(r1)
    d6bc:	03 3c       	jmp	$+8      	;abs 0xd6c4
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    d6be:	18 53       	inc	r8		
    d6c0:	0a 98       	cmp	r8,	r10	
    d6c2:	0c 38       	jl	$+26     	;abs 0xd6dc
    if (steep) {
      lcd_drawPixel(y0, x0, color);
    d6c4:	0d 44       	mov	r4,	r13	
    d6c6:	0e 48       	mov	r8,	r14	
    d6c8:	0f 46       	mov	r6,	r15	
    d6ca:	b0 12 66 c9 	call	#0xc966	
    } else {
      lcd_drawPixel(x0, y0, color);
    }
    err -= dy;
    if (err < 0) {
    d6ce:	09 93       	tst	r9		
    d6d0:	f6 37       	jge	$-18     	;abs 0xd6be
      y0 += ystep;
    d6d2:	36 53       	add	#-1,	r6	;r3 As==11
      err += dx;
    d6d4:	09 5b       	add	r11,	r9	
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    d6d6:	18 53       	inc	r8		
    d6d8:	0a 98       	cmp	r8,	r10	
    d6da:	f4 37       	jge	$-22     	;abs 0xd6c4
{
  // smarter version
  lcd_gfx_drawFastHLine(x+r  , y    , w-2*r, color); // Top
  lcd_gfx_drawFastHLine(x+r  , y+h-1, w-2*r, color); // Bottom
  lcd_gfx_drawFastVLine(x    , y+r  , h-2*r, color); // Left
  lcd_gfx_drawFastVLine(x+w-1, y+r  , h-2*r, color); // Right
    d6dc:	1a 41 02 00 	mov	2(r1),	r10	;0x0002(r1)
    d6e0:	3a 53       	add	#-1,	r10	;r3 As==11
    d6e2:	1a 51 0a 00 	add	10(r1),	r10	;0x000a(r1)
  if (steep) {
    swap(x0, y0);
    swap(x1, y1);
  }

  if (x0 > x1) {
    d6e6:	27 91       	cmp	@r1,	r7	
    d6e8:	b2 34       	jge	$+358    	;abs 0xd84e
    swap(x0, x1);
    swap(y0, y1);
  }

  int16_t dx, dy;
  dx = x1 - x0;
    d6ea:	2b 41       	mov	@r1,	r11	
    d6ec:	0b 87       	sub	r7,	r11	
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
    d6ee:	09 4b       	mov	r11,	r9	
    d6f0:	3b b0 00 80 	bit	#-32768,r11	;#0x8000
    d6f4:	01 34       	jge	$+4      	;abs 0xd6f8
    d6f6:	19 53       	inc	r9		
    d6f8:	09 11       	rra	r9		
    d6fa:	26 41       	mov	@r1,	r6	
    d6fc:	08 4a       	mov	r10,	r8	
    swap(y0, y1);
  }

  int16_t dx, dy;
  dx = x1 - x0;
  dy = abs(y1 - y0);
    d6fe:	05 43       	clr	r5		
  int16_t ystep;

  if (y0 < y1) {
    ystep = 1;
  } else {
    ystep = -1;
    d700:	b1 43 02 00 	mov	#-1,	2(r1)	;r3 As==11, 0x0002(r1)
  }

  for (; x0<=x1; x0++) {
    d704:	81 93 0c 00 	tst	12(r1)		;0x000c(r1)
    d708:	66 20       	jnz	$+206    	;abs 0xd7d6
    d70a:	03 3c       	jmp	$+8      	;abs 0xd712
    d70c:	17 53       	inc	r7		
    d70e:	06 97       	cmp	r7,	r6	
    d710:	0f 38       	jl	$+32     	;abs 0xd730
    if (steep) {
      lcd_drawPixel(y0, x0, color);
    } else {
      lcd_drawPixel(x0, y0, color);
    d712:	0d 44       	mov	r4,	r13	
    d714:	0e 48       	mov	r8,	r14	
    d716:	0f 47       	mov	r7,	r15	
    d718:	b0 12 66 c9 	call	#0xc966	
    }
    err -= dy;
    d71c:	09 85       	sub	r5,	r9	
    if (err < 0) {
    d71e:	39 b0 00 80 	bit	#-32768,r9	;#0x8000
    d722:	f4 37       	jge	$-22     	;abs 0xd70c
      y0 += ystep;
    d724:	18 51 02 00 	add	2(r1),	r8	;0x0002(r1)
      err += dx;
    d728:	09 5b       	add	r11,	r9	
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    d72a:	17 53       	inc	r7		
    d72c:	06 97       	cmp	r7,	r6	
    d72e:	f1 37       	jge	$-28     	;abs 0xd712
  lcd_gfx_drawFastHLine(x+r  , y    , w-2*r, color); // Top
  lcd_gfx_drawFastHLine(x+r  , y+h-1, w-2*r, color); // Bottom
  lcd_gfx_drawFastVLine(x    , y+r  , h-2*r, color); // Left
  lcd_gfx_drawFastVLine(x+w-1, y+r  , h-2*r, color); // Right
  // draw four corners
  lcd_gfx_drawCircleHelper(x+r    , y+r    , r, 1, color);
    d730:	04 12       	push	r4		
    d732:	5c 43       	mov.b	#1,	r12	;r3 As==01
    d734:	1d 41 24 00 	mov	36(r1),	r13	;0x0024(r1)
    d738:	1e 41 02 00 	mov	2(r1),	r14	;0x0002(r1)
    d73c:	1f 41 06 00 	mov	6(r1),	r15	;0x0006(r1)
    d740:	b0 12 88 cb 	call	#0xcb88	
  lcd_gfx_drawCircleHelper(x+w-r-1, y+r    , r, 2, color);
    d744:	1a 81 24 00 	sub	36(r1),	r10	;0x0024(r1)
    d748:	81 44 00 00 	mov	r4,	0(r1)	;0x0000(r1)
    d74c:	6c 43       	mov.b	#2,	r12	;r3 As==10
    d74e:	1d 41 24 00 	mov	36(r1),	r13	;0x0024(r1)
    d752:	1e 41 02 00 	mov	2(r1),	r14	;0x0002(r1)
    d756:	0f 4a       	mov	r10,	r15	
    d758:	b0 12 88 cb 	call	#0xcb88	
  lcd_gfx_drawCircleHelper(x+w-r-1, y+h-r-1, r, 4, color);
    d75c:	1b 41 0a 00 	mov	10(r1),	r11	;0x000a(r1)
    d760:	1b 81 24 00 	sub	36(r1),	r11	;0x0024(r1)
    d764:	81 44 00 00 	mov	r4,	0(r1)	;0x0000(r1)
    d768:	6c 42       	mov.b	#4,	r12	;r2 As==10
    d76a:	1d 41 24 00 	mov	36(r1),	r13	;0x0024(r1)
    d76e:	0e 4b       	mov	r11,	r14	
    d770:	0f 4a       	mov	r10,	r15	
    d772:	b0 12 88 cb 	call	#0xcb88	
  lcd_gfx_drawCircleHelper(x+r    , y+h-r-1, r, 8, color);
    d776:	81 44 00 00 	mov	r4,	0(r1)	;0x0000(r1)
    d77a:	7c 42       	mov.b	#8,	r12	;r2 As==11
    d77c:	1d 41 24 00 	mov	36(r1),	r13	;0x0024(r1)
    d780:	0e 4b       	mov	r11,	r14	
    d782:	1f 41 06 00 	mov	6(r1),	r15	;0x0006(r1)
    d786:	b0 12 88 cb 	call	#0xcb88	
}
    d78a:	31 50 12 00 	add	#18,	r1	;#0x0012
    d78e:	34 41       	pop	r4		
    d790:	35 41       	pop	r5		
    d792:	36 41       	pop	r6		
    d794:	37 41       	pop	r7		
    d796:	38 41       	pop	r8		
    d798:	39 41       	pop	r9		
    d79a:	3a 41       	pop	r10		
    d79c:	3b 41       	pop	r11		
    d79e:	30 41       	ret			
  if (steep) {
    swap(x0, y0);
    swap(x1, y1);
  }

  if (x0 > x1) {
    d7a0:	15 41 04 00 	mov	4(r1),	r5	;0x0004(r1)
    swap(x0, x1);
    swap(y0, y1);
  }

  int16_t dx, dy;
  dx = x1 - x0;
    d7a4:	0b 45       	mov	r5,	r11	
    d7a6:	0b 89       	sub	r9,	r11	
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
    d7a8:	08 4b       	mov	r11,	r8	
    d7aa:	3b b0 00 80 	bit	#-32768,r11	;#0x8000
    d7ae:	57 37       	jge	$-336    	;abs 0xd65e
    d7b0:	18 53       	inc	r8		
    d7b2:	55 3f       	jmp	$-340    	;abs 0xd65e
    d7b4:	05 4f       	mov	r15,	r5	
  if (steep) {
    swap(x0, y0);
    swap(x1, y1);
  }

  if (x0 > x1) {
    d7b6:	0b 49       	mov	r9,	r11	
    swap(x0, x1);
    swap(y0, y1);
  }

  int16_t dx, dy;
  dx = x1 - x0;
    d7b8:	07 45       	mov	r5,	r7	
    d7ba:	07 8b       	sub	r11,	r7	
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
    d7bc:	08 47       	mov	r7,	r8	
    d7be:	07 93       	tst	r7		
    d7c0:	30 37       	jge	$-414    	;abs 0xd622
    d7c2:	18 53       	inc	r8		
    d7c4:	2e 3f       	jmp	$-418    	;abs 0xd622
    d7c6:	19 53       	inc	r9		
    d7c8:	72 3f       	jmp	$-282    	;abs 0xd6ae
    } else {
      lcd_drawPixel(x0, y0, color);
    }
    err -= dy;
    if (err < 0) {
      y0 += ystep;
    d7ca:	18 51 02 00 	add	2(r1),	r8	;0x0002(r1)
      err += dx;
    d7ce:	09 5b       	add	r11,	r9	
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    d7d0:	17 53       	inc	r7		
    d7d2:	06 97       	cmp	r7,	r6	
    d7d4:	ad 3b       	jl	$-164    	;abs 0xd730
    if (steep) {
      lcd_drawPixel(y0, x0, color);
    d7d6:	0d 44       	mov	r4,	r13	
    d7d8:	0e 47       	mov	r7,	r14	
    d7da:	0f 48       	mov	r8,	r15	
    d7dc:	b0 12 66 c9 	call	#0xc966	
    } else {
      lcd_drawPixel(x0, y0, color);
    }
    err -= dy;
    d7e0:	09 85       	sub	r5,	r9	
    if (err < 0) {
    d7e2:	39 b0 00 80 	bit	#-32768,r9	;#0x8000
    d7e6:	f4 37       	jge	$-22     	;abs 0xd7d0
    d7e8:	f0 3f       	jmp	$-30     	;abs 0xd7ca
}

// Bresenham's algorithm - thx wikpedia
void lcd_gfx_drawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint16_t color) 
{
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
    d7ea:	81 45 0c 00 	mov	r5,	12(r1)	;0x000c(r1)
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
  int16_t ystep;

  if (y0 < y1) {
    d7ee:	0f 97       	cmp	r7,	r15	
    d7f0:	3b 34       	jge	$+120    	;abs 0xd868
    d7f2:	0b 45       	mov	r5,	r11	
void lcd_gfx_drawRoundRect(int16_t x, int16_t y, int16_t w, int16_t h, int16_t r, uint16_t color) 
{
  // smarter version
  lcd_gfx_drawFastHLine(x+r  , y    , w-2*r, color); // Top
  lcd_gfx_drawFastHLine(x+r  , y+h-1, w-2*r, color); // Bottom
  lcd_gfx_drawFastVLine(x    , y+r  , h-2*r, color); // Left
    d7f4:	26 41       	mov	@r1,	r6	
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
  int16_t ystep;

  if (y0 < y1) {
    d7f6:	18 41 02 00 	mov	2(r1),	r8	;0x0002(r1)
    d7fa:	0a 48       	mov	r8,	r10	
    d7fc:	09 45       	mov	r5,	r9	
    d7fe:	81 45 06 00 	mov	r5,	6(r1)	;0x0006(r1)
    ystep = 1;
    d802:	91 43 0e 00 	mov	#1,	14(r1)	;r3 As==01, 0x000e(r1)
    d806:	03 3c       	jmp	$+8      	;abs 0xd80e
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    d808:	18 53       	inc	r8		
    d80a:	0a 98       	cmp	r8,	r10	
    d80c:	10 38       	jl	$+34     	;abs 0xd82e
    if (steep) {
      lcd_drawPixel(y0, x0, color);
    } else {
      lcd_drawPixel(x0, y0, color);
    d80e:	0d 44       	mov	r4,	r13	
    d810:	0e 46       	mov	r6,	r14	
    d812:	0f 48       	mov	r8,	r15	
    d814:	b0 12 66 c9 	call	#0xc966	
    }
    err -= dy;
    d818:	09 8b       	sub	r11,	r9	
    if (err < 0) {
    d81a:	39 b0 00 80 	bit	#-32768,r9	;#0x8000
    d81e:	f4 37       	jge	$-22     	;abs 0xd808
      y0 += ystep;
    d820:	16 51 0e 00 	add	14(r1),	r6	;0x000e(r1)
      err += dx;
    d824:	19 51 06 00 	add	6(r1),	r9	;0x0006(r1)
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    d828:	18 53       	inc	r8		
    d82a:	0a 98       	cmp	r8,	r10	
    d82c:	f0 37       	jge	$-30     	;abs 0xd80e
{
  // smarter version
  lcd_gfx_drawFastHLine(x+r  , y    , w-2*r, color); // Top
  lcd_gfx_drawFastHLine(x+r  , y+h-1, w-2*r, color); // Bottom
  lcd_gfx_drawFastVLine(x    , y+r  , h-2*r, color); // Left
  lcd_gfx_drawFastVLine(x+w-1, y+r  , h-2*r, color); // Right
    d82e:	1a 41 02 00 	mov	2(r1),	r10	;0x0002(r1)
    d832:	3a 53       	add	#-1,	r10	;r3 As==11
    d834:	1a 51 0a 00 	add	10(r1),	r10	;0x000a(r1)
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
  int16_t ystep;

  if (y0 < y1) {
    d838:	81 97 00 00 	cmp	r7,	0(r1)	;0x0000(r1)
    d83c:	20 34       	jge	$+66     	;abs 0xd87e
    ystep = 1;
    d83e:	91 43 02 00 	mov	#1,	2(r1)	;r3 As==01, 0x0002(r1)
  } else {
    ystep = -1;
    d842:	06 4a       	mov	r10,	r6	
    d844:	07 4a       	mov	r10,	r7	
    d846:	28 41       	mov	@r1,	r8	
    d848:	09 43       	clr	r9		
    d84a:	0b 49       	mov	r9,	r11	
    d84c:	5b 3f       	jmp	$-328    	;abs 0xd704
  }

  for (; x0<=x1; x0++) {
    d84e:	09 45       	mov	r5,	r9	
    d850:	05 93       	tst	r5		
    d852:	01 34       	jge	$+4      	;abs 0xd856
    d854:	19 53       	inc	r9		
    d856:	09 11       	rra	r9		
  if (steep) {
    swap(x0, y0);
    swap(x1, y1);
  }

  if (x0 > x1) {
    d858:	06 47       	mov	r7,	r6	
    d85a:	27 41       	mov	@r1,	r7	
    d85c:	08 4a       	mov	r10,	r8	
    d85e:	0b 45       	mov	r5,	r11	
    d860:	05 43       	clr	r5		
  int16_t ystep;

  if (y0 < y1) {
    ystep = 1;
  } else {
    ystep = -1;
    d862:	b1 43 02 00 	mov	#-1,	2(r1)	;r3 As==11, 0x0002(r1)
    d866:	4e 3f       	jmp	$-354    	;abs 0xd704
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
  int16_t ystep;

  if (y0 < y1) {
    d868:	0b 45       	mov	r5,	r11	
void lcd_gfx_drawRoundRect(int16_t x, int16_t y, int16_t w, int16_t h, int16_t r, uint16_t color) 
{
  // smarter version
  lcd_gfx_drawFastHLine(x+r  , y    , w-2*r, color); // Top
  lcd_gfx_drawFastHLine(x+r  , y+h-1, w-2*r, color); // Bottom
  lcd_gfx_drawFastVLine(x    , y+r  , h-2*r, color); // Left
    d86a:	26 41       	mov	@r1,	r6	
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
  int16_t ystep;

  if (y0 < y1) {
    d86c:	18 41 02 00 	mov	2(r1),	r8	;0x0002(r1)
    d870:	0a 48       	mov	r8,	r10	
    d872:	09 45       	mov	r5,	r9	
    d874:	81 45 06 00 	mov	r5,	6(r1)	;0x0006(r1)
    ystep = 1;
  } else {
    ystep = -1;
    d878:	b1 43 0e 00 	mov	#-1,	14(r1)	;r3 As==11, 0x000e(r1)
    d87c:	c8 3f       	jmp	$-110    	;abs 0xd80e
    d87e:	b1 43 02 00 	mov	#-1,	2(r1)	;r3 As==11, 0x0002(r1)
    d882:	df 3f       	jmp	$-64     	;abs 0xd842
  if (steep) {
    swap(x0, y0);
    swap(x1, y1);
  }

  if (x0 > x1) {
    d884:	09 45       	mov	r5,	r9	
    d886:	05 93       	tst	r5		
    d888:	01 34       	jge	$+4      	;abs 0xd88c
    d88a:	19 53       	inc	r9		
    d88c:	09 11       	rra	r9		
// Bresenham's algorithm - thx wikpedia
void lcd_gfx_drawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint16_t color) 
{
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
  if (steep) {
    swap(x0, y0);
    d88e:	16 41 02 00 	mov	2(r1),	r6	;0x0002(r1)
    swap(x1, y1);
  }

  if (x0 > x1) {
    d892:	81 45 06 00 	mov	r5,	6(r1)	;0x0006(r1)
    d896:	28 41       	mov	@r1,	r8	
    d898:	0a 47       	mov	r7,	r10	
    d89a:	0b 43       	clr	r11		
  int16_t ystep;

  if (y0 < y1) {
    ystep = 1;
  } else {
    ystep = -1;
    d89c:	b1 43 0e 00 	mov	#-1,	14(r1)	;r3 As==11, 0x000e(r1)
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
  int16_t ystep;

  if (y0 < y1) {
    d8a0:	81 9b 0c 00 	cmp	r11,	12(r1)	;0x000c(r1)
    d8a4:	b4 27       	jz	$-150    	;abs 0xd80e
    d8a6:	0b 45       	mov	r5,	r11	
    d8a8:	30 40 c4 d6 	br	#0xd6c4	

0000d8ac <lcd_gfx_fillRoundRect>:
  lcd_gfx_drawCircleHelper(x+r    , y+h-r-1, r, 8, color);
}

// Fill a rounded rectangle
void lcd_gfx_fillRoundRect(int16_t x, int16_t y, int16_t w, int16_t h, int16_t r, uint16_t color) 
{
    d8ac:	0b 12       	push	r11		
    d8ae:	0a 12       	push	r10		
    d8b0:	09 12       	push	r9		
    d8b2:	08 12       	push	r8		
    d8b4:	07 12       	push	r7		
    d8b6:	06 12       	push	r6		
    d8b8:	05 12       	push	r5		
    d8ba:	04 12       	push	r4		
    d8bc:	04 4f       	mov	r15,	r4	
    d8be:	08 4e       	mov	r14,	r8	
    d8c0:	05 4d       	mov	r13,	r5	
    d8c2:	09 4c       	mov	r12,	r9	
    d8c4:	1a 41 12 00 	mov	18(r1),	r10	;0x0012(r1)
    d8c8:	16 41 14 00 	mov	20(r1),	r6	;0x0014(r1)
  // smarter version
  lcd_fillRect(x+r, y, w-2*r, h, color);
    d8cc:	0b 4a       	mov	r10,	r11	
    d8ce:	0b 11       	rra	r11		
    d8d0:	0b 43       	clr	r11		
    d8d2:	0b 10       	rrc	r11		
    d8d4:	0b 8a       	sub	r10,	r11	
    d8d6:	0b 5b       	rla	r11		
    d8d8:	07 4a       	mov	r10,	r7	
    d8da:	07 5f       	add	r15,	r7	
    d8dc:	06 12       	push	r6		
    d8de:	0d 4b       	mov	r11,	r13	
    d8e0:	0d 55       	add	r5,	r13	
    d8e2:	0f 47       	mov	r7,	r15	
    d8e4:	b0 12 52 c8 	call	#0xc852	

  // draw four corners
  lcd_gfx_fillCircleHelper(x+w-r-1, y+r, r, 1, h-2*r-1, color);
    d8e8:	39 53       	add	#-1,	r9	;r3 As==11
    d8ea:	09 5b       	add	r11,	r9	
    d8ec:	08 5a       	add	r10,	r8	
    d8ee:	0b 44       	mov	r4,	r11	
    d8f0:	3b 53       	add	#-1,	r11	;r3 As==11
    d8f2:	0b 55       	add	r5,	r11	
    d8f4:	81 46 00 00 	mov	r6,	0(r1)	;0x0000(r1)
    d8f8:	09 12       	push	r9		
    d8fa:	5c 43       	mov.b	#1,	r12	;r3 As==01
    d8fc:	0d 4a       	mov	r10,	r13	
    d8fe:	0e 48       	mov	r8,	r14	
    d900:	0f 4b       	mov	r11,	r15	
    d902:	0f 8a       	sub	r10,	r15	
    d904:	b0 12 d6 cc 	call	#0xccd6	
    d908:	21 52       	add	#4,	r1	;r2 As==10
  lcd_gfx_fillCircleHelper(x+r    , y+r, r, 2, h-2*r-1, color);
    d90a:	06 12       	push	r6		
    d90c:	09 12       	push	r9		
    d90e:	6c 43       	mov.b	#2,	r12	;r3 As==10
    d910:	0d 4a       	mov	r10,	r13	
    d912:	0e 48       	mov	r8,	r14	
    d914:	0f 47       	mov	r7,	r15	
    d916:	b0 12 d6 cc 	call	#0xccd6	
    d91a:	21 52       	add	#4,	r1	;r2 As==10
}
    d91c:	34 41       	pop	r4		
    d91e:	35 41       	pop	r5		
    d920:	36 41       	pop	r6		
    d922:	37 41       	pop	r7		
    d924:	38 41       	pop	r8		
    d926:	39 41       	pop	r9		
    d928:	3a 41       	pop	r10		
    d92a:	3b 41       	pop	r11		
    d92c:	30 41       	ret			

0000d92e <lcd_gfx_drawTriangle>:

// Draw a triangle
void lcd_gfx_drawTriangle(int16_t x0, int16_t y0, int16_t x1, int16_t y1, int16_t x2, int16_t y2, uint16_t color) 
{
    d92e:	0b 12       	push	r11		
    d930:	0a 12       	push	r10		
    d932:	09 12       	push	r9		
    d934:	08 12       	push	r8		
    d936:	07 12       	push	r7		
    d938:	06 12       	push	r6		
    d93a:	05 12       	push	r5		
    d93c:	04 12       	push	r4		
    d93e:	31 50 f6 ff 	add	#-10,	r1	;#0xfff6
    d942:	81 4f 02 00 	mov	r15,	2(r1)	;0x0002(r1)
    d946:	81 4e 04 00 	mov	r14,	4(r1)	;0x0004(r1)
    d94a:	08 4d       	mov	r13,	r8	
    d94c:	04 4c       	mov	r12,	r4	
    d94e:	16 41 1c 00 	mov	28(r1),	r6	;0x001c(r1)
}

// Bresenham's algorithm - thx wikpedia
void lcd_gfx_drawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint16_t color) 
{
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
    d952:	0f 4c       	mov	r12,	r15	
    d954:	0f 8e       	sub	r14,	r15	
    d956:	81 4f 00 00 	mov	r15,	0(r1)	;0x0000(r1)
    d95a:	05 4d       	mov	r13,	r5	
    d95c:	15 81 02 00 	sub	2(r1),	r5	;0x0002(r1)
    d960:	1e 43       	mov	#1,	r14	;r3 As==01
    d962:	05 9f       	cmp	r15,	r5	
    d964:	02 2c       	jc	$+6      	;abs 0xd96a
    d966:	30 40 52 db 	br	#0xdb52	
    d96a:	0e 43       	clr	r14		
  if (steep) {
    d96c:	81 45 00 00 	mov	r5,	0(r1)	;0x0000(r1)
    d970:	05 4f       	mov	r15,	r5	
    d972:	0d 4c       	mov	r12,	r13	
    d974:	07 48       	mov	r8,	r7	
    d976:	19 41 04 00 	mov	4(r1),	r9	;0x0004(r1)
    d97a:	1a 41 02 00 	mov	2(r1),	r10	;0x0002(r1)
    swap(x0, y0);
    swap(x1, y1);
  }

  if (x0 > x1) {
    d97e:	07 9a       	cmp	r10,	r7	
    d980:	0c 34       	jge	$+26     	;abs 0xd99a
    d982:	0f 4a       	mov	r10,	r15	
    d984:	0f 87       	sub	r7,	r15	
    d986:	81 4f 00 00 	mov	r15,	0(r1)	;0x0000(r1)
    d98a:	05 49       	mov	r9,	r5	
    d98c:	05 8d       	sub	r13,	r5	
    d98e:	0f 49       	mov	r9,	r15	
    swap(x0, x1);
    swap(y0, y1);
    d990:	09 4d       	mov	r13,	r9	
    d992:	0d 4f       	mov	r15,	r13	
  if (steep) {
    swap(x0, y0);
    swap(x1, y1);
  }

  if (x0 > x1) {
    d994:	0f 4a       	mov	r10,	r15	
    d996:	0a 47       	mov	r7,	r10	
    d998:	07 4f       	mov	r15,	r7	
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
  int16_t ystep;

  if (y0 < y1) {
    d99a:	09 9d       	cmp	r13,	r9	
    d99c:	02 38       	jl	$+6      	;abs 0xd9a2
    d99e:	30 40 4a db 	br	#0xdb4a	
    ystep = 1;
    d9a2:	91 43 06 00 	mov	#1,	6(r1)	;r3 As==01, 0x0006(r1)
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    d9a6:	07 9a       	cmp	r10,	r7	
    d9a8:	25 38       	jl	$+76     	;abs 0xd9f4

  int16_t dx, dy;
  dx = x1 - x0;
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
    d9aa:	2b 41       	mov	@r1,	r11	
    d9ac:	0b 93       	tst	r11		
    d9ae:	02 34       	jge	$+6      	;abs 0xd9b4
    d9b0:	30 40 fa db 	br	#0xdbfa	
    d9b4:	0b 11       	rra	r11		
    d9b6:	0e 93       	tst	r14		
    d9b8:	02 24       	jz	$+6      	;abs 0xd9be
    d9ba:	30 40 ca db 	br	#0xdbca	
    d9be:	81 46 08 00 	mov	r6,	8(r1)	;0x0008(r1)
    d9c2:	06 48       	mov	r8,	r6	
    d9c4:	18 41 20 00 	mov	32(r1),	r8	;0x0020(r1)
    d9c8:	03 3c       	jmp	$+8      	;abs 0xd9d0
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    d9ca:	1a 53       	inc	r10		
    d9cc:	07 9a       	cmp	r10,	r7	
    d9ce:	0f 38       	jl	$+32     	;abs 0xd9ee
    if (steep) {
      lcd_drawPixel(y0, x0, color);
    } else {
      lcd_drawPixel(x0, y0, color);
    d9d0:	0d 48       	mov	r8,	r13	
    d9d2:	0e 49       	mov	r9,	r14	
    d9d4:	0f 4a       	mov	r10,	r15	
    d9d6:	b0 12 66 c9 	call	#0xc966	
    }
    err -= dy;
    d9da:	0b 85       	sub	r5,	r11	
    if (err < 0) {
    d9dc:	3b b0 00 80 	bit	#-32768,r11	;#0x8000
    d9e0:	f4 37       	jge	$-22     	;abs 0xd9ca
      y0 += ystep;
    d9e2:	19 51 06 00 	add	6(r1),	r9	;0x0006(r1)
      err += dx;
    d9e6:	2b 51       	add	@r1,	r11	
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    d9e8:	1a 53       	inc	r10		
    d9ea:	07 9a       	cmp	r10,	r7	
    d9ec:	f1 37       	jge	$-28     	;abs 0xd9d0
    d9ee:	08 46       	mov	r6,	r8	
    d9f0:	16 41 08 00 	mov	8(r1),	r6	;0x0008(r1)
}

// Bresenham's algorithm - thx wikpedia
void lcd_gfx_drawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint16_t color) 
{
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
    d9f4:	15 41 1e 00 	mov	30(r1),	r5	;0x001e(r1)
    d9f8:	05 84       	sub	r4,	r5	
    d9fa:	07 46       	mov	r6,	r7	
    d9fc:	07 88       	sub	r8,	r7	
    d9fe:	1f 43       	mov	#1,	r15	;r3 As==01
    da00:	07 95       	cmp	r5,	r7	
    da02:	9c 28       	jnc	$+314    	;abs 0xdb3c
    da04:	0f 43       	clr	r15		
  if (steep) {
    da06:	0b 45       	mov	r5,	r11	
    da08:	05 47       	mov	r7,	r5	
    da0a:	07 4b       	mov	r11,	r7	
    da0c:	1b 41 1e 00 	mov	30(r1),	r11	;0x001e(r1)
    da10:	09 46       	mov	r6,	r9	
    swap(x0, y0);
    swap(x1, y1);
  }

  if (x0 > x1) {
    da12:	09 98       	cmp	r8,	r9	
    da14:	0a 34       	jge	$+22     	;abs 0xda2a
    da16:	05 48       	mov	r8,	r5	
    da18:	05 89       	sub	r9,	r5	
    da1a:	07 44       	mov	r4,	r7	
    da1c:	07 8b       	sub	r11,	r7	
    da1e:	0a 44       	mov	r4,	r10	
    swap(x0, x1);
    swap(y0, y1);
    da20:	04 4b       	mov	r11,	r4	
    da22:	0b 4a       	mov	r10,	r11	
  if (steep) {
    swap(x0, y0);
    swap(x1, y1);
  }

  if (x0 > x1) {
    da24:	0a 48       	mov	r8,	r10	
    da26:	08 49       	mov	r9,	r8	
    da28:	09 4a       	mov	r10,	r9	
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
  int16_t ystep;

  if (y0 < y1) {
    da2a:	04 9b       	cmp	r11,	r4	
    da2c:	85 34       	jge	$+268    	;abs 0xdb38
    ystep = 1;
    da2e:	1a 43       	mov	#1,	r10	;r3 As==01
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    da30:	09 98       	cmp	r8,	r9	
    da32:	1e 38       	jl	$+62     	;abs 0xda70

  int16_t dx, dy;
  dx = x1 - x0;
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
    da34:	0b 45       	mov	r5,	r11	
    da36:	05 93       	tst	r5		
    da38:	c3 38       	jl	$+392    	;abs 0xdbc0
    da3a:	0b 11       	rra	r11		
    da3c:	0f 93       	tst	r15		
    da3e:	ab 20       	jnz	$+344    	;abs 0xdb96
    da40:	81 46 00 00 	mov	r6,	0(r1)	;0x0000(r1)
    da44:	06 4a       	mov	r10,	r6	
    da46:	1a 41 20 00 	mov	32(r1),	r10	;0x0020(r1)
    da4a:	03 3c       	jmp	$+8      	;abs 0xda52
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    da4c:	18 53       	inc	r8		
    da4e:	09 98       	cmp	r8,	r9	
    da50:	0e 38       	jl	$+30     	;abs 0xda6e
    if (steep) {
      lcd_drawPixel(y0, x0, color);
    } else {
      lcd_drawPixel(x0, y0, color);
    da52:	0d 4a       	mov	r10,	r13	
    da54:	0e 44       	mov	r4,	r14	
    da56:	0f 48       	mov	r8,	r15	
    da58:	b0 12 66 c9 	call	#0xc966	
    }
    err -= dy;
    da5c:	0b 87       	sub	r7,	r11	
    if (err < 0) {
    da5e:	3b b0 00 80 	bit	#-32768,r11	;#0x8000
    da62:	f4 37       	jge	$-22     	;abs 0xda4c
      y0 += ystep;
    da64:	04 56       	add	r6,	r4	
      err += dx;
    da66:	0b 55       	add	r5,	r11	
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    da68:	18 53       	inc	r8		
    da6a:	09 98       	cmp	r8,	r9	
    da6c:	f2 37       	jge	$-26     	;abs 0xda52
    da6e:	26 41       	mov	@r1,	r6	
}

// Bresenham's algorithm - thx wikpedia
void lcd_gfx_drawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint16_t color) 
{
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
    da70:	19 41 04 00 	mov	4(r1),	r9	;0x0004(r1)
    da74:	19 81 1e 00 	sub	30(r1),	r9	;0x001e(r1)
    da78:	1a 41 02 00 	mov	2(r1),	r10	;0x0002(r1)
    da7c:	0a 86       	sub	r6,	r10	
    da7e:	1c 43       	mov	#1,	r12	;r3 As==01
    da80:	0a 99       	cmp	r9,	r10	
    da82:	4d 28       	jnc	$+156    	;abs 0xdb1e
    da84:	0c 43       	clr	r12		
  if (steep) {
    da86:	0b 49       	mov	r9,	r11	
    da88:	09 4a       	mov	r10,	r9	
    da8a:	0a 4b       	mov	r11,	r10	
    swap(x0, y0);
    swap(x1, y1);
  }

  if (x0 > x1) {
    da8c:	81 96 02 00 	cmp	r6,	2(r1)	;0x0002(r1)
    da90:	13 34       	jge	$+40     	;abs 0xdab8
    da92:	09 46       	mov	r6,	r9	
    da94:	19 81 02 00 	sub	2(r1),	r9	;0x0002(r1)
    da98:	1a 41 1e 00 	mov	30(r1),	r10	;0x001e(r1)
    da9c:	1a 81 04 00 	sub	4(r1),	r10	;0x0004(r1)
    daa0:	1b 41 1e 00 	mov	30(r1),	r11	;0x001e(r1)
    swap(x0, x1);
    swap(y0, y1);
    daa4:	91 41 04 00 	mov	4(r1),	30(r1)	;0x0004(r1), 0x001e(r1)
    daa8:	1e 00 
    daaa:	81 4b 04 00 	mov	r11,	4(r1)	;0x0004(r1)
  if (steep) {
    swap(x0, y0);
    swap(x1, y1);
  }

  if (x0 > x1) {
    daae:	0b 46       	mov	r6,	r11	
    dab0:	16 41 02 00 	mov	2(r1),	r6	;0x0002(r1)
    dab4:	81 4b 02 00 	mov	r11,	2(r1)	;0x0002(r1)
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
  int16_t ystep;

  if (y0 < y1) {
    dab8:	91 91 04 00 	cmp	4(r1),	30(r1)	;0x0004(r1), 0x001e(r1)
    dabc:	1e 00 
    dabe:	2d 34       	jge	$+92     	;abs 0xdb1a
    ystep = 1;
    dac0:	18 43       	mov	#1,	r8	;r3 As==01
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    dac2:	81 96 02 00 	cmp	r6,	2(r1)	;0x0002(r1)
    dac6:	1e 38       	jl	$+62     	;abs 0xdb04

  int16_t dx, dy;
  dx = x1 - x0;
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
    dac8:	0b 49       	mov	r9,	r11	
    daca:	09 93       	tst	r9		
    dacc:	5f 38       	jl	$+192    	;abs 0xdb8c
    dace:	0b 11       	rra	r11		
    dad0:	0c 93       	tst	r12		
    dad2:	46 20       	jnz	$+142    	;abs 0xdb60
    dad4:	15 41 02 00 	mov	2(r1),	r5	;0x0002(r1)
    dad8:	17 41 1e 00 	mov	30(r1),	r7	;0x001e(r1)
    dadc:	14 41 20 00 	mov	32(r1),	r4	;0x0020(r1)
    dae0:	03 3c       	jmp	$+8      	;abs 0xdae8
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    dae2:	16 53       	inc	r6		
    dae4:	05 96       	cmp	r6,	r5	
    dae6:	0e 38       	jl	$+30     	;abs 0xdb04
    if (steep) {
      lcd_drawPixel(y0, x0, color);
    } else {
      lcd_drawPixel(x0, y0, color);
    dae8:	0d 44       	mov	r4,	r13	
    daea:	0e 47       	mov	r7,	r14	
    daec:	0f 46       	mov	r6,	r15	
    daee:	b0 12 66 c9 	call	#0xc966	
    }
    err -= dy;
    daf2:	0b 8a       	sub	r10,	r11	
    if (err < 0) {
    daf4:	3b b0 00 80 	bit	#-32768,r11	;#0x8000
    daf8:	f4 37       	jge	$-22     	;abs 0xdae2
      y0 += ystep;
    dafa:	07 58       	add	r8,	r7	
      err += dx;
    dafc:	0b 59       	add	r9,	r11	
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    dafe:	16 53       	inc	r6		
    db00:	05 96       	cmp	r6,	r5	
    db02:	f2 37       	jge	$-26     	;abs 0xdae8
void lcd_gfx_drawTriangle(int16_t x0, int16_t y0, int16_t x1, int16_t y1, int16_t x2, int16_t y2, uint16_t color) 
{
  lcd_gfx_drawLine(x0, y0, x1, y1, color);
  lcd_gfx_drawLine(x1, y1, x2, y2, color);
  lcd_gfx_drawLine(x2, y2, x0, y0, color);
}
    db04:	31 50 0a 00 	add	#10,	r1	;#0x000a
    db08:	34 41       	pop	r4		
    db0a:	35 41       	pop	r5		
    db0c:	36 41       	pop	r6		
    db0e:	37 41       	pop	r7		
    db10:	38 41       	pop	r8		
    db12:	39 41       	pop	r9		
    db14:	3a 41       	pop	r10		
    db16:	3b 41       	pop	r11		
    db18:	30 41       	ret			
  int16_t ystep;

  if (y0 < y1) {
    ystep = 1;
  } else {
    ystep = -1;
    db1a:	38 43       	mov	#-1,	r8	;r3 As==11
    db1c:	d2 3f       	jmp	$-90     	;abs 0xdac2

// Bresenham's algorithm - thx wikpedia
void lcd_gfx_drawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint16_t color) 
{
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
  if (steep) {
    db1e:	1b 41 02 00 	mov	2(r1),	r11	;0x0002(r1)
    swap(x0, y0);
    swap(x1, y1);
    db22:	91 41 04 00 	mov	4(r1),	2(r1)	;0x0004(r1), 0x0002(r1)
    db26:	02 00 
    db28:	81 4b 04 00 	mov	r11,	4(r1)	;0x0004(r1)

// Bresenham's algorithm - thx wikpedia
void lcd_gfx_drawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint16_t color) 
{
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
  if (steep) {
    db2c:	0b 46       	mov	r6,	r11	
    swap(x0, y0);
    db2e:	16 41 1e 00 	mov	30(r1),	r6	;0x001e(r1)
    db32:	81 4b 1e 00 	mov	r11,	30(r1)	;0x001e(r1)
    db36:	aa 3f       	jmp	$-170    	;abs 0xda8c
  int16_t ystep;

  if (y0 < y1) {
    ystep = 1;
  } else {
    ystep = -1;
    db38:	3a 43       	mov	#-1,	r10	;r3 As==11
    db3a:	7a 3f       	jmp	$-266    	;abs 0xda30
void lcd_gfx_drawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint16_t color) 
{
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
  if (steep) {
    swap(x0, y0);
    swap(x1, y1);
    db3c:	0b 46       	mov	r6,	r11	
    db3e:	19 41 1e 00 	mov	30(r1),	r9	;0x001e(r1)

// Bresenham's algorithm - thx wikpedia
void lcd_gfx_drawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint16_t color) 
{
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
  if (steep) {
    db42:	0a 48       	mov	r8,	r10	
    swap(x0, y0);
    db44:	08 44       	mov	r4,	r8	
    db46:	04 4a       	mov	r10,	r4	
    db48:	64 3f       	jmp	$-310    	;abs 0xda12
  int16_t ystep;

  if (y0 < y1) {
    ystep = 1;
  } else {
    ystep = -1;
    db4a:	b1 43 06 00 	mov	#-1,	6(r1)	;r3 As==11, 0x0006(r1)
    db4e:	30 40 a6 d9 	br	#0xd9a6	
void lcd_gfx_drawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint16_t color) 
{
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
  if (steep) {
    swap(x0, y0);
    swap(x1, y1);
    db52:	07 4c       	mov	r12,	r7	
// Bresenham's algorithm - thx wikpedia
void lcd_gfx_drawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint16_t color) 
{
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
  if (steep) {
    swap(x0, y0);
    db54:	19 41 02 00 	mov	2(r1),	r9	;0x0002(r1)
    db58:	1a 41 04 00 	mov	4(r1),	r10	;0x0004(r1)
    db5c:	30 40 7e d9 	br	#0xd97e	
    db60:	15 41 02 00 	mov	2(r1),	r5	;0x0002(r1)
    db64:	17 41 1e 00 	mov	30(r1),	r7	;0x001e(r1)
    db68:	14 41 20 00 	mov	32(r1),	r4	;0x0020(r1)
    db6c:	03 3c       	jmp	$+8      	;abs 0xdb74
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    db6e:	16 53       	inc	r6		
    db70:	05 96       	cmp	r6,	r5	
    db72:	c8 3b       	jl	$-110    	;abs 0xdb04
    if (steep) {
      lcd_drawPixel(y0, x0, color);
    db74:	0d 44       	mov	r4,	r13	
    db76:	0e 46       	mov	r6,	r14	
    db78:	0f 47       	mov	r7,	r15	
    db7a:	b0 12 66 c9 	call	#0xc966	
    } else {
      lcd_drawPixel(x0, y0, color);
    }
    err -= dy;
    db7e:	0b 8a       	sub	r10,	r11	
    if (err < 0) {
    db80:	3b b0 00 80 	bit	#-32768,r11	;#0x8000
    db84:	f4 37       	jge	$-22     	;abs 0xdb6e
      y0 += ystep;
    db86:	07 58       	add	r8,	r7	
      err += dx;
    db88:	0b 59       	add	r9,	r11	
    db8a:	f1 3f       	jmp	$-28     	;abs 0xdb6e

  int16_t dx, dy;
  dx = x1 - x0;
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
    db8c:	1b 53       	inc	r11		
    db8e:	0b 11       	rra	r11		
    db90:	0c 93       	tst	r12		
    db92:	e6 23       	jnz	$-50     	;abs 0xdb60
    db94:	9f 3f       	jmp	$-192    	;abs 0xdad4
    db96:	81 46 00 00 	mov	r6,	0(r1)	;0x0000(r1)
    db9a:	06 4a       	mov	r10,	r6	
    db9c:	1a 41 20 00 	mov	32(r1),	r10	;0x0020(r1)
    dba0:	03 3c       	jmp	$+8      	;abs 0xdba8
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    dba2:	18 53       	inc	r8		
    dba4:	09 98       	cmp	r8,	r9	
    dba6:	63 3b       	jl	$-312    	;abs 0xda6e
    if (steep) {
      lcd_drawPixel(y0, x0, color);
    dba8:	0d 4a       	mov	r10,	r13	
    dbaa:	0e 48       	mov	r8,	r14	
    dbac:	0f 44       	mov	r4,	r15	
    dbae:	b0 12 66 c9 	call	#0xc966	
    } else {
      lcd_drawPixel(x0, y0, color);
    }
    err -= dy;
    dbb2:	0b 87       	sub	r7,	r11	
    if (err < 0) {
    dbb4:	3b b0 00 80 	bit	#-32768,r11	;#0x8000
    dbb8:	f4 37       	jge	$-22     	;abs 0xdba2
      y0 += ystep;
    dbba:	04 56       	add	r6,	r4	
      err += dx;
    dbbc:	0b 55       	add	r5,	r11	
    dbbe:	f1 3f       	jmp	$-28     	;abs 0xdba2

  int16_t dx, dy;
  dx = x1 - x0;
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
    dbc0:	1b 53       	inc	r11		
    dbc2:	0b 11       	rra	r11		
    dbc4:	0f 93       	tst	r15		
    dbc6:	e7 23       	jnz	$-48     	;abs 0xdb96
    dbc8:	3b 3f       	jmp	$-392    	;abs 0xda40
    dbca:	81 46 08 00 	mov	r6,	8(r1)	;0x0008(r1)
    dbce:	06 48       	mov	r8,	r6	
    dbd0:	18 41 20 00 	mov	32(r1),	r8	;0x0020(r1)
    dbd4:	05 3c       	jmp	$+12     	;abs 0xdbe0
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    dbd6:	1a 53       	inc	r10		
    dbd8:	07 9a       	cmp	r10,	r7	
    dbda:	02 34       	jge	$+6      	;abs 0xdbe0
    dbdc:	30 40 ee d9 	br	#0xd9ee	
    if (steep) {
      lcd_drawPixel(y0, x0, color);
    dbe0:	0d 48       	mov	r8,	r13	
    dbe2:	0e 4a       	mov	r10,	r14	
    dbe4:	0f 49       	mov	r9,	r15	
    dbe6:	b0 12 66 c9 	call	#0xc966	
    } else {
      lcd_drawPixel(x0, y0, color);
    }
    err -= dy;
    dbea:	0b 85       	sub	r5,	r11	
    if (err < 0) {
    dbec:	3b b0 00 80 	bit	#-32768,r11	;#0x8000
    dbf0:	f2 37       	jge	$-26     	;abs 0xdbd6
      y0 += ystep;
    dbf2:	19 51 06 00 	add	6(r1),	r9	;0x0006(r1)
      err += dx;
    dbf6:	2b 51       	add	@r1,	r11	
    dbf8:	ee 3f       	jmp	$-34     	;abs 0xdbd6

  int16_t dx, dy;
  dx = x1 - x0;
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
    dbfa:	1b 53       	inc	r11		
    dbfc:	0b 11       	rra	r11		
    dbfe:	0e 93       	tst	r14		
    dc00:	e4 23       	jnz	$-54     	;abs 0xdbca
    dc02:	30 40 be d9 	br	#0xd9be	

0000dc06 <lcd_gfx_fillTriangle>:
  lcd_gfx_drawLine(x2, y2, x0, y0, color);
}

// Fill a triangle
void lcd_gfx_fillTriangle ( int16_t x0, int16_t y0, int16_t x1, int16_t y1, int16_t x2, int16_t y2, uint16_t color) 
{
    dc06:	0b 12       	push	r11		
    dc08:	0a 12       	push	r10		
    dc0a:	09 12       	push	r9		
    dc0c:	08 12       	push	r8		
    dc0e:	07 12       	push	r7		
    dc10:	06 12       	push	r6		
    dc12:	05 12       	push	r5		
    dc14:	04 12       	push	r4		
    dc16:	31 50 e6 ff 	add	#-26,	r1	;#0xffe6
    dc1a:	81 4f 02 00 	mov	r15,	2(r1)	;0x0002(r1)
    dc1e:	81 4e 0e 00 	mov	r14,	14(r1)	;0x000e(r1)
    dc22:	81 4d 0a 00 	mov	r13,	10(r1)	;0x000a(r1)
    dc26:	81 4c 08 00 	mov	r12,	8(r1)	;0x0008(r1)
    dc2a:	14 41 30 00 	mov	48(r1),	r4	;0x0030(r1)

  int16_t a, b, y, last;

  // Sort coordinates by Y order (y2 >= y1 >= y0)
  if (y0 > y1) {
    dc2e:	0c 9e       	cmp	r14,	r12	
    dc30:	08 34       	jge	$+18     	;abs 0xdc42
    dc32:	81 4c 0e 00 	mov	r12,	14(r1)	;0x000e(r1)
    dc36:	81 4e 08 00 	mov	r14,	8(r1)	;0x0008(r1)
    swap(y0, y1); swap(x0, x1);
    dc3a:	81 4d 02 00 	mov	r13,	2(r1)	;0x0002(r1)
    dc3e:	81 4f 0a 00 	mov	r15,	10(r1)	;0x000a(r1)
  }
  if (y1 > y2) {
    dc42:	91 91 08 00 	cmp	8(r1),	46(r1)	;0x0008(r1), 0x002e(r1)
    dc46:	2e 00 
    dc48:	0e 34       	jge	$+30     	;abs 0xdc66
    dc4a:	19 41 08 00 	mov	8(r1),	r9	;0x0008(r1)
    dc4e:	91 41 2e 00 	mov	46(r1),	8(r1)	;0x002e(r1), 0x0008(r1)
    dc52:	08 00 
    dc54:	81 49 2e 00 	mov	r9,	46(r1)	;0x002e(r1)
    dc58:	19 41 0a 00 	mov	10(r1),	r9	;0x000a(r1)
    swap(y2, y1); swap(x2, x1);
    dc5c:	91 41 2c 00 	mov	44(r1),	10(r1)	;0x002c(r1), 0x000a(r1)
    dc60:	0a 00 
    dc62:	81 49 2c 00 	mov	r9,	44(r1)	;0x002c(r1)
  }
  if (y0 > y1) {
    dc66:	91 91 0e 00 	cmp	14(r1),	8(r1)	;0x000e(r1), 0x0008(r1)
    dc6a:	08 00 
    dc6c:	0e 34       	jge	$+30     	;abs 0xdc8a
    dc6e:	19 41 0e 00 	mov	14(r1),	r9	;0x000e(r1)
    dc72:	91 41 08 00 	mov	8(r1),	14(r1)	;0x0008(r1), 0x000e(r1)
    dc76:	0e 00 
    dc78:	81 49 08 00 	mov	r9,	8(r1)	;0x0008(r1)
    dc7c:	19 41 02 00 	mov	2(r1),	r9	;0x0002(r1)
    swap(y0, y1); swap(x0, x1);
    dc80:	91 41 0a 00 	mov	10(r1),	2(r1)	;0x000a(r1), 0x0002(r1)
    dc84:	02 00 
    dc86:	81 49 0a 00 	mov	r9,	10(r1)	;0x000a(r1)
  }

  if(y0 == y2) { // Handle awkward all-on-same-line case as its own thing
    dc8a:	91 91 2e 00 	cmp	46(r1),	14(r1)	;0x002e(r1), 0x000e(r1)
    dc8e:	0e 00 
    dc90:	d4 24       	jz	$+426    	;abs 0xde3a
    lcd_gfx_drawFastHLine(a, y0, b-a+1, color);
    return;
  }

  int16_t
    dx01 = x1 - x0,
    dc92:	1f 41 0a 00 	mov	10(r1),	r15	;0x000a(r1)
    dc96:	1f 81 02 00 	sub	2(r1),	r15	;0x0002(r1)
    dc9a:	81 4f 12 00 	mov	r15,	18(r1)	;0x0012(r1)
    dy01 = y1 - y0,
    dc9e:	1f 41 08 00 	mov	8(r1),	r15	;0x0008(r1)
    dca2:	1f 81 0e 00 	sub	14(r1),	r15	;0x000e(r1)
    dca6:	81 4f 14 00 	mov	r15,	20(r1)	;0x0014(r1)
    dx02 = x2 - x0,
    dcaa:	1f 41 2c 00 	mov	44(r1),	r15	;0x002c(r1)
    dcae:	1f 81 02 00 	sub	2(r1),	r15	;0x0002(r1)
    dcb2:	81 4f 04 00 	mov	r15,	4(r1)	;0x0004(r1)
    dy02 = y2 - y0,
    dcb6:	1f 41 2e 00 	mov	46(r1),	r15	;0x002e(r1)
    dcba:	1f 81 0e 00 	sub	14(r1),	r15	;0x000e(r1)
    dcbe:	81 4f 06 00 	mov	r15,	6(r1)	;0x0006(r1)
    dx12 = x2 - x1,
    dy12 = y2 - y1,
    dcc2:	1f 41 2e 00 	mov	46(r1),	r15	;0x002e(r1)
    dcc6:	1f 81 08 00 	sub	8(r1),	r15	;0x0008(r1)
    dcca:	81 4f 16 00 	mov	r15,	22(r1)	;0x0016(r1)
  // 0-1 and 0-2.  If y1=y2 (flat-bottomed triangle), the scanline y1
  // is included here (and second loop will be skipped, avoiding a /0
  // error there), otherwise scanline y1 is skipped here and handled
  // in the second loop...which also avoids a /0 error here if y0=y1
  // (flat-topped triangle).
  if(y1 == y2) last = y1;   // Include y1 scanline
    dcce:	91 91 2e 00 	cmp	46(r1),	8(r1)	;0x002e(r1), 0x0008(r1)
    dcd2:	08 00 
    dcd4:	d9 24       	jz	$+436    	;abs 0xde88
  else         last = y1-1; // Skip it
    dcd6:	1f 41 08 00 	mov	8(r1),	r15	;0x0008(r1)
    dcda:	3f 53       	add	#-1,	r15	;r3 As==11
    dcdc:	81 4f 10 00 	mov	r15,	16(r1)	;0x0010(r1)

  for(y=y0; y<=last; y++) {
    dce0:	91 91 0e 00 	cmp	14(r1),	16(r1)	;0x000e(r1), 0x0010(r1)
    dce4:	10 00 
    dce6:	02 34       	jge	$+6      	;abs 0xdcec
    dce8:	30 40 b8 de 	br	#0xdeb8	
    dcec:	15 41 0e 00 	mov	14(r1),	r5	;0x000e(r1)
    dcf0:	09 43       	clr	r9		
    dcf2:	81 49 00 00 	mov	r9,	0(r1)	;0x0000(r1)
    dcf6:	81 44 18 00 	mov	r4,	24(r1)	;0x0018(r1)
    dcfa:	04 49       	mov	r9,	r4	
    a   = x0 + sa / dy01;
    dcfc:	2c 41       	mov	@r1,	r12	
    dcfe:	1a 41 14 00 	mov	20(r1),	r10	;0x0014(r1)
    dd02:	b0 12 d4 ee 	call	#0xeed4	
    dd06:	19 41 02 00 	mov	2(r1),	r9	;0x0002(r1)
    dd0a:	09 5c       	add	r12,	r9	
    b   = x0 + sb / dy02;
    dd0c:	0c 44       	mov	r4,	r12	
    dd0e:	1a 41 06 00 	mov	6(r1),	r10	;0x0006(r1)
    dd12:	b0 12 d4 ee 	call	#0xeed4	
    dd16:	17 41 02 00 	mov	2(r1),	r7	;0x0002(r1)
    dd1a:	07 5c       	add	r12,	r7	
  lcd_gfx_drawLine(x1, y1, x2, y2, color);
  lcd_gfx_drawLine(x2, y2, x0, y0, color);
}

// Fill a triangle
void lcd_gfx_fillTriangle ( int16_t x0, int16_t y0, int16_t x1, int16_t y1, int16_t x2, int16_t y2, uint16_t color) 
    dd1c:	91 51 12 00 	add	18(r1),	0(r1)	;0x0012(r1), 0x0000(r1)
    dd20:	00 00 
    dd22:	14 51 04 00 	add	4(r1),	r4	;0x0004(r1)
    sb += dx02;
    /* longhand:
    a = x0 + (x1 - x0) * (y - y0) / (y1 - y0);
    b = x0 + (x2 - x0) * (y - y0) / (y2 - y0);
    */
    if(a > b) swap(a,b);
    dd26:	07 99       	cmp	r9,	r7	
    dd28:	03 34       	jge	$+8      	;abs 0xdd30
    dd2a:	0f 49       	mov	r9,	r15	
    dd2c:	09 47       	mov	r7,	r9	
    dd2e:	07 4f       	mov	r15,	r7	
    swap(x0, x1);
    swap(y0, y1);
  }

  int16_t dx, dy;
  dx = x1 - x0;
    dd30:	06 47       	mov	r7,	r6	
    dd32:	06 89       	sub	r9,	r6	
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
    dd34:	0b 46       	mov	r6,	r11	
    dd36:	36 b0 00 80 	bit	#-32768,r6	;#0x8000
    dd3a:	01 34       	jge	$+4      	;abs 0xdd3e
    dd3c:	1b 53       	inc	r11		
    dd3e:	0b 11       	rra	r11		
    dd40:	08 45       	mov	r5,	r8	
    dd42:	1a 41 18 00 	mov	24(r1),	r10	;0x0018(r1)

  for (; x0<=x1; x0++) {
    if (steep) {
      lcd_drawPixel(y0, x0, color);
    } else {
      lcd_drawPixel(x0, y0, color);
    dd46:	0d 4a       	mov	r10,	r13	
    dd48:	0e 48       	mov	r8,	r14	
    dd4a:	0f 49       	mov	r9,	r15	
    dd4c:	b0 12 66 c9 	call	#0xc966	
    }
    err -= dy;
    if (err < 0) {
    dd50:	0b 93       	tst	r11		
    dd52:	02 34       	jge	$+6      	;abs 0xdd58
      y0 += ystep;
    dd54:	38 53       	add	#-1,	r8	;r3 As==11
      err += dx;
    dd56:	0b 56       	add	r6,	r11	
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    dd58:	19 53       	inc	r9		
    dd5a:	07 99       	cmp	r9,	r7	
    dd5c:	f4 37       	jge	$-22     	;abs 0xdd46
  // in the second loop...which also avoids a /0 error here if y0=y1
  // (flat-topped triangle).
  if(y1 == y2) last = y1;   // Include y1 scanline
  else         last = y1-1; // Skip it

  for(y=y0; y<=last; y++) {
    dd5e:	15 53       	inc	r5		
    dd60:	81 95 10 00 	cmp	r5,	16(r1)	;0x0010(r1)
    dd64:	cb 37       	jge	$-104    	;abs 0xdcfc
    dd66:	14 41 18 00 	mov	24(r1),	r4	;0x0018(r1)

  // For lower part of triangle, find scanline crossings for segments
  // 0-2 and 1-2.  This loop is skipped if y1=y2.
  sa = dx12 * (y - y1);
  sb = dx02 * (y - y0);
  for(; y<=y2; y++) {
    dd6a:	81 95 2e 00 	cmp	r5,	46(r1)	;0x002e(r1)
    dd6e:	5a 38       	jl	$+182    	;abs 0xde24
  int16_t
    dx01 = x1 - x0,
    dy01 = y1 - y0,
    dx02 = x2 - x0,
    dy02 = y2 - y0,
    dx12 = x2 - x1,
    dd70:	1f 41 2c 00 	mov	44(r1),	r15	;0x002c(r1)
    dd74:	1f 81 0a 00 	sub	10(r1),	r15	;0x000a(r1)
    dd78:	81 4f 0c 00 	mov	r15,	12(r1)	;0x000c(r1)
    lcd_gfx_drawFastHLine(a, y, b-a+1, color);
  }

  // For lower part of triangle, find scanline crossings for segments
  // 0-2 and 1-2.  This loop is skipped if y1=y2.
  sa = dx12 * (y - y1);
    dd7c:	0c 45       	mov	r5,	r12	
    dd7e:	1c 81 08 00 	sub	8(r1),	r12	;0x0008(r1)
    dd82:	02 12       	push	r2		
    dd84:	32 c2       	dint			
    dd86:	03 43       	nop			
    dd88:	82 4c 32 01 	mov	r12,	&0x0132	
    dd8c:	82 4f 38 01 	mov	r15,	&0x0138	
    dd90:	19 42 3a 01 	mov	&0x013a,r9	
    dd94:	32 41       	pop	r2		
  sb = dx02 * (y - y0);
    dd96:	0e 45       	mov	r5,	r14	
    dd98:	1e 81 0e 00 	sub	14(r1),	r14	;0x000e(r1)
    dd9c:	02 12       	push	r2		
    dd9e:	32 c2       	dint			
    dda0:	03 43       	nop			
    dda2:	82 4e 32 01 	mov	r14,	&0x0132	
    dda6:	92 41 06 00 	mov	6(r1),	&0x0138	;0x0006(r1)
    ddaa:	38 01 
    ddac:	91 42 3a 01 	mov	&0x013a,2(r1)	;0x0002(r1)
    ddb0:	02 00 
    ddb2:	32 41       	pop	r2		
    ddb4:	81 44 08 00 	mov	r4,	8(r1)	;0x0008(r1)
    ddb8:	04 49       	mov	r9,	r4	
  for(; y<=y2; y++) {
    a   = x1 + sa / dy12;
    ddba:	0c 44       	mov	r4,	r12	
    ddbc:	1a 41 16 00 	mov	22(r1),	r10	;0x0016(r1)
    ddc0:	b0 12 d4 ee 	call	#0xeed4	
    ddc4:	19 41 0a 00 	mov	10(r1),	r9	;0x000a(r1)
    ddc8:	09 5c       	add	r12,	r9	
    b   = x0 + sb / dy02;
    ddca:	2c 41       	mov	@r1,	r12	
    ddcc:	1a 41 06 00 	mov	6(r1),	r10	;0x0006(r1)
    ddd0:	b0 12 d4 ee 	call	#0xeed4	
    ddd4:	17 41 02 00 	mov	2(r1),	r7	;0x0002(r1)
    ddd8:	07 5c       	add	r12,	r7	
  lcd_gfx_drawLine(x1, y1, x2, y2, color);
  lcd_gfx_drawLine(x2, y2, x0, y0, color);
}

// Fill a triangle
void lcd_gfx_fillTriangle ( int16_t x0, int16_t y0, int16_t x1, int16_t y1, int16_t x2, int16_t y2, uint16_t color) 
    ddda:	14 51 0c 00 	add	12(r1),	r4	;0x000c(r1)
    ddde:	91 51 04 00 	add	4(r1),	0(r1)	;0x0004(r1), 0x0000(r1)
    dde2:	00 00 
    sb += dx02;
    /* longhand:
    a = x1 + (x2 - x1) * (y - y1) / (y2 - y1);
    b = x0 + (x2 - x0) * (y - y0) / (y2 - y0);
    */
    if(a > b) swap(a,b);
    dde4:	07 99       	cmp	r9,	r7	
    dde6:	03 34       	jge	$+8      	;abs 0xddee
    dde8:	0f 49       	mov	r9,	r15	
    ddea:	09 47       	mov	r7,	r9	
    ddec:	07 4f       	mov	r15,	r7	
    swap(x0, x1);
    swap(y0, y1);
  }

  int16_t dx, dy;
  dx = x1 - x0;
    ddee:	06 47       	mov	r7,	r6	
    ddf0:	06 89       	sub	r9,	r6	
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
    ddf2:	0b 46       	mov	r6,	r11	
    ddf4:	36 b0 00 80 	bit	#-32768,r6	;#0x8000
    ddf8:	01 34       	jge	$+4      	;abs 0xddfc
    ddfa:	1b 53       	inc	r11		
    ddfc:	0b 11       	rra	r11		
    ddfe:	08 45       	mov	r5,	r8	
    de00:	1a 41 08 00 	mov	8(r1),	r10	;0x0008(r1)

  for (; x0<=x1; x0++) {
    if (steep) {
      lcd_drawPixel(y0, x0, color);
    } else {
      lcd_drawPixel(x0, y0, color);
    de04:	0d 4a       	mov	r10,	r13	
    de06:	0e 48       	mov	r8,	r14	
    de08:	0f 49       	mov	r9,	r15	
    de0a:	b0 12 66 c9 	call	#0xc966	
    }
    err -= dy;
    if (err < 0) {
    de0e:	0b 93       	tst	r11		
    de10:	02 34       	jge	$+6      	;abs 0xde16
      y0 += ystep;
    de12:	38 53       	add	#-1,	r8	;r3 As==11
      err += dx;
    de14:	0b 56       	add	r6,	r11	
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    de16:	19 53       	inc	r9		
    de18:	07 99       	cmp	r9,	r7	
    de1a:	f4 37       	jge	$-22     	;abs 0xde04

  // For lower part of triangle, find scanline crossings for segments
  // 0-2 and 1-2.  This loop is skipped if y1=y2.
  sa = dx12 * (y - y1);
  sb = dx02 * (y - y0);
  for(; y<=y2; y++) {
    de1c:	15 53       	inc	r5		
    de1e:	81 95 2e 00 	cmp	r5,	46(r1)	;0x002e(r1)
    de22:	cb 37       	jge	$-104    	;abs 0xddba
    b = x0 + (x2 - x0) * (y - y0) / (y2 - y0);
    */
    if(a > b) swap(a,b);
    lcd_gfx_drawFastHLine(a, y, b-a+1, color);
  }
}
    de24:	31 50 1a 00 	add	#26,	r1	;#0x001a
    de28:	34 41       	pop	r4		
    de2a:	35 41       	pop	r5		
    de2c:	36 41       	pop	r6		
    de2e:	37 41       	pop	r7		
    de30:	38 41       	pop	r8		
    de32:	39 41       	pop	r9		
    de34:	3a 41       	pop	r10		
    de36:	3b 41       	pop	r11		
    de38:	30 41       	ret			
    swap(y0, y1); swap(x0, x1);
  }

  if(y0 == y2) { // Handle awkward all-on-same-line case as its own thing
    a = b = x0;
    if(x1 < a)      a = x1;
    de3a:	91 91 02 00 	cmp	2(r1),	10(r1)	;0x0002(r1), 0x000a(r1)
    de3e:	0a 00 
    de40:	27 34       	jge	$+80     	;abs 0xde90
    de42:	1c 41 02 00 	mov	2(r1),	r12	;0x0002(r1)
    de46:	1b 41 0a 00 	mov	10(r1),	r11	;0x000a(r1)
    else if(x1 > b) b = x1;
    if(x2 < a)      a = x2;
    de4a:	81 9b 2c 00 	cmp	r11,	44(r1)	;0x002c(r1)
    de4e:	28 38       	jl	$+82     	;abs 0xdea0
    else if(x2 > b) b = x2;
    de50:	1c 91 2c 00 	cmp	44(r1),	r12	;0x002c(r1)
    de54:	27 34       	jge	$+80     	;abs 0xdea4
    de56:	1c 41 2c 00 	mov	44(r1),	r12	;0x002c(r1)
    de5a:	09 4c       	mov	r12,	r9	
    swap(x0, x1);
    swap(y0, y1);
  }

  int16_t dx, dy;
  dx = x1 - x0;
    de5c:	07 49       	mov	r9,	r7	
    de5e:	07 8b       	sub	r11,	r7	
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
    de60:	08 47       	mov	r7,	r8	
    de62:	07 93       	tst	r7		
    de64:	01 34       	jge	$+4      	;abs 0xde68
    de66:	18 53       	inc	r8		
    de68:	08 11       	rra	r8		
    de6a:	1a 41 0e 00 	mov	14(r1),	r10	;0x000e(r1)

  for (; x0<=x1; x0++) {
    if (steep) {
      lcd_drawPixel(y0, x0, color);
    } else {
      lcd_drawPixel(x0, y0, color);
    de6e:	0d 44       	mov	r4,	r13	
    de70:	0e 4a       	mov	r10,	r14	
    de72:	0f 4b       	mov	r11,	r15	
    de74:	b0 12 66 c9 	call	#0xc966	
    }
    err -= dy;
    if (err < 0) {
    de78:	08 93       	tst	r8		
    de7a:	02 34       	jge	$+6      	;abs 0xde80
      y0 += ystep;
    de7c:	3a 53       	add	#-1,	r10	;r3 As==11
      err += dx;
    de7e:	08 57       	add	r7,	r8	
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    de80:	1b 53       	inc	r11		
    de82:	09 9b       	cmp	r11,	r9	
    de84:	f4 37       	jge	$-22     	;abs 0xde6e
    de86:	ce 3f       	jmp	$-98     	;abs 0xde24
  // 0-1 and 0-2.  If y1=y2 (flat-bottomed triangle), the scanline y1
  // is included here (and second loop will be skipped, avoiding a /0
  // error there), otherwise scanline y1 is skipped here and handled
  // in the second loop...which also avoids a /0 error here if y0=y1
  // (flat-topped triangle).
  if(y1 == y2) last = y1;   // Include y1 scanline
    de88:	91 41 08 00 	mov	8(r1),	16(r1)	;0x0008(r1), 0x0010(r1)
    de8c:	10 00 
    de8e:	28 3f       	jmp	$-430    	;abs 0xdce0
  }

  if(y0 == y2) { // Handle awkward all-on-same-line case as its own thing
    a = b = x0;
    if(x1 < a)      a = x1;
    else if(x1 > b) b = x1;
    de90:	91 91 0a 00 	cmp	10(r1),	2(r1)	;0x000a(r1), 0x0002(r1)
    de94:	02 00 
    de96:	0b 38       	jl	$+24     	;abs 0xdeae
    de98:	1c 41 02 00 	mov	2(r1),	r12	;0x0002(r1)
    de9c:	0b 4c       	mov	r12,	r11	
    de9e:	d5 3f       	jmp	$-84     	;abs 0xde4a
    if(x2 < a)      a = x2;
    dea0:	1b 41 2c 00 	mov	44(r1),	r11	;0x002c(r1)
  if (steep) {
    swap(x0, y0);
    swap(x1, y1);
  }

  if (x0 > x1) {
    dea4:	0c 9b       	cmp	r11,	r12	
    dea6:	d9 37       	jge	$-76     	;abs 0xde5a
    dea8:	09 4b       	mov	r11,	r9	
    deaa:	0b 4c       	mov	r12,	r11	
    deac:	d7 3f       	jmp	$-80     	;abs 0xde5c
  }

  if(y0 == y2) { // Handle awkward all-on-same-line case as its own thing
    a = b = x0;
    if(x1 < a)      a = x1;
    else if(x1 > b) b = x1;
    deae:	1c 41 0a 00 	mov	10(r1),	r12	;0x000a(r1)
    deb2:	1b 41 02 00 	mov	2(r1),	r11	;0x0002(r1)
    deb6:	c9 3f       	jmp	$-108    	;abs 0xde4a
  // in the second loop...which also avoids a /0 error here if y0=y1
  // (flat-topped triangle).
  if(y1 == y2) last = y1;   // Include y1 scanline
  else         last = y1-1; // Skip it

  for(y=y0; y<=last; y++) {
    deb8:	15 41 0e 00 	mov	14(r1),	r5	;0x000e(r1)
    debc:	56 3f       	jmp	$-338    	;abs 0xdd6a

0000debe <lcd_gfx_drawBitmap>:
    lcd_gfx_drawFastHLine(a, y, b-a+1, color);
  }
}

void lcd_gfx_drawBitmap(int16_t x, int16_t y, const uint8_t *bitmap, int16_t w, int16_t h, uint16_t color) 
{
    debe:	0b 12       	push	r11		
    dec0:	0a 12       	push	r10		
    dec2:	09 12       	push	r9		
    dec4:	08 12       	push	r8		
    dec6:	07 12       	push	r7		
    dec8:	06 12       	push	r6		
    deca:	05 12       	push	r5		
    decc:	04 12       	push	r4		
    dece:	31 82       	sub	#8,	r1	;r2 As==11
    ded0:	81 4f 00 00 	mov	r15,	0(r1)	;0x0000(r1)
    ded4:	81 4e 04 00 	mov	r14,	4(r1)	;0x0004(r1)
    ded8:	81 4d 06 00 	mov	r13,	6(r1)	;0x0006(r1)
    dedc:	04 4c       	mov	r12,	r4	

  int16_t i, j, byteWidth = (w + 7) / 8;
    dede:	0b 4c       	mov	r12,	r11	
    dee0:	3b 50 07 00 	add	#7,	r11	;#0x0007
    dee4:	3b b0 00 80 	bit	#-32768,r11	;#0x8000
    dee8:	02 34       	jge	$+6      	;abs 0xdeee
    deea:	3b 50 07 00 	add	#7,	r11	;#0x0007
    deee:	0b 11       	rra	r11		
    def0:	81 4b 02 00 	mov	r11,	2(r1)	;0x0002(r1)
    def4:	11 11 02 00 	rra	2(r1)		;0x0002(r1)
    def8:	11 11 02 00 	rra	2(r1)		;0x0002(r1)

  for(j=0; j<h; j++) {
    defc:	0a 43       	clr	r10		
    defe:	1a 91 1a 00 	cmp	26(r1),	r10	;0x001a(r1)
    df02:	33 34       	jge	$+104    	;abs 0xdf6a
    df04:	08 4a       	mov	r10,	r8	
    for(i=0; i<w; i++ ) {
      if( *(bitmap + j * byteWidth + i / 8) & (128 >> (i & 7))) {
    df06:	35 40 80 00 	mov	#128,	r5	;#0x0080
    df0a:	06 4a       	mov	r10,	r6	
{

  int16_t i, j, byteWidth = (w + 7) / 8;

  for(j=0; j<h; j++) {
    for(i=0; i<w; i++ ) {
    df0c:	0f 43       	clr	r15		
    df0e:	0f 94       	cmp	r4,	r15	
    df10:	26 34       	jge	$+78     	;abs 0xdf5e
    df12:	0a 43       	clr	r10		
    df14:	19 41 06 00 	mov	6(r1),	r9	;0x0006(r1)
    df18:	09 56       	add	r6,	r9	
      if( *(bitmap + j * byteWidth + i / 8) & (128 >> (i & 7))) {
	lcd_drawPixel(x+i, y+j, color);
    df1a:	17 41 04 00 	mov	4(r1),	r7	;0x0004(r1)
    df1e:	07 58       	add	r8,	r7	
    df20:	03 3c       	jmp	$+8      	;abs 0xdf28
{

  int16_t i, j, byteWidth = (w + 7) / 8;

  for(j=0; j<h; j++) {
    for(i=0; i<w; i++ ) {
    df22:	1a 53       	inc	r10		
    df24:	0a 94       	cmp	r4,	r10	
    df26:	1b 34       	jge	$+56     	;abs 0xdf5e
      if( *(bitmap + j * byteWidth + i / 8) & (128 >> (i & 7))) {
    df28:	0f 4a       	mov	r10,	r15	
    df2a:	0f 11       	rra	r15		
    df2c:	0f 11       	rra	r15		
    df2e:	0f 11       	rra	r15		
    df30:	0f 59       	add	r9,	r15	
    df32:	6c 4f       	mov.b	@r15,	r12	
    df34:	0b 4a       	mov	r10,	r11	
    df36:	3b f0 07 00 	and	#7,	r11	;#0x0007
    df3a:	0f 45       	mov	r5,	r15	
    df3c:	0b 93       	tst	r11		
    df3e:	03 24       	jz	$+8      	;abs 0xdf46
    df40:	0f 11       	rra	r15		
    df42:	1b 83       	dec	r11		
    df44:	fd 23       	jnz	$-4      	;abs 0xdf40
    df46:	0c ff       	and	r15,	r12	
    df48:	ec 27       	jz	$-38     	;abs 0xdf22
	lcd_drawPixel(x+i, y+j, color);
    df4a:	1d 41 1c 00 	mov	28(r1),	r13	;0x001c(r1)
    df4e:	0e 47       	mov	r7,	r14	
    df50:	2f 41       	mov	@r1,	r15	
    df52:	0f 5a       	add	r10,	r15	
    df54:	b0 12 66 c9 	call	#0xc966	
{

  int16_t i, j, byteWidth = (w + 7) / 8;

  for(j=0; j<h; j++) {
    for(i=0; i<w; i++ ) {
    df58:	1a 53       	inc	r10		
    df5a:	0a 94       	cmp	r4,	r10	
    df5c:	e5 3b       	jl	$-52     	;abs 0xdf28
void lcd_gfx_drawBitmap(int16_t x, int16_t y, const uint8_t *bitmap, int16_t w, int16_t h, uint16_t color) 
{

  int16_t i, j, byteWidth = (w + 7) / 8;

  for(j=0; j<h; j++) {
    df5e:	18 53       	inc	r8		
    df60:	16 51 02 00 	add	2(r1),	r6	;0x0002(r1)
    df64:	18 91 1a 00 	cmp	26(r1),	r8	;0x001a(r1)
    df68:	d1 3b       	jl	$-92     	;abs 0xdf0c
      if( *(bitmap + j * byteWidth + i / 8) & (128 >> (i & 7))) {
	lcd_drawPixel(x+i, y+j, color);
      }
    }
  }
}
    df6a:	31 52       	add	#8,	r1	;r2 As==11
    df6c:	34 41       	pop	r4		
    df6e:	35 41       	pop	r5		
    df70:	36 41       	pop	r6		
    df72:	37 41       	pop	r7		
    df74:	38 41       	pop	r8		
    df76:	39 41       	pop	r9		
    df78:	3a 41       	pop	r10		
    df7a:	3b 41       	pop	r11		
    df7c:	30 41       	ret			

0000df7e <lcd_gfx_drawChar>:
}
*/

// Draw a character
int8_t lcd_gfx_drawChar(int16_t x, int16_t y, unsigned char c, uint16_t color, uint16_t bg, uint8_t size) 
{
    df7e:	0b 12       	push	r11		
    df80:	0a 12       	push	r10		
    df82:	09 12       	push	r9		
    df84:	08 12       	push	r8		
    df86:	07 12       	push	r7		
    df88:	06 12       	push	r6		
    df8a:	05 12       	push	r5		
    df8c:	04 12       	push	r4		
    df8e:	31 50 de ff 	add	#-34,	r1	;#0xffde
    df92:	81 4f 00 00 	mov	r15,	0(r1)	;0x0000(r1)
    df96:	06 4e       	mov	r14,	r6	
    df98:	05 4c       	mov	r12,	r5	
  int8_t i, j;

  if((x >= cur_width)            || // Clip right
    df9a:	1f 92 1c 02 	cmp	&0x021c,r15	
    df9e:	0c 38       	jl	$+26     	;abs 0xdfb8
     (y >= cur_height)           || // Clip bottom
     ((x + 6 * size - 1) < 0) || // Clip left
     ((y + 8 * size - 1) < 0))   // Clip top
    return -1;
    dfa0:	7f 43       	mov.b	#-1,	r15	;r3 As==11
      }
      line >>= 1;
    }
  }
  return 1;
}
    dfa2:	31 50 22 00 	add	#34,	r1	;#0x0022
    dfa6:	34 41       	pop	r4		
    dfa8:	35 41       	pop	r5		
    dfaa:	36 41       	pop	r6		
    dfac:	37 41       	pop	r7		
    dfae:	38 41       	pop	r8		
    dfb0:	39 41       	pop	r9		
    dfb2:	3a 41       	pop	r10		
    dfb4:	3b 41       	pop	r11		
    dfb6:	30 41       	ret			
// Draw a character
int8_t lcd_gfx_drawChar(int16_t x, int16_t y, unsigned char c, uint16_t color, uint16_t bg, uint8_t size) 
{
  int8_t i, j;

  if((x >= cur_width)            || // Clip right
    dfb8:	1e 92 20 02 	cmp	&0x0220,r14	
    dfbc:	f1 37       	jge	$-28     	;abs 0xdfa0
     (y >= cur_height)           || // Clip bottom
     ((x + 6 * size - 1) < 0) || // Clip left
    dfbe:	5f 41 36 00 	mov.b	54(r1),	r15	;0x0036(r1)
    dfc2:	81 4f 02 00 	mov	r15,	2(r1)	;0x0002(r1)
    dfc6:	09 4f       	mov	r15,	r9	
    dfc8:	09 59       	rla	r9		
    dfca:	07 4f       	mov	r15,	r7	
    dfcc:	07 59       	add	r9,	r7	
    dfce:	0c 47       	mov	r7,	r12	
    dfd0:	0c 5c       	rla	r12		
    dfd2:	2f 41       	mov	@r1,	r15	
    dfd4:	0f 5c       	add	r12,	r15	
int8_t lcd_gfx_drawChar(int16_t x, int16_t y, unsigned char c, uint16_t color, uint16_t bg, uint8_t size) 
{
  int8_t i, j;

  if((x >= cur_width)            || // Clip right
     (y >= cur_height)           || // Clip bottom
    dfd6:	0e 43       	clr	r14		
    dfd8:	0e 9f       	cmp	r15,	r14	
    dfda:	e2 37       	jge	$-58     	;abs 0xdfa0
     ((x + 6 * size - 1) < 0) || // Clip left
     ((y + 8 * size - 1) < 0))   // Clip top
    dfdc:	0a 49       	mov	r9,	r10	
    dfde:	0a 5a       	rla	r10		
    dfe0:	08 4a       	mov	r10,	r8	
    dfe2:	08 58       	rla	r8		
    dfe4:	0f 48       	mov	r8,	r15	
    dfe6:	0f 56       	add	r6,	r15	
{
  int8_t i, j;

  if((x >= cur_width)            || // Clip right
     (y >= cur_height)           || // Clip bottom
     ((x + 6 * size - 1) < 0) || // Clip left
    dfe8:	0e 9f       	cmp	r15,	r14	
    dfea:	da 37       	jge	$-74     	;abs 0xdfa0
  {
    uint8_t line;
    if (i == 5) 
      line = 0x0;
    else 
      line = *(glcd_font+(c*5)+i);
    dfec:	4b 4d       	mov.b	r13,	r11	
    dfee:	04 4b       	mov	r11,	r4	
    dff0:	04 54       	rla	r4		
    dff2:	04 5b       	add	r11,	r4	
    dff4:	04 5b       	add	r11,	r4	
    dff6:	04 5b       	add	r11,	r4	
      else if (bg != color) 
      {
        if (size == 1) // default size
          lcd_drawPixel(x+i, y+j, bg);
        else {  // big size
          lcd_fillRect(x+i*size, y+j*size, size, size, bg);
    dff8:	81 49 04 00 	mov	r9,	4(r1)	;0x0004(r1)
    dffc:	81 56 04 00 	add	r6,	4(r1)	;0x0004(r1)
    e000:	81 47 06 00 	mov	r7,	6(r1)	;0x0006(r1)
    e004:	81 56 06 00 	add	r6,	6(r1)	;0x0006(r1)
    e008:	0f 4a       	mov	r10,	r15	
    e00a:	0f 56       	add	r6,	r15	
    e00c:	81 4f 0c 00 	mov	r15,	12(r1)	;0x000c(r1)
    e010:	1a 51 02 00 	add	2(r1),	r10	;0x0002(r1)
    e014:	81 4a 08 00 	mov	r10,	8(r1)	;0x0008(r1)
    e018:	81 56 08 00 	add	r6,	8(r1)	;0x0008(r1)
    e01c:	18 81 02 00 	sub	2(r1),	r8	;0x0002(r1)
    e020:	81 48 0a 00 	mov	r8,	10(r1)	;0x000a(r1)
    e024:	81 56 0a 00 	add	r6,	10(r1)	;0x000a(r1)
  return ((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3);
}
*/

// Draw a character
int8_t lcd_gfx_drawChar(int16_t x, int16_t y, unsigned char c, uint16_t color, uint16_t bg, uint8_t size) 
    e028:	28 41       	mov	@r1,	r8	
    e02a:	07 44       	mov	r4,	r7	
    e02c:	37 50 86 e4 	add	#-7034,	r7	;#0xe486
    e030:	34 50 8c e4 	add	#-7028,	r4	;#0xe48c
    e034:	81 44 20 00 	mov	r4,	32(r1)	;0x0020(r1)
    for (j = 0; j<8; j++) 
    {
      if (line & 0x1) 
      {
        if (size == 1) // default size
          lcd_drawPixel(x+i, y+j, color);
    e038:	0f 46       	mov	r6,	r15	
    e03a:	1f 53       	inc	r15		
    e03c:	81 4f 0e 00 	mov	r15,	14(r1)	;0x000e(r1)
        else 
        {  // big size
          lcd_fillRect(x+(i*size), y+(j*size), size, size, color);
    e040:	1f 41 02 00 	mov	2(r1),	r15	;0x0002(r1)
    e044:	0f 56       	add	r6,	r15	
    e046:	81 4f 10 00 	mov	r15,	16(r1)	;0x0010(r1)
    for (j = 0; j<8; j++) 
    {
      if (line & 0x1) 
      {
        if (size == 1) // default size
          lcd_drawPixel(x+i, y+j, color);
    e04a:	0f 46       	mov	r6,	r15	
    e04c:	2f 53       	incd	r15		
    e04e:	81 4f 12 00 	mov	r15,	18(r1)	;0x0012(r1)
    e052:	1f 53       	inc	r15		
    e054:	81 4f 14 00 	mov	r15,	20(r1)	;0x0014(r1)
    e058:	1f 53       	inc	r15		
    e05a:	81 4f 16 00 	mov	r15,	22(r1)	;0x0016(r1)
    e05e:	1f 53       	inc	r15		
    e060:	81 4f 18 00 	mov	r15,	24(r1)	;0x0018(r1)
    e064:	1f 53       	inc	r15		
    e066:	81 4f 1a 00 	mov	r15,	26(r1)	;0x001a(r1)
        else 
        {  // big size
          lcd_fillRect(x+(i*size), y+(j*size), size, size, color);
    e06a:	0c 56       	add	r6,	r12	
    e06c:	81 4c 1c 00 	mov	r12,	28(r1)	;0x001c(r1)
    for (j = 0; j<8; j++) 
    {
      if (line & 0x1) 
      {
        if (size == 1) // default size
          lcd_drawPixel(x+i, y+j, color);
    e070:	04 46       	mov	r6,	r4	
    e072:	34 50 07 00 	add	#7,	r4	;#0x0007
    e076:	81 44 1e 00 	mov	r4,	30(r1)	;0x001e(r1)
    e07a:	04 46       	mov	r6,	r4	
    e07c:	06 47       	mov	r7,	r6	
    e07e:	07 48       	mov	r8,	r7	
    e080:	19 41 02 00 	mov	2(r1),	r9	;0x0002(r1)
    e084:	93 3c       	jmp	$+296    	;abs 0xe1ac
        else 
        {  // big size
          lcd_fillRect(x+(i*size), y+(j*size), size, size, color);
        } 
      } 
      else if (bg != color) 
    e086:	81 95 34 00 	cmp	r5,	52(r1)	;0x0034(r1)
    e08a:	0f 24       	jz	$+32     	;abs 0xe0aa
      {
        if (size == 1) // default size
    e08c:	d1 93 36 00 	cmp.b	#1,	54(r1)	;r3 As==01, 0x0036(r1)
    e090:	02 20       	jnz	$+6      	;abs 0xe096
    e092:	30 40 10 e3 	br	#0xe310	
          lcd_drawPixel(x+i, y+j, bg);
        else {  // big size
          lcd_fillRect(x+i*size, y+j*size, size, size, bg);
    e096:	11 12 36 00 	push	54(r1)		;0x0036(r1)
      {
        if (size == 1) // default size
          lcd_drawPixel(x+i, y+j, color);
        else 
        {  // big size
          lcd_fillRect(x+(i*size), y+(j*size), size, size, color);
    e09a:	0c 49       	mov	r9,	r12	
    e09c:	0d 49       	mov	r9,	r13	
    e09e:	1e 41 12 00 	mov	18(r1),	r14	;0x0012(r1)
    e0a2:	0f 47       	mov	r7,	r15	
    e0a4:	b0 12 52 c8 	call	#0xc852	
    e0a8:	21 53       	incd	r1		
          lcd_drawPixel(x+i, y+j, bg);
        else {  // big size
          lcd_fillRect(x+i*size, y+j*size, size, size, bg);
        }
      }
      line >>= 1;
    e0aa:	12 c3       	clrc			
    e0ac:	4a 10       	rrc.b	r10		
    else 
      line = *(glcd_font+(c*5)+i);
    
    for (j = 0; j<8; j++) 
    {
      if (line & 0x1) 
    e0ae:	1a b3       	bit	#1,	r10	;r3 As==01
    e0b0:	9e 20       	jnz	$+318    	;abs 0xe1ee
        else 
        {  // big size
          lcd_fillRect(x+(i*size), y+(j*size), size, size, color);
        } 
      } 
      else if (bg != color) 
    e0b2:	81 95 34 00 	cmp	r5,	52(r1)	;0x0034(r1)
    e0b6:	0f 24       	jz	$+32     	;abs 0xe0d6
      {
        if (size == 1) // default size
    e0b8:	d1 93 36 00 	cmp.b	#1,	54(r1)	;r3 As==01, 0x0036(r1)
    e0bc:	02 20       	jnz	$+6      	;abs 0xe0c2
    e0be:	30 40 b2 e2 	br	#0xe2b2	
          lcd_drawPixel(x+i, y+j, bg);
        else {  // big size
          lcd_fillRect(x+i*size, y+j*size, size, size, bg);
    e0c2:	11 12 36 00 	push	54(r1)		;0x0036(r1)
      {
        if (size == 1) // default size
          lcd_drawPixel(x+i, y+j, color);
        else 
        {  // big size
          lcd_fillRect(x+(i*size), y+(j*size), size, size, color);
    e0c6:	0c 49       	mov	r9,	r12	
    e0c8:	0d 49       	mov	r9,	r13	
    e0ca:	1e 41 06 00 	mov	6(r1),	r14	;0x0006(r1)
    e0ce:	0f 47       	mov	r7,	r15	
    e0d0:	b0 12 52 c8 	call	#0xc852	
    e0d4:	21 53       	incd	r1		
          lcd_drawPixel(x+i, y+j, bg);
        else {  // big size
          lcd_fillRect(x+i*size, y+j*size, size, size, bg);
        }
      }
      line >>= 1;
    e0d6:	12 c3       	clrc			
    e0d8:	4a 10       	rrc.b	r10		
    else 
      line = *(glcd_font+(c*5)+i);
    
    for (j = 0; j<8; j++) 
    {
      if (line & 0x1) 
    e0da:	1a b3       	bit	#1,	r10	;r3 As==01
    e0dc:	97 20       	jnz	$+304    	;abs 0xe20c
        else 
        {  // big size
          lcd_fillRect(x+(i*size), y+(j*size), size, size, color);
        } 
      } 
      else if (bg != color) 
    e0de:	81 95 34 00 	cmp	r5,	52(r1)	;0x0034(r1)
    e0e2:	0f 24       	jz	$+32     	;abs 0xe102
      {
        if (size == 1) // default size
    e0e4:	d1 93 36 00 	cmp.b	#1,	54(r1)	;r3 As==01, 0x0036(r1)
    e0e8:	02 20       	jnz	$+6      	;abs 0xe0ee
    e0ea:	30 40 d4 e2 	br	#0xe2d4	
          lcd_drawPixel(x+i, y+j, bg);
        else {  // big size
          lcd_fillRect(x+i*size, y+j*size, size, size, bg);
    e0ee:	11 12 36 00 	push	54(r1)		;0x0036(r1)
      {
        if (size == 1) // default size
          lcd_drawPixel(x+i, y+j, color);
        else 
        {  // big size
          lcd_fillRect(x+(i*size), y+(j*size), size, size, color);
    e0f2:	0c 49       	mov	r9,	r12	
    e0f4:	0d 49       	mov	r9,	r13	
    e0f6:	1e 41 08 00 	mov	8(r1),	r14	;0x0008(r1)
    e0fa:	0f 47       	mov	r7,	r15	
    e0fc:	b0 12 52 c8 	call	#0xc852	
    e100:	21 53       	incd	r1		
          lcd_drawPixel(x+i, y+j, bg);
        else {  // big size
          lcd_fillRect(x+i*size, y+j*size, size, size, bg);
        }
      }
      line >>= 1;
    e102:	12 c3       	clrc			
    e104:	4a 10       	rrc.b	r10		
    else 
      line = *(glcd_font+(c*5)+i);
    
    for (j = 0; j<8; j++) 
    {
      if (line & 0x1) 
    e106:	1a b3       	bit	#1,	r10	;r3 As==01
    e108:	8b 20       	jnz	$+280    	;abs 0xe220
        else 
        {  // big size
          lcd_fillRect(x+(i*size), y+(j*size), size, size, color);
        } 
      } 
      else if (bg != color) 
    e10a:	81 95 34 00 	cmp	r5,	52(r1)	;0x0034(r1)
    e10e:	0d 24       	jz	$+28     	;abs 0xe12a
      {
        if (size == 1) // default size
    e110:	d1 93 36 00 	cmp.b	#1,	54(r1)	;r3 As==01, 0x0036(r1)
    e114:	92 24       	jz	$+294    	;abs 0xe23a
          lcd_drawPixel(x+i, y+j, bg);
        else {  // big size
          lcd_fillRect(x+i*size, y+j*size, size, size, bg);
    e116:	11 12 36 00 	push	54(r1)		;0x0036(r1)
      {
        if (size == 1) // default size
          lcd_drawPixel(x+i, y+j, color);
        else 
        {  // big size
          lcd_fillRect(x+(i*size), y+(j*size), size, size, color);
    e11a:	0c 49       	mov	r9,	r12	
    e11c:	0d 49       	mov	r9,	r13	
    e11e:	1e 41 0e 00 	mov	14(r1),	r14	;0x000e(r1)
    e122:	0f 47       	mov	r7,	r15	
    e124:	b0 12 52 c8 	call	#0xc852	
    e128:	21 53       	incd	r1		
          lcd_drawPixel(x+i, y+j, bg);
        else {  // big size
          lcd_fillRect(x+i*size, y+j*size, size, size, bg);
        }
      }
      line >>= 1;
    e12a:	12 c3       	clrc			
    e12c:	4a 10       	rrc.b	r10		
    else 
      line = *(glcd_font+(c*5)+i);
    
    for (j = 0; j<8; j++) 
    {
      if (line & 0x1) 
    e12e:	1a b3       	bit	#1,	r10	;r3 As==01
    e130:	72 20       	jnz	$+230    	;abs 0xe216
        else 
        {  // big size
          lcd_fillRect(x+(i*size), y+(j*size), size, size, color);
        } 
      } 
      else if (bg != color) 
    e132:	81 95 34 00 	cmp	r5,	52(r1)	;0x0034(r1)
    e136:	0d 24       	jz	$+28     	;abs 0xe152
      {
        if (size == 1) // default size
    e138:	d1 93 36 00 	cmp.b	#1,	54(r1)	;r3 As==01, 0x0036(r1)
    e13c:	8d 24       	jz	$+284    	;abs 0xe258
          lcd_drawPixel(x+i, y+j, bg);
        else {  // big size
          lcd_fillRect(x+i*size, y+j*size, size, size, bg);
    e13e:	11 12 36 00 	push	54(r1)		;0x0036(r1)
      {
        if (size == 1) // default size
          lcd_drawPixel(x+i, y+j, color);
        else 
        {  // big size
          lcd_fillRect(x+(i*size), y+(j*size), size, size, color);
    e142:	0c 49       	mov	r9,	r12	
    e144:	0d 49       	mov	r9,	r13	
    e146:	1e 41 0a 00 	mov	10(r1),	r14	;0x000a(r1)
    e14a:	0f 47       	mov	r7,	r15	
    e14c:	b0 12 52 c8 	call	#0xc852	
    e150:	21 53       	incd	r1		
          lcd_drawPixel(x+i, y+j, bg);
        else {  // big size
          lcd_fillRect(x+i*size, y+j*size, size, size, bg);
        }
      }
      line >>= 1;
    e152:	4b 4a       	mov.b	r10,	r11	
    e154:	12 c3       	clrc			
    e156:	4b 10       	rrc.b	r11		
    else 
      line = *(glcd_font+(c*5)+i);
    
    for (j = 0; j<8; j++) 
    {
      if (line & 0x1) 
    e158:	1b b3       	bit	#1,	r11	;r3 As==01
    e15a:	67 20       	jnz	$+208    	;abs 0xe22a
        else 
        {  // big size
          lcd_fillRect(x+(i*size), y+(j*size), size, size, color);
        } 
      } 
      else if (bg != color) 
    e15c:	81 95 34 00 	cmp	r5,	52(r1)	;0x0034(r1)
    e160:	0d 24       	jz	$+28     	;abs 0xe17c
      {
        if (size == 1) // default size
    e162:	d1 93 36 00 	cmp.b	#1,	54(r1)	;r3 As==01, 0x0036(r1)
    e166:	87 24       	jz	$+272    	;abs 0xe276
          lcd_drawPixel(x+i, y+j, bg);
        else {  // big size
          lcd_fillRect(x+i*size, y+j*size, size, size, bg);
    e168:	11 12 36 00 	push	54(r1)		;0x0036(r1)
      {
        if (size == 1) // default size
          lcd_drawPixel(x+i, y+j, color);
        else 
        {  // big size
          lcd_fillRect(x+(i*size), y+(j*size), size, size, color);
    e16c:	0c 49       	mov	r9,	r12	
    e16e:	0d 49       	mov	r9,	r13	
    e170:	1e 41 1e 00 	mov	30(r1),	r14	;0x001e(r1)
    e174:	0f 47       	mov	r7,	r15	
    e176:	b0 12 52 c8 	call	#0xc852	
    e17a:	21 53       	incd	r1		
    else 
      line = *(glcd_font+(c*5)+i);
    
    for (j = 0; j<8; j++) 
    {
      if (line & 0x1) 
    e17c:	6b f3       	and.b	#2,	r11	;r3 As==10
    e17e:	32 20       	jnz	$+102    	;abs 0xe1e4
        else 
        {  // big size
          lcd_fillRect(x+(i*size), y+(j*size), size, size, color);
        } 
      } 
      else if (bg != color) 
    e180:	81 95 34 00 	cmp	r5,	52(r1)	;0x0034(r1)
    e184:	0d 24       	jz	$+28     	;abs 0xe1a0
      {
        if (size == 1) // default size
    e186:	d1 93 36 00 	cmp.b	#1,	54(r1)	;r3 As==01, 0x0036(r1)
    e18a:	84 24       	jz	$+266    	;abs 0xe294
          lcd_drawPixel(x+i, y+j, bg);
        else {  // big size
          lcd_fillRect(x+i*size, y+j*size, size, size, bg);
    e18c:	11 12 36 00 	push	54(r1)		;0x0036(r1)
      {
        if (size == 1) // default size
          lcd_drawPixel(x+i, y+j, color);
        else 
        {  // big size
          lcd_fillRect(x+(i*size), y+(j*size), size, size, color);
    e190:	0c 49       	mov	r9,	r12	
    e192:	0d 49       	mov	r9,	r13	
    e194:	1e 41 0c 00 	mov	12(r1),	r14	;0x000c(r1)
    e198:	0f 47       	mov	r7,	r15	
    e19a:	b0 12 52 c8 	call	#0xc852	
    e19e:	21 53       	incd	r1		
    for (j = 0; j<8; j++) 
    {
      if (line & 0x1) 
      {
        if (size == 1) // default size
          lcd_drawPixel(x+i, y+j, color);
    e1a0:	07 59       	add	r9,	r7	
    e1a2:	18 53       	inc	r8		
    e1a4:	16 53       	inc	r6		
     (y >= cur_height)           || // Clip bottom
     ((x + 6 * size - 1) < 0) || // Clip left
     ((y + 8 * size - 1) < 0))   // Clip top
    return -1;

  for (i=0; i<6; i++ ) 
    e1a6:	16 91 20 00 	cmp	32(r1),	r6	;0x0020(r1)
    e1aa:	44 24       	jz	$+138    	;abs 0xe234
  return ((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3);
}
*/

// Draw a character
int8_t lcd_gfx_drawChar(int16_t x, int16_t y, unsigned char c, uint16_t color, uint16_t bg, uint8_t size) 
    e1ac:	4b 48       	mov.b	r8,	r11	
    e1ae:	6b 81       	sub.b	@r1,	r11	
    return -1;

  for (i=0; i<6; i++ ) 
  {
    uint8_t line;
    if (i == 5) 
    e1b0:	7b 90 05 00 	cmp.b	#5,	r11	;#0x0005
    e1b4:	21 24       	jz	$+68     	;abs 0xe1f8
      line = 0x0;
    else 
      line = *(glcd_font+(c*5)+i);
    e1b6:	6a 46       	mov.b	@r6,	r10	
    
    for (j = 0; j<8; j++) 
    {
      if (line & 0x1) 
    e1b8:	1a b3       	bit	#1,	r10	;r3 As==01
    e1ba:	1f 24       	jz	$+64     	;abs 0xe1fa
      {
        if (size == 1) // default size
    e1bc:	d1 93 36 00 	cmp.b	#1,	54(r1)	;r3 As==01, 0x0036(r1)
    e1c0:	99 24       	jz	$+308    	;abs 0xe2f4
          lcd_drawPixel(x+i, y+j, color);
        else 
        {  // big size
          lcd_fillRect(x+(i*size), y+(j*size), size, size, color);
    e1c2:	05 12       	push	r5		
    e1c4:	0c 49       	mov	r9,	r12	
    e1c6:	0d 49       	mov	r9,	r13	
    e1c8:	0e 44       	mov	r4,	r14	
    e1ca:	0f 47       	mov	r7,	r15	
    e1cc:	b0 12 52 c8 	call	#0xc852	
    e1d0:	21 53       	incd	r1		
          lcd_drawPixel(x+i, y+j, bg);
        else {  // big size
          lcd_fillRect(x+i*size, y+j*size, size, size, bg);
        }
      }
      line >>= 1;
    e1d2:	12 c3       	clrc			
    e1d4:	4a 10       	rrc.b	r10		
    else 
      line = *(glcd_font+(c*5)+i);
    
    for (j = 0; j<8; j++) 
    {
      if (line & 0x1) 
    e1d6:	1a b3       	bit	#1,	r10	;r3 As==01
    e1d8:	56 27       	jz	$-338    	;abs 0xe086
      {
        if (size == 1) // default size
    e1da:	d1 93 36 00 	cmp.b	#1,	54(r1)	;r3 As==01, 0x0036(r1)
    e1de:	72 24       	jz	$+230    	;abs 0xe2c4
          lcd_drawPixel(x+i, y+j, color);
        else 
        {  // big size
          lcd_fillRect(x+(i*size), y+(j*size), size, size, color);
    e1e0:	05 12       	push	r5		
    e1e2:	5b 3f       	jmp	$-328    	;abs 0xe09a
    
    for (j = 0; j<8; j++) 
    {
      if (line & 0x1) 
      {
        if (size == 1) // default size
    e1e4:	d1 93 36 00 	cmp.b	#1,	54(r1)	;r3 As==01, 0x0036(r1)
    e1e8:	7e 24       	jz	$+254    	;abs 0xe2e6
          lcd_drawPixel(x+i, y+j, color);
        else 
        {  // big size
          lcd_fillRect(x+(i*size), y+(j*size), size, size, color);
    e1ea:	05 12       	push	r5		
    e1ec:	d1 3f       	jmp	$-92     	;abs 0xe190
    
    for (j = 0; j<8; j++) 
    {
      if (line & 0x1) 
      {
        if (size == 1) // default size
    e1ee:	d1 93 36 00 	cmp.b	#1,	54(r1)	;r3 As==01, 0x0036(r1)
    e1f2:	86 24       	jz	$+270    	;abs 0xe300
          lcd_drawPixel(x+i, y+j, color);
        else 
        {  // big size
          lcd_fillRect(x+(i*size), y+(j*size), size, size, color);
    e1f4:	05 12       	push	r5		
    e1f6:	67 3f       	jmp	$-304    	;abs 0xe0c6

  for (i=0; i<6; i++ ) 
  {
    uint8_t line;
    if (i == 5) 
      line = 0x0;
    e1f8:	4a 43       	clr.b	r10		
        else 
        {  // big size
          lcd_fillRect(x+(i*size), y+(j*size), size, size, color);
        } 
      } 
      else if (bg != color) 
    e1fa:	81 95 34 00 	cmp	r5,	52(r1)	;0x0034(r1)
    e1fe:	e9 27       	jz	$-44     	;abs 0xe1d2
      {
        if (size == 1) // default size
    e200:	d1 93 36 00 	cmp.b	#1,	54(r1)	;r3 As==01, 0x0036(r1)
    e204:	22 24       	jz	$+70     	;abs 0xe24a
          lcd_drawPixel(x+i, y+j, bg);
        else {  // big size
          lcd_fillRect(x+i*size, y+j*size, size, size, bg);
    e206:	11 12 36 00 	push	54(r1)		;0x0036(r1)
    e20a:	dc 3f       	jmp	$-70     	;abs 0xe1c4
    
    for (j = 0; j<8; j++) 
    {
      if (line & 0x1) 
      {
        if (size == 1) // default size
    e20c:	d1 93 36 00 	cmp.b	#1,	54(r1)	;r3 As==01, 0x0036(r1)
    e210:	3a 24       	jz	$+118    	;abs 0xe286
          lcd_drawPixel(x+i, y+j, color);
        else 
        {  // big size
          lcd_fillRect(x+(i*size), y+(j*size), size, size, color);
    e212:	05 12       	push	r5		
    e214:	6e 3f       	jmp	$-290    	;abs 0xe0f2
    
    for (j = 0; j<8; j++) 
    {
      if (line & 0x1) 
      {
        if (size == 1) // default size
    e216:	d1 93 36 00 	cmp.b	#1,	54(r1)	;r3 As==01, 0x0036(r1)
    e21a:	26 24       	jz	$+78     	;abs 0xe268
          lcd_drawPixel(x+i, y+j, color);
        else 
        {  // big size
          lcd_fillRect(x+(i*size), y+(j*size), size, size, color);
    e21c:	05 12       	push	r5		
    e21e:	91 3f       	jmp	$-220    	;abs 0xe142
    
    for (j = 0; j<8; j++) 
    {
      if (line & 0x1) 
      {
        if (size == 1) // default size
    e220:	d1 93 36 00 	cmp.b	#1,	54(r1)	;r3 As==01, 0x0036(r1)
    e224:	3f 24       	jz	$+128    	;abs 0xe2a4
          lcd_drawPixel(x+i, y+j, color);
        else 
        {  // big size
          lcd_fillRect(x+(i*size), y+(j*size), size, size, color);
    e226:	05 12       	push	r5		
    e228:	78 3f       	jmp	$-270    	;abs 0xe11a
    
    for (j = 0; j<8; j++) 
    {
      if (line & 0x1) 
      {
        if (size == 1) // default size
    e22a:	d1 93 36 00 	cmp.b	#1,	54(r1)	;r3 As==01, 0x0036(r1)
    e22e:	79 24       	jz	$+244    	;abs 0xe322
          lcd_drawPixel(x+i, y+j, color);
        else 
        {  // big size
          lcd_fillRect(x+(i*size), y+(j*size), size, size, color);
    e230:	05 12       	push	r5		
    e232:	9c 3f       	jmp	$-198    	;abs 0xe16c
        }
      }
      line >>= 1;
    }
  }
  return 1;
    e234:	5f 43       	mov.b	#1,	r15	;r3 As==01
    e236:	30 40 a2 df 	br	#0xdfa2	
        } 
      } 
      else if (bg != color) 
      {
        if (size == 1) // default size
          lcd_drawPixel(x+i, y+j, bg);
    e23a:	1d 41 34 00 	mov	52(r1),	r13	;0x0034(r1)
    e23e:	1e 41 16 00 	mov	22(r1),	r14	;0x0016(r1)
    e242:	0f 48       	mov	r8,	r15	
    e244:	b0 12 66 c9 	call	#0xc966	
    e248:	70 3f       	jmp	$-286    	;abs 0xe12a
    e24a:	1d 41 34 00 	mov	52(r1),	r13	;0x0034(r1)
    e24e:	0e 44       	mov	r4,	r14	
    e250:	0f 48       	mov	r8,	r15	
    e252:	b0 12 66 c9 	call	#0xc966	
    e256:	bd 3f       	jmp	$-132    	;abs 0xe1d2
    e258:	1d 41 34 00 	mov	52(r1),	r13	;0x0034(r1)
    e25c:	1e 41 18 00 	mov	24(r1),	r14	;0x0018(r1)
    e260:	0f 48       	mov	r8,	r15	
    e262:	b0 12 66 c9 	call	#0xc966	
    e266:	75 3f       	jmp	$-276    	;abs 0xe152
    for (j = 0; j<8; j++) 
    {
      if (line & 0x1) 
      {
        if (size == 1) // default size
          lcd_drawPixel(x+i, y+j, color);
    e268:	0d 45       	mov	r5,	r13	
    e26a:	1e 41 18 00 	mov	24(r1),	r14	;0x0018(r1)
    e26e:	0f 48       	mov	r8,	r15	
    e270:	b0 12 66 c9 	call	#0xc966	
    e274:	6e 3f       	jmp	$-290    	;abs 0xe152
        } 
      } 
      else if (bg != color) 
      {
        if (size == 1) // default size
          lcd_drawPixel(x+i, y+j, bg);
    e276:	1d 41 34 00 	mov	52(r1),	r13	;0x0034(r1)
    e27a:	1e 41 1a 00 	mov	26(r1),	r14	;0x001a(r1)
    e27e:	0f 48       	mov	r8,	r15	
    e280:	b0 12 66 c9 	call	#0xc966	
    e284:	7b 3f       	jmp	$-264    	;abs 0xe17c
    for (j = 0; j<8; j++) 
    {
      if (line & 0x1) 
      {
        if (size == 1) // default size
          lcd_drawPixel(x+i, y+j, color);
    e286:	0d 45       	mov	r5,	r13	
    e288:	1e 41 14 00 	mov	20(r1),	r14	;0x0014(r1)
    e28c:	0f 48       	mov	r8,	r15	
    e28e:	b0 12 66 c9 	call	#0xc966	
    e292:	37 3f       	jmp	$-400    	;abs 0xe102
        } 
      } 
      else if (bg != color) 
      {
        if (size == 1) // default size
          lcd_drawPixel(x+i, y+j, bg);
    e294:	1d 41 34 00 	mov	52(r1),	r13	;0x0034(r1)
    e298:	1e 41 1e 00 	mov	30(r1),	r14	;0x001e(r1)
    e29c:	0f 48       	mov	r8,	r15	
    e29e:	b0 12 66 c9 	call	#0xc966	
    e2a2:	7e 3f       	jmp	$-258    	;abs 0xe1a0
    for (j = 0; j<8; j++) 
    {
      if (line & 0x1) 
      {
        if (size == 1) // default size
          lcd_drawPixel(x+i, y+j, color);
    e2a4:	0d 45       	mov	r5,	r13	
    e2a6:	1e 41 16 00 	mov	22(r1),	r14	;0x0016(r1)
    e2aa:	0f 48       	mov	r8,	r15	
    e2ac:	b0 12 66 c9 	call	#0xc966	
    e2b0:	3c 3f       	jmp	$-390    	;abs 0xe12a
        } 
      } 
      else if (bg != color) 
      {
        if (size == 1) // default size
          lcd_drawPixel(x+i, y+j, bg);
    e2b2:	1d 41 34 00 	mov	52(r1),	r13	;0x0034(r1)
    e2b6:	1e 41 12 00 	mov	18(r1),	r14	;0x0012(r1)
    e2ba:	0f 48       	mov	r8,	r15	
    e2bc:	b0 12 66 c9 	call	#0xc966	
    e2c0:	30 40 d6 e0 	br	#0xe0d6	
    for (j = 0; j<8; j++) 
    {
      if (line & 0x1) 
      {
        if (size == 1) // default size
          lcd_drawPixel(x+i, y+j, color);
    e2c4:	0d 45       	mov	r5,	r13	
    e2c6:	1e 41 0e 00 	mov	14(r1),	r14	;0x000e(r1)
    e2ca:	0f 48       	mov	r8,	r15	
    e2cc:	b0 12 66 c9 	call	#0xc966	
    e2d0:	30 40 aa e0 	br	#0xe0aa	
        } 
      } 
      else if (bg != color) 
      {
        if (size == 1) // default size
          lcd_drawPixel(x+i, y+j, bg);
    e2d4:	1d 41 34 00 	mov	52(r1),	r13	;0x0034(r1)
    e2d8:	1e 41 14 00 	mov	20(r1),	r14	;0x0014(r1)
    e2dc:	0f 48       	mov	r8,	r15	
    e2de:	b0 12 66 c9 	call	#0xc966	
    e2e2:	30 40 02 e1 	br	#0xe102	
    for (j = 0; j<8; j++) 
    {
      if (line & 0x1) 
      {
        if (size == 1) // default size
          lcd_drawPixel(x+i, y+j, color);
    e2e6:	0d 45       	mov	r5,	r13	
    e2e8:	1e 41 1e 00 	mov	30(r1),	r14	;0x001e(r1)
    e2ec:	0f 48       	mov	r8,	r15	
    e2ee:	b0 12 66 c9 	call	#0xc966	
    e2f2:	56 3f       	jmp	$-338    	;abs 0xe1a0
    e2f4:	0d 45       	mov	r5,	r13	
    e2f6:	0e 44       	mov	r4,	r14	
    e2f8:	0f 48       	mov	r8,	r15	
    e2fa:	b0 12 66 c9 	call	#0xc966	
    e2fe:	69 3f       	jmp	$-300    	;abs 0xe1d2
    e300:	0d 45       	mov	r5,	r13	
    e302:	1e 41 12 00 	mov	18(r1),	r14	;0x0012(r1)
    e306:	0f 48       	mov	r8,	r15	
    e308:	b0 12 66 c9 	call	#0xc966	
    e30c:	30 40 d6 e0 	br	#0xe0d6	
        } 
      } 
      else if (bg != color) 
      {
        if (size == 1) // default size
          lcd_drawPixel(x+i, y+j, bg);
    e310:	1d 41 34 00 	mov	52(r1),	r13	;0x0034(r1)
    e314:	1e 41 0e 00 	mov	14(r1),	r14	;0x000e(r1)
    e318:	0f 48       	mov	r8,	r15	
    e31a:	b0 12 66 c9 	call	#0xc966	
    e31e:	30 40 aa e0 	br	#0xe0aa	
    for (j = 0; j<8; j++) 
    {
      if (line & 0x1) 
      {
        if (size == 1) // default size
          lcd_drawPixel(x+i, y+j, color);
    e322:	0d 45       	mov	r5,	r13	
    e324:	1e 41 1a 00 	mov	26(r1),	r14	;0x001a(r1)
    e328:	0f 48       	mov	r8,	r15	
    e32a:	b0 12 66 c9 	call	#0xc966	
    e32e:	26 3f       	jmp	$-434    	;abs 0xe17c

0000e330 <lcd_gfx_print>:


// This function will print a character string to the screen
// it automatically moves the cursor position as text is printed
void lcd_gfx_print(char *s)
{
    e330:	0b 12       	push	r11		
    e332:	0a 12       	push	r10		
    e334:	0b 4f       	mov	r15,	r11	
  // Print each character
  while(*s != 0x00){
    e336:	6d 4f       	mov.b	@r15,	r13	
    e338:	4d 93       	tst.b	r13		
    e33a:	6c 24       	jz	$+218    	;abs 0xe414
    e33c:	1f 42 24 02 	mov	&0x0224,r15	
    e340:	5a 42 26 02 	mov.b	&0x0226,r10	
    e344:	4e 4a       	mov.b	r10,	r14	
    e346:	28 3c       	jmp	$+82     	;abs 0xe398
      lcd_fillRect(cursor_x, cursor_y, cur_width - cursor_x, textsize*7+1, textbgcolor);
      cursor_y += 7*textsize +1;
      cursor_x = 0;
    }
    else{
      if (cursor_x + textsize*5 > cur_width) {
    e348:	0d 5d       	rla	r13		
    e34a:	0d 8e       	sub	r14,	r13	
    e34c:	1e 42 1a 02 	mov	&0x021a,r14	
        //Wrap Line 
        cursor_x = 0;
        cursor_y += 7*textsize +1 ;
      }
      if (cursor_y + textsize*7 > cur_height) {
    e350:	0d 5e       	add	r14,	r13	
    e352:	82 9d 20 02 	cmp	r13,	&0x0220	
    e356:	03 34       	jge	$+8      	;abs 0xe35e
        // Wrap Screen
        cursor_y = 0;
    e358:	82 43 1a 02 	mov	#0,	&0x021a	;r3 As==00
    e35c:	0e 43       	clr	r14		
      }
      lcd_gfx_drawChar(cursor_x, cursor_y, *s, textcolor, textbgcolor, textsize);
    e35e:	4a 12       	push.b	r10		
    e360:	12 12 28 02 	push	&0x0228	
    e364:	1c 42 2a 02 	mov	&0x022a,r12	
    e368:	6d 4b       	mov.b	@r11,	r13	
    e36a:	1f 42 24 02 	mov	&0x0224,r15	
    e36e:	b0 12 7e df 	call	#0xdf7e	
    e372:	21 52       	add	#4,	r1	;r2 As==10
      cursor_x += textsize*5 + 1;
    e374:	5a 42 26 02 	mov.b	&0x0226,r10	
    e378:	1f 42 24 02 	mov	&0x0224,r15	
    e37c:	1f 53       	inc	r15		
    e37e:	4e 4a       	mov.b	r10,	r14	
    e380:	0d 4e       	mov	r14,	r13	
    e382:	0d 5d       	rla	r13		
    e384:	0d 5e       	add	r14,	r13	
    e386:	0d 5e       	add	r14,	r13	
    e388:	0d 5e       	add	r14,	r13	
    e38a:	0f 5d       	add	r13,	r15	
    e38c:	82 4f 24 02 	mov	r15,	&0x0224	
    }
    s++;
    e390:	1b 53       	inc	r11		
// This function will print a character string to the screen
// it automatically moves the cursor position as text is printed
void lcd_gfx_print(char *s)
{
  // Print each character
  while(*s != 0x00){
    e392:	6d 4b       	mov.b	@r11,	r13	
    e394:	4d 93       	tst.b	r13		
    e396:	3e 24       	jz	$+126    	;abs 0xe414
    if (*s == 0x0A){
    e398:	7d 90 0a 00 	cmp.b	#10,	r13	;#0x000a
    e39c:	14 24       	jz	$+42     	;abs 0xe3c6
      lcd_fillRect(cursor_x, cursor_y, cur_width - cursor_x, textsize*7+1, textbgcolor);
      cursor_y += 7*textsize +1;
      cursor_x = 0;
    }
    else{
      if (cursor_x + textsize*5 > cur_width) {
    e39e:	0d 4e       	mov	r14,	r13	
    e3a0:	0d 5d       	rla	r13		
    e3a2:	0d 5d       	rla	r13		
    e3a4:	0c 4d       	mov	r13,	r12	
    e3a6:	0c 5e       	add	r14,	r12	
    e3a8:	0c 5f       	add	r15,	r12	
    e3aa:	82 9c 1c 02 	cmp	r12,	&0x021c	
    e3ae:	cc 37       	jge	$-102    	;abs 0xe348
        //Wrap Line 
        cursor_x = 0;
    e3b0:	82 43 24 02 	mov	#0,	&0x0224	;r3 As==00
        cursor_y += 7*textsize +1 ;
    e3b4:	0d 5d       	rla	r13		
    e3b6:	0d 8e       	sub	r14,	r13	
    e3b8:	1e 42 1a 02 	mov	&0x021a,r14	
    e3bc:	1e 53       	inc	r14		
    e3be:	0e 5d       	add	r13,	r14	
    e3c0:	82 4e 1a 02 	mov	r14,	&0x021a	
    e3c4:	c5 3f       	jmp	$-116    	;abs 0xe350
{
  // Print each character
  while(*s != 0x00){
    if (*s == 0x0A){
      // Overwrite the rest of the line 
      lcd_fillRect(cursor_x, cursor_y, cur_width - cursor_x, textsize*7+1, textbgcolor);
    e3c6:	0c 4e       	mov	r14,	r12	
    e3c8:	0c 5c       	rla	r12		
    e3ca:	0c 5c       	rla	r12		
    e3cc:	0c 5e       	add	r14,	r12	
    e3ce:	0c 5e       	add	r14,	r12	
    e3d0:	0c 5e       	add	r14,	r12	
    e3d2:	12 12 28 02 	push	&0x0228	
    e3d6:	1c 53       	inc	r12		
    e3d8:	1d 42 1c 02 	mov	&0x021c,r13	
    e3dc:	0d 8f       	sub	r15,	r13	
    e3de:	1e 42 1a 02 	mov	&0x021a,r14	
    e3e2:	b0 12 52 c8 	call	#0xc852	
    e3e6:	21 53       	incd	r1		
      cursor_y += 7*textsize +1;
    e3e8:	5a 42 26 02 	mov.b	&0x0226,r10	
    e3ec:	1d 42 1a 02 	mov	&0x021a,r13	
    e3f0:	1d 53       	inc	r13		
    e3f2:	4e 4a       	mov.b	r10,	r14	
    e3f4:	0f 4e       	mov	r14,	r15	
    e3f6:	0f 5f       	rla	r15		
    e3f8:	0f 5f       	rla	r15		
    e3fa:	0f 5e       	add	r14,	r15	
    e3fc:	0f 5e       	add	r14,	r15	
    e3fe:	0f 5e       	add	r14,	r15	
    e400:	0d 5f       	add	r15,	r13	
    e402:	82 4d 1a 02 	mov	r13,	&0x021a	
      cursor_x = 0;
    e406:	82 43 24 02 	mov	#0,	&0x0224	;r3 As==00
    e40a:	0f 43       	clr	r15		
        cursor_y = 0;
      }
      lcd_gfx_drawChar(cursor_x, cursor_y, *s, textcolor, textbgcolor, textsize);
      cursor_x += textsize*5 + 1;
    }
    s++;
    e40c:	1b 53       	inc	r11		
// This function will print a character string to the screen
// it automatically moves the cursor position as text is printed
void lcd_gfx_print(char *s)
{
  // Print each character
  while(*s != 0x00){
    e40e:	6d 4b       	mov.b	@r11,	r13	
    e410:	4d 93       	tst.b	r13		
    e412:	c2 23       	jnz	$-122    	;abs 0xe398
      lcd_gfx_drawChar(cursor_x, cursor_y, *s, textcolor, textbgcolor, textsize);
      cursor_x += textsize*5 + 1;
    }
    s++;
  }
}
    e414:	3a 41       	pop	r10		
    e416:	3b 41       	pop	r11		
    e418:	30 41       	ret			

0000e41a <lcd_gfx_setCursor>:
}
*/

void lcd_gfx_setCursor(int16_t x, int16_t y) 
{
  cursor_x = x;
    e41a:	82 4f 24 02 	mov	r15,	&0x0224	
  cursor_y = y;
    e41e:	82 4e 1a 02 	mov	r14,	&0x021a	
}
    e422:	30 41       	ret			

0000e424 <lcd_gfx_setTextSize>:

void lcd_gfx_setTextSize(uint8_t s) 
{
  textsize = (s > 0) ? s : 1;
    e424:	4f 93       	tst.b	r15		
    e426:	01 20       	jnz	$+4      	;abs 0xe42a
    e428:	5f 43       	mov.b	#1,	r15	;r3 As==01
    e42a:	c2 4f 26 02 	mov.b	r15,	&0x0226	
}
    e42e:	30 41       	ret			

0000e430 <lcd_gfx_setTextColor>:

void lcd_gfx_setTextColor(uint16_t c, uint16_t b) 
{
  textcolor   = c;
    e430:	82 4f 2a 02 	mov	r15,	&0x022a	
  textbgcolor = b; 
    e434:	82 4e 28 02 	mov	r14,	&0x0228	
}
    e438:	30 41       	ret			

0000e43a <lcd_gfx_getRotation>:

uint8_t lcd_gfx_getRotation(void) 
{
  return rotation;
}
    e43a:	5f 42 22 02 	mov.b	&0x0222,r15	
    e43e:	30 41       	ret			

0000e440 <lcd_gfx_setRotation>:

void lcd_gfx_setRotation(uint8_t x) 
{
  rotation = (x & 3);
    e440:	7f f0 03 00 	and.b	#3,	r15	;#0x0003
    e444:	c2 4f 22 02 	mov.b	r15,	&0x0222	
  switch(rotation) {
    e448:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    e44a:	0a 24       	jz	$+22     	;abs 0xe460
    e44c:	7f 90 03 00 	cmp.b	#3,	r15	;#0x0003
    e450:	07 24       	jz	$+16     	;abs 0xe460
   case 0:
   case 2:
    cur_width  = CONST_WIDTH;
    e452:	92 42 1e 02 	mov	&0x021e,&0x021c	
    e456:	1c 02 
    cur_height = CONST_HEIGHT;
    e458:	92 42 18 02 	mov	&0x0218,&0x0220	
    e45c:	20 02 
    break;
    e45e:	30 41       	ret			
   case 1:
   case 3:
    cur_width  = CONST_HEIGHT;
    e460:	92 42 18 02 	mov	&0x0218,&0x021c	
    e464:	1c 02 
    cur_height = CONST_WIDTH;
    e466:	92 42 1e 02 	mov	&0x021e,&0x0220	
    e46a:	20 02 
    e46c:	30 41       	ret			

0000e46e <lcd_gfx_getWidth>:

// Return the size of the display 
int16_t lcd_gfx_getWidth(void) 
{
  return cur_width;
}
    e46e:	1f 42 1c 02 	mov	&0x021c,r15	
    e472:	30 41       	ret			

0000e474 <lcd_gfx_getHeight>:
 
int16_t lcd_gfx_getHeight(void) 
{
  return cur_height;
}
    e474:	1f 42 20 02 	mov	&0x0220,r15	
    e478:	30 41       	ret			

0000e47a <lcd_gfx_setWidth>:

// Set the size of the display 
void lcd_gfx_setWidth(uint16_t w) 
{
  cur_width = w;
    e47a:	82 4f 1c 02 	mov	r15,	&0x021c	
}
    e47e:	30 41       	ret			

0000e480 <lcd_gfx_setHeight>:
 
void lcd_gfx_setHeight(uint16_t h) 
{
  cur_height = h;
    e480:	82 4f 20 02 	mov	r15,	&0x0220	
}
    e484:	30 41       	ret			

0000e486 <glcd_font>:
    e486:	00 00 00 00 00 3e 5b 4f 5b 3e 3e 6b 4f 6b 3e 1c     .....>[O[>>kOk>.
    e496:	3e 7c 3e 1c 18 3c 7e 3c 18 1c 57 7d 57 1c 1c 5e     >|>..<~<..W}W..^
    e4a6:	7f 5e 1c 00 18 3c 18 00 ff e7 c3 e7 ff 00 18 24     .^...<.........$
    e4b6:	18 00 ff e7 db e7 ff 30 48 3a 06 0e 26 29 79 29     .......0H:..&)y)
    e4c6:	26 40 7f 05 05 07 40 7f 05 25 3f 5a 3c e7 3c 5a     &@....@..%?Z<.<Z
    e4d6:	7f 3e 1c 1c 08 08 1c 1c 3e 7f 14 22 7f 22 14 5f     .>......>.."."._
    e4e6:	5f 00 5f 5f 06 09 7f 01 7f 00 66 89 95 6a 60 60     _.__......f..j``
    e4f6:	60 60 60 94 a2 ff a2 94 08 04 7e 04 08 10 20 7e     ```.......~... ~
    e506:	20 10 08 08 2a 1c 08 08 1c 2a 08 08 1e 10 10 10      ...*....*......
    e516:	10 0c 1e 0c 1e 0c 30 38 3e 38 30 06 0e 3e 0e 06     ......08>80..>..
    e526:	00 00 00 00 00 00 00 5f 00 00 00 07 00 07 00 14     ......._........
    e536:	7f 14 7f 14 24 2a 7f 2a 12 23 13 08 64 62 36 49     ....$*.*.#..db6I
    e546:	56 20 50 00 08 07 03 00 00 1c 22 41 00 00 41 22     V P......."A..A"
    e556:	1c 00 2a 1c 7f 1c 2a 08 08 3e 08 08 00 80 70 30     ..*...*..>....p0
    e566:	00 08 08 08 08 08 00 00 60 60 00 20 10 08 04 02     ........``. ....
    e576:	3e 51 49 45 3e 00 42 7f 40 00 72 49 49 49 46 21     >QIE>.B.@.rIIIF!
    e586:	41 49 4d 33 18 14 12 7f 10 27 45 45 45 39 3c 4a     AIM3.....'EEE9<J
    e596:	49 49 31 41 21 11 09 07 36 49 49 49 36 46 49 49     II1A!...6III6FII
    e5a6:	29 1e 00 00 14 00 00 00 40 34 00 00 00 08 14 22     ).......@4....."
    e5b6:	41 14 14 14 14 14 00 41 22 14 08 02 01 59 09 06     A......A"....Y..
    e5c6:	3e 41 5d 59 4e 7c 12 11 12 7c 7f 49 49 49 36 3e     >A]YN|...|.III6>
    e5d6:	41 41 41 22 7f 41 41 41 3e 7f 49 49 49 41 7f 09     AAA".AAA>.IIIA..
    e5e6:	09 09 01 3e 41 41 51 73 7f 08 08 08 7f 00 41 7f     ...>AAQs......A.
    e5f6:	41 00 20 40 41 3f 01 7f 08 14 22 41 7f 40 40 40     A. @A?...."A.@@@
    e606:	40 7f 02 1c 02 7f 7f 04 08 10 7f 3e 41 41 41 3e     @..........>AAA>
    e616:	7f 09 09 09 06 3e 41 51 21 5e 7f 09 19 29 46 26     .....>AQ!^...)F&
    e626:	49 49 49 32 03 01 7f 01 03 3f 40 40 40 3f 1f 20     III2.....?@@@?. 
    e636:	40 20 1f 3f 40 38 40 3f 63 14 08 14 63 03 04 78     @ .?@8@?c...c..x
    e646:	04 03 61 59 49 4d 43 00 7f 41 41 41 02 04 08 10     ..aYIMC..AAA....
    e656:	20 00 41 41 41 7f 04 02 01 02 04 40 40 40 40 40      .AAA......@@@@@
    e666:	00 03 07 08 00 20 54 54 78 40 7f 28 44 44 38 38     ..... TTx@.(DD88
    e676:	44 44 44 28 38 44 44 28 7f 38 54 54 54 18 00 08     DDD(8DD(.8TTT...
    e686:	7e 09 02 18 a4 a4 9c 78 7f 08 04 04 78 00 44 7d     ~......x....x.D}
    e696:	40 00 20 40 40 3d 00 7f 10 28 44 00 00 41 7f 40     @. @@=...(D..A.@
    e6a6:	00 7c 04 78 04 78 7c 08 04 04 78 38 44 44 44 38     .|.x.x|...x8DDD8
    e6b6:	fc 18 24 24 18 18 24 24 18 fc 7c 08 04 04 08 48     ..$$..$$..|....H
    e6c6:	54 54 54 24 04 04 3f 44 24 3c 40 40 20 7c 1c 20     TTT$..?D$<@@ |. 
    e6d6:	40 20 1c 3c 40 30 40 3c 44 28 10 28 44 4c 90 90     @ .<@0@<D(.(DL..
    e6e6:	90 7c 44 64 54 4c 44 00 08 36 41 00 00 00 77 00     .|DdTLD..6A...w.
    e6f6:	00 00 41 36 08 00 02 01 02 04 02 3c 26 23 26 3c     ..A6.......<&#&<
    e706:	1e a1 a1 61 12 3a 40 40 20 7a 38 54 54 55 59 21     ...a.:@@ z8TTUY!
    e716:	55 55 79 41 21 54 54 78 41 21 55 54 78 40 20 54     UUyA!TTxA!UTx@ T
    e726:	55 79 40 0c 1e 52 72 12 39 55 55 55 59 39 54 54     Uy@..Rr.9UUUY9TT
    e736:	54 59 39 55 54 54 58 00 00 45 7c 41 00 02 45 7d     TY9UTTX..E|A..E}
    e746:	42 00 01 45 7c 40 f0 29 24 29 f0 f0 28 25 28 f0     B..E|@.)$)..(%(.
    e756:	7c 54 55 45 00 20 54 54 7c 54 7c 0a 09 7f 49 32     |TUE. TT|T|...I2
    e766:	49 49 49 32 32 48 48 48 32 32 4a 48 48 30 3a 41     III22HHH22JHH0:A
    e776:	41 21 7a 3a 42 40 20 78 00 9d a0 a0 7d 39 44 44     A!z:B@ x....}9DD
    e786:	44 39 3d 40 40 40 3d 3c 24 ff 24 24 48 7e 49 43     D9=@@@=<$.$$H~IC
    e796:	66 2b 2f fc 2f 2b ff 09 29 f6 20 c0 88 7e 09 03     f+/./+..). ..~..
    e7a6:	20 54 54 79 41 00 00 44 7d 41 30 48 48 4a 32 38      TTyA..D}A0HHJ28
    e7b6:	40 40 22 7a 00 7a 0a 0a 72 7d 0d 19 31 7d 26 29     @@"z.z..r}..1}&)
    e7c6:	29 2f 28 26 29 29 29 26 30 48 4d 40 20 38 08 08     )/(&)))&0HM@ 8..
    e7d6:	08 08 08 08 08 08 38 2f 10 c8 ac ba 2f 10 28 34     ......8/..../.(4
    e7e6:	fa 00 00 7b 00 00 08 14 2a 14 22 22 14 2a 14 08     ...{....*."".*..
    e7f6:	aa 00 55 00 aa aa 55 aa 55 aa 00 00 00 ff 00 10     ..U...U.U.......
    e806:	10 10 ff 00 14 14 14 ff 00 10 10 ff 00 ff 10 10     ................
    e816:	f0 10 f0 14 14 14 fc 00 14 14 f7 00 ff 00 00 ff     ................
    e826:	00 ff 14 14 f4 04 fc 14 14 17 10 1f 10 10 1f 10     ................
    e836:	1f 14 14 14 1f 00 10 10 10 f0 00 00 00 00 1f 10     ................
    e846:	10 10 10 1f 10 10 10 10 f0 10 00 00 00 ff 10 10     ................
    e856:	10 10 10 10 10 10 10 ff 10 00 00 00 ff 14 00 00     ................
    e866:	ff 00 ff 00 00 1f 10 17 00 00 fc 04 f4 14 14 17     ................
    e876:	10 17 14 14 f4 04 f4 00 00 ff 00 f7 14 14 14 14     ................
    e886:	14 14 14 f7 00 f7 14 14 14 17 14 10 10 1f 10 1f     ................
    e896:	14 14 14 f4 14 10 10 f0 10 f0 00 00 1f 10 1f 00     ................
    e8a6:	00 00 1f 14 00 00 00 fc 14 00 00 f0 10 f0 10 10     ................
    e8b6:	ff 10 ff 14 14 14 ff 14 10 10 10 1f 00 00 00 00     ................
    e8c6:	f0 10 ff ff ff ff ff f0 f0 f0 f0 f0 ff ff ff 00     ................
    e8d6:	00 00 00 00 ff ff 0f 0f 0f 0f 0f 38 44 44 38 44     ...........8DD8D
    e8e6:	7c 2a 2a 3e 14 7e 02 02 06 06 02 7e 02 7e 02 63     |**>.~.....~.~.c
    e8f6:	55 49 41 63 38 44 44 3c 04 40 7e 20 1e 20 06 02     UIAc8DD<.@~ . ..
    e906:	7e 02 02 99 a5 e7 a5 99 1c 2a 49 2a 1c 4c 72 01     ~........*I*.Lr.
    e916:	72 4c 30 4a 4d 4d 30 30 48 78 48 30 bc 62 5a 46     rL0JMM00HxH0.bZF
    e926:	3d 3e 49 49 49 00 7e 01 01 01 7e 2a 2a 2a 2a 2a     =>III.~...~*****
    e936:	44 44 5f 44 44 40 51 4a 44 40 40 44 4a 51 40 00     DD_DD@QJD@@DJQ@.
    e946:	00 ff 01 03 e0 80 ff 00 00 08 08 6b 6b 08 36 12     ...........kk.6.
    e956:	36 24 36 06 0f 09 0f 06 00 00 18 18 00 00 00 10     6$6.............
    e966:	10 00 30 40 ff 01 01 00 1f 01 01 1e 00 19 1d 17     ..0@............
    e976:	12 00 3c 3c 3c 3c 00 00 00 00 00 00                 ..<<<<......

0000e982 <printf>:
    e982:	0d 41       	mov	r1,	r13	
    e984:	2d 52       	add	#4,	r13	;r2 As==10
    e986:	1e 41 02 00 	mov	2(r1),	r14	;0x0002(r1)
    e98a:	3f 40 44 c3 	mov	#-15548,r15	;#0xc344
    e98e:	b0 12 6a eb 	call	#0xeb6a	
    e992:	30 41       	ret			

0000e994 <vprintf>:
    e994:	0d 4e       	mov	r14,	r13	
    e996:	0e 4f       	mov	r15,	r14	
    e998:	3f 40 44 c3 	mov	#-15548,r15	;#0xc344
    e99c:	b0 12 6a eb 	call	#0xeb6a	
    e9a0:	30 41       	ret			

0000e9a2 <append>:
    e9a2:	1d 42 06 02 	mov	&0x0206,r13	
    e9a6:	1d 93       	cmp	#1,	r13	;r3 As==01
    e9a8:	0b 38       	jl	$+24     	;abs 0xe9c0
    e9aa:	1e 42 04 02 	mov	&0x0204,r14	
    e9ae:	ce 4f 00 00 	mov.b	r15,	0(r14)	;0x0000(r14)
    e9b2:	1e 53       	inc	r14		
    e9b4:	82 4e 04 02 	mov	r14,	&0x0204	
    e9b8:	3d 53       	add	#-1,	r13	;r3 As==11
    e9ba:	82 4d 06 02 	mov	r13,	&0x0206	
    e9be:	30 41       	ret			
    e9c0:	3f 43       	mov	#-1,	r15	;r3 As==11
    e9c2:	30 41       	ret			

0000e9c4 <call_vuprintf>:
    e9c4:	0b 12       	push	r11		
    e9c6:	0a 12       	push	r10		
    e9c8:	21 83       	decd	r1		
    e9ca:	81 4e 00 00 	mov	r14,	0(r1)	;0x0000(r1)
    e9ce:	1a 42 04 02 	mov	&0x0204,r10	
    e9d2:	1b 42 06 02 	mov	&0x0206,r11	
    e9d6:	0d 4e       	mov	r14,	r13	
    e9d8:	0e 4f       	mov	r15,	r14	
    e9da:	3f 40 a2 e9 	mov	#-5726,	r15	;#0xe9a2
    e9de:	b0 12 6a eb 	call	#0xeb6a	
    e9e2:	0f 9b       	cmp	r11,	r15	
    e9e4:	05 38       	jl	$+12     	;abs 0xe9f0
    e9e6:	0e 4a       	mov	r10,	r14	
    e9e8:	0e 5b       	add	r11,	r14	
    e9ea:	ce 43 ff ff 	mov.b	#0,	-1(r14)	;r3 As==00, 0xffff(r14)
    e9ee:	04 3c       	jmp	$+10     	;abs 0xe9f8
    e9f0:	1e 42 04 02 	mov	&0x0204,r14	
    e9f4:	ce 43 00 00 	mov.b	#0,	0(r14)	;r3 As==00, 0x0000(r14)
    e9f8:	21 53       	incd	r1		
    e9fa:	3a 41       	pop	r10		
    e9fc:	3b 41       	pop	r11		
    e9fe:	30 41       	ret			

0000ea00 <sprintf>:
    ea00:	92 41 02 00 	mov	2(r1),	&0x0204	;0x0002(r1)
    ea04:	04 02 
    ea06:	b2 40 ff 7f 	mov	#32767,	&0x0206	;#0x7fff
    ea0a:	06 02 
    ea0c:	0e 41       	mov	r1,	r14	
    ea0e:	3e 50 06 00 	add	#6,	r14	;#0x0006
    ea12:	1f 41 04 00 	mov	4(r1),	r15	;0x0004(r1)
    ea16:	b0 12 c4 e9 	call	#0xe9c4	
    ea1a:	30 41       	ret			

0000ea1c <snprintf>:
    ea1c:	92 41 02 00 	mov	2(r1),	&0x0204	;0x0002(r1)
    ea20:	04 02 
    ea22:	92 41 04 00 	mov	4(r1),	&0x0206	;0x0004(r1)
    ea26:	06 02 
    ea28:	0e 41       	mov	r1,	r14	
    ea2a:	3e 52       	add	#8,	r14	;r2 As==11
    ea2c:	1f 41 06 00 	mov	6(r1),	r15	;0x0006(r1)
    ea30:	b0 12 c4 e9 	call	#0xe9c4	
    ea34:	30 41       	ret			

0000ea36 <vsprintf>:
    ea36:	0c 4e       	mov	r14,	r12	
    ea38:	82 4f 04 02 	mov	r15,	&0x0204	
    ea3c:	b2 40 ff 7f 	mov	#32767,	&0x0206	;#0x7fff
    ea40:	06 02 
    ea42:	0e 4d       	mov	r13,	r14	
    ea44:	0f 4c       	mov	r12,	r15	
    ea46:	b0 12 c4 e9 	call	#0xe9c4	
    ea4a:	30 41       	ret			

0000ea4c <vsnprintf>:
    ea4c:	82 4f 04 02 	mov	r15,	&0x0204	
    ea50:	82 4e 06 02 	mov	r14,	&0x0206	
    ea54:	0e 4c       	mov	r12,	r14	
    ea56:	0f 4d       	mov	r13,	r15	
    ea58:	b0 12 c4 e9 	call	#0xe9c4	
    ea5c:	30 41       	ret			

0000ea5e <print_field>:
    ea5e:	0b 12       	push	r11		
    ea60:	0a 12       	push	r10		
    ea62:	09 12       	push	r9		
    ea64:	08 12       	push	r8		
    ea66:	07 12       	push	r7		
    ea68:	06 12       	push	r6		
    ea6a:	05 12       	push	r5		
    ea6c:	04 12       	push	r4		
    ea6e:	21 83       	decd	r1		
    ea70:	0a 4f       	mov	r15,	r10	
    ea72:	08 4e       	mov	r14,	r8	
    ea74:	07 4d       	mov	r13,	r7	
    ea76:	0f 4c       	mov	r12,	r15	
    ea78:	8f 10       	swpb	r15		
    ea7a:	8f 11       	sxt	r15		
    ea7c:	4d 4c       	mov.b	r12,	r13	
    ea7e:	4e 4c       	mov.b	r12,	r14	
    ea80:	7e f0 10 00 	and.b	#16,	r14	;#0x0010
    ea84:	10 24       	jz	$+34     	;abs 0xeaa6
    ea86:	f1 40 30 00 	mov.b	#48,	0(r1)	;#0x0030, 0x0000(r1)
    ea8a:	00 00 
    ea8c:	7d f0 40 00 	and.b	#64,	r13	;#0x0040
    ea90:	03 24       	jz	$+8      	;abs 0xea98
    ea92:	7f 40 58 00 	mov.b	#88,	r15	;#0x0058
    ea96:	02 3c       	jmp	$+6      	;abs 0xea9c
    ea98:	7f 40 78 00 	mov.b	#120,	r15	;#0x0078
    ea9c:	c1 4f 01 00 	mov.b	r15,	1(r1)	;0x0001(r1)
    eaa0:	06 41       	mov	r1,	r6	
    eaa2:	26 53       	incd	r6		
    eaa4:	08 3c       	jmp	$+18     	;abs 0xeab6
    eaa6:	4f 9e       	cmp.b	r14,	r15	
    eaa8:	05 24       	jz	$+12     	;abs 0xeab4
    eaaa:	c1 4f 00 00 	mov.b	r15,	0(r1)	;0x0000(r1)
    eaae:	06 41       	mov	r1,	r6	
    eab0:	16 53       	inc	r6		
    eab2:	01 3c       	jmp	$+4      	;abs 0xeab6
    eab4:	06 41       	mov	r1,	r6	
    eab6:	06 81       	sub	r1,	r6	
    eab8:	6c b2       	bit.b	#4,	r12	;r2 As==10
    eaba:	2b 20       	jnz	$+88     	;abs 0xeb12
    eabc:	0f 48       	mov	r8,	r15	
    eabe:	3f 53       	add	#-1,	r15	;r3 As==11
    eac0:	1f 53       	inc	r15		
    eac2:	cf 93 00 00 	tst.b	0(r15)		;0x0000(r15)
    eac6:	fc 23       	jnz	$-6      	;abs 0xeac0
    eac8:	05 4f       	mov	r15,	r5	
    eaca:	05 88       	sub	r8,	r5	
    eacc:	07 96       	cmp	r6,	r7	
    eace:	02 28       	jnc	$+6      	;abs 0xead4
    ead0:	07 86       	sub	r6,	r7	
    ead2:	01 3c       	jmp	$+4      	;abs 0xead6
    ead4:	07 43       	clr	r7		
    ead6:	7c f0 20 00 	and.b	#32,	r12	;#0x0020
    eada:	0e 24       	jz	$+30     	;abs 0xeaf8
    eadc:	09 43       	clr	r9		
    eade:	06 3c       	jmp	$+14     	;abs 0xeaec
    eae0:	0f 41       	mov	r1,	r15	
    eae2:	0f 59       	add	r9,	r15	
    eae4:	6f 4f       	mov.b	@r15,	r15	
    eae6:	8f 11       	sxt	r15		
    eae8:	19 53       	inc	r9		
    eaea:	8a 12       	call	r10		
    eaec:	09 96       	cmp	r6,	r9	
    eaee:	f8 3b       	jl	$-14     	;abs 0xeae0
    eaf0:	0b 46       	mov	r6,	r11	
    eaf2:	74 40 30 00 	mov.b	#48,	r4	;#0x0030
    eaf6:	0a 3c       	jmp	$+22     	;abs 0xeb0c
    eaf8:	74 40 20 00 	mov.b	#32,	r4	;#0x0020
    eafc:	09 43       	clr	r9		
    eafe:	0b 49       	mov	r9,	r11	
    eb00:	05 3c       	jmp	$+12     	;abs 0xeb0c
    eb02:	4f 44       	mov.b	r4,	r15	
    eb04:	8f 11       	sxt	r15		
    eb06:	8a 12       	call	r10		
    eb08:	1b 53       	inc	r11		
    eb0a:	15 53       	inc	r5		
    eb0c:	05 97       	cmp	r7,	r5	
    eb0e:	f9 2b       	jnc	$-12     	;abs 0xeb02
    eb10:	02 3c       	jmp	$+6      	;abs 0xeb16
    eb12:	09 43       	clr	r9		
    eb14:	0b 49       	mov	r9,	r11	
    eb16:	09 51       	add	r1,	r9	
    eb18:	05 3c       	jmp	$+12     	;abs 0xeb24
    eb1a:	1b 53       	inc	r11		
    eb1c:	6f 49       	mov.b	@r9,	r15	
    eb1e:	8f 11       	sxt	r15		
    eb20:	8a 12       	call	r10		
    eb22:	19 53       	inc	r9		
    eb24:	0f 49       	mov	r9,	r15	
    eb26:	0f 81       	sub	r1,	r15	
    eb28:	0f 96       	cmp	r6,	r15	
    eb2a:	f7 3b       	jl	$-16     	;abs 0xeb1a
    eb2c:	05 3c       	jmp	$+12     	;abs 0xeb38
    eb2e:	6f 48       	mov.b	@r8,	r15	
    eb30:	8f 11       	sxt	r15		
    eb32:	8a 12       	call	r10		
    eb34:	18 53       	inc	r8		
    eb36:	1b 53       	inc	r11		
    eb38:	c8 93 00 00 	tst.b	0(r8)		;0x0000(r8)
    eb3c:	f8 23       	jnz	$-14     	;abs 0xeb2e
    eb3e:	04 3c       	jmp	$+10     	;abs 0xeb48
    eb40:	3f 40 20 00 	mov	#32,	r15	;#0x0020
    eb44:	8a 12       	call	r10		
    eb46:	1b 53       	inc	r11		
    eb48:	0b 97       	cmp	r7,	r11	
    eb4a:	fa 2b       	jnc	$-10     	;abs 0xeb40
    eb4c:	0f 4b       	mov	r11,	r15	
    eb4e:	21 53       	incd	r1		
    eb50:	34 41       	pop	r4		
    eb52:	35 41       	pop	r5		
    eb54:	36 41       	pop	r6		
    eb56:	37 41       	pop	r7		
    eb58:	38 41       	pop	r8		
    eb5a:	39 41       	pop	r9		
    eb5c:	3a 41       	pop	r10		
    eb5e:	3b 41       	pop	r11		
    eb60:	30 41       	ret			
    eb62:	28 6e       	addc	@r14,	r8	
    eb64:	75 6c       	addc.b	@r12+,	r5	
    eb66:	6c 29       	jnc	$+730    	;abs 0xee40
	...

0000eb6a <vuprintf>:
    eb6a:	0b 12       	push	r11		
    eb6c:	0a 12       	push	r10		
    eb6e:	09 12       	push	r9		
    eb70:	08 12       	push	r8		
    eb72:	07 12       	push	r7		
    eb74:	06 12       	push	r6		
    eb76:	05 12       	push	r5		
    eb78:	04 12       	push	r4		
    eb7a:	31 50 de ff 	add	#-34,	r1	;#0xffde
    eb7e:	81 4f 18 00 	mov	r15,	24(r1)	;0x0018(r1)
    eb82:	81 4e 1a 00 	mov	r14,	26(r1)	;0x001a(r1)
    eb86:	81 4d 0e 00 	mov	r13,	14(r1)	;0x000e(r1)
    eb8a:	81 43 10 00 	mov	#0,	16(r1)	;r3 As==00, 0x0010(r1)
    eb8e:	1a 41 10 00 	mov	16(r1),	r10	;0x0010(r1)
    eb92:	81 4a 12 00 	mov	r10,	18(r1)	;0x0012(r1)
    eb96:	30 40 ac ee 	br	#0xeeac	
    eb9a:	0a 93       	tst	r10		
    eb9c:	0b 20       	jnz	$+24     	;abs 0xebb4
    eb9e:	7e 90 25 00 	cmp.b	#37,	r14	;#0x0025
    eba2:	02 24       	jz	$+6      	;abs 0xeba8
    eba4:	30 40 96 ee 	br	#0xee96	
    eba8:	81 4a 00 00 	mov	r10,	0(r1)	;0x0000(r1)
    ebac:	81 4a 10 00 	mov	r10,	16(r1)	;0x0010(r1)
    ebb0:	30 40 a6 ee 	br	#0xeea6	
    ebb4:	7e 90 63 00 	cmp.b	#99,	r14	;#0x0063
    ebb8:	a3 24       	jz	$+328    	;abs 0xed00
    ebba:	7f 40 63 00 	mov.b	#99,	r15	;#0x0063
    ebbe:	4f 9e       	cmp.b	r14,	r15	
    ebc0:	2a 38       	jl	$+86     	;abs 0xec16
    ebc2:	7e 90 30 00 	cmp.b	#48,	r14	;#0x0030
    ebc6:	78 24       	jz	$+242    	;abs 0xecb8
    ebc8:	7f 50 cd ff 	add.b	#-51,	r15	;#0xffcd
    ebcc:	4f 9e       	cmp.b	r14,	r15	
    ebce:	19 38       	jl	$+52     	;abs 0xec02
    ebd0:	7e 90 2a 00 	cmp.b	#42,	r14	;#0x002a
    ebd4:	5b 24       	jz	$+184    	;abs 0xec8c
    ebd6:	7f 50 fa ff 	add.b	#-6,	r15	;#0xfffa
    ebda:	4f 9e       	cmp.b	r14,	r15	
    ebdc:	09 38       	jl	$+20     	;abs 0xebf0
    ebde:	7e 90 20 00 	cmp.b	#32,	r14	;#0x0020
    ebe2:	49 24       	jz	$+148    	;abs 0xec76
    ebe4:	7e 90 23 00 	cmp.b	#35,	r14	;#0x0023
    ebe8:	02 24       	jz	$+6      	;abs 0xebee
    ebea:	30 40 96 ee 	br	#0xee96	
    ebee:	32 3c       	jmp	$+102    	;abs 0xec54
    ebf0:	7e 90 2b 00 	cmp.b	#43,	r14	;#0x002b
    ebf4:	3b 24       	jz	$+120    	;abs 0xec6c
    ebf6:	7e 90 2d 00 	cmp.b	#45,	r14	;#0x002d
    ebfa:	02 24       	jz	$+6      	;abs 0xec00
    ebfc:	30 40 96 ee 	br	#0xee96	
    ec00:	31 3c       	jmp	$+100    	;abs 0xec64
    ec02:	7f 40 39 00 	mov.b	#57,	r15	;#0x0039
    ec06:	4f 9e       	cmp.b	r14,	r15	
    ec08:	6c 34       	jge	$+218    	;abs 0xece2
    ec0a:	7e 90 58 00 	cmp.b	#88,	r14	;#0x0058
    ec0e:	02 24       	jz	$+6      	;abs 0xec14
    ec10:	30 40 96 ee 	br	#0xee96	
    ec14:	a9 3c       	jmp	$+340    	;abs 0xed68
    ec16:	7e 90 70 00 	cmp.b	#112,	r14	;#0x0070
    ec1a:	8f 24       	jz	$+288    	;abs 0xed3a
    ec1c:	7f 40 70 00 	mov.b	#112,	r15	;#0x0070
    ec20:	4f 9e       	cmp.b	r14,	r15	
    ec22:	0c 38       	jl	$+26     	;abs 0xec3c
    ec24:	7e 90 69 00 	cmp.b	#105,	r14	;#0x0069
    ec28:	a3 24       	jz	$+328    	;abs 0xed70
    ec2a:	7e 90 6c 00 	cmp.b	#108,	r14	;#0x006c
    ec2e:	16 24       	jz	$+46     	;abs 0xec5c
    ec30:	7e 90 64 00 	cmp.b	#100,	r14	;#0x0064
    ec34:	02 24       	jz	$+6      	;abs 0xec3a
    ec36:	30 40 96 ee 	br	#0xee96	
    ec3a:	9a 3c       	jmp	$+310    	;abs 0xed70
    ec3c:	7e 90 75 00 	cmp.b	#117,	r14	;#0x0075
    ec40:	99 24       	jz	$+308    	;abs 0xed74
    ec42:	7e 90 78 00 	cmp.b	#120,	r14	;#0x0078
    ec46:	99 24       	jz	$+308    	;abs 0xed7a
    ec48:	7e 90 73 00 	cmp.b	#115,	r14	;#0x0073
    ec4c:	02 24       	jz	$+6      	;abs 0xec52
    ec4e:	30 40 96 ee 	br	#0xee96	
    ec52:	5d 3c       	jmp	$+188    	;abs 0xed0e
    ec54:	f1 d2 00 00 	bis.b	#8,	0(r1)	;r2 As==11, 0x0000(r1)
    ec58:	30 40 a6 ee 	br	#0xeea6	
    ec5c:	d1 d3 00 00 	bis.b	#1,	0(r1)	;r3 As==01, 0x0000(r1)
    ec60:	30 40 a6 ee 	br	#0xeea6	
    ec64:	e1 d2 00 00 	bis.b	#4,	0(r1)	;r2 As==10, 0x0000(r1)
    ec68:	30 40 a6 ee 	br	#0xeea6	
    ec6c:	f1 40 2b 00 	mov.b	#43,	1(r1)	;#0x002b, 0x0001(r1)
    ec70:	01 00 
    ec72:	30 40 a6 ee 	br	#0xeea6	
    ec76:	f1 90 2b 00 	cmp.b	#43,	1(r1)	;#0x002b, 0x0001(r1)
    ec7a:	01 00 
    ec7c:	02 20       	jnz	$+6      	;abs 0xec82
    ec7e:	30 40 a6 ee 	br	#0xeea6	
    ec82:	f1 40 20 00 	mov.b	#32,	1(r1)	;#0x0020, 0x0001(r1)
    ec86:	01 00 
    ec88:	30 40 a6 ee 	br	#0xeea6	
    ec8c:	1c 41 0e 00 	mov	14(r1),	r12	;0x000e(r1)
    ec90:	2c 53       	incd	r12		
    ec92:	1f 41 0e 00 	mov	14(r1),	r15	;0x000e(r1)
    ec96:	2e 4f       	mov	@r15,	r14	
    ec98:	0e 93       	tst	r14		
    ec9a:	03 38       	jl	$+8      	;abs 0xeca2
    ec9c:	81 4e 10 00 	mov	r14,	16(r1)	;0x0010(r1)
    eca0:	07 3c       	jmp	$+16     	;abs 0xecb0
    eca2:	e1 d2 00 00 	bis.b	#4,	0(r1)	;r2 As==10, 0x0000(r1)
    eca6:	3e e3       	inv	r14		
    eca8:	81 4e 10 00 	mov	r14,	16(r1)	;0x0010(r1)
    ecac:	91 53 10 00 	inc	16(r1)		;0x0010(r1)
    ecb0:	81 4c 0e 00 	mov	r12,	14(r1)	;0x000e(r1)
    ecb4:	30 40 a6 ee 	br	#0xeea6	
    ecb8:	81 93 10 00 	tst	16(r1)		;0x0010(r1)
    ecbc:	12 20       	jnz	$+38     	;abs 0xece2
    ecbe:	6b 41       	mov.b	@r1,	r11	
    ecc0:	6b f2       	and.b	#4,	r11	;r2 As==10
    ecc2:	5a 43       	mov.b	#1,	r10	;r3 As==01
    ecc4:	02 24       	jz	$+6      	;abs 0xecca
    ecc6:	5a 41 10 00 	mov.b	16(r1),	r10	;0x0010(r1)
    ecca:	5a f3       	and.b	#1,	r10	;r3 As==01
    eccc:	4a 5a       	rla.b	r10		
    ecce:	4a 5a       	rla.b	r10		
    ecd0:	4a 5a       	rla.b	r10		
    ecd2:	4a 5a       	rla.b	r10		
    ecd4:	4a 5a       	rla.b	r10		
    ecd6:	6b 41       	mov.b	@r1,	r11	
    ecd8:	7b f0 df ff 	and.b	#-33,	r11	;#0xffdf
    ecdc:	4b da       	bis.b	r10,	r11	
    ecde:	c1 4b 00 00 	mov.b	r11,	0(r1)	;0x0000(r1)
    ece2:	1b 41 10 00 	mov	16(r1),	r11	;0x0010(r1)
    ece6:	0b 5b       	rla	r11		
    ece8:	0b 5b       	rla	r11		
    ecea:	1b 51 10 00 	add	16(r1),	r11	;0x0010(r1)
    ecee:	0b 5b       	rla	r11		
    ecf0:	8e 11       	sxt	r14		
    ecf2:	3e 50 d0 ff 	add	#-48,	r14	;#0xffd0
    ecf6:	81 4e 10 00 	mov	r14,	16(r1)	;0x0010(r1)
    ecfa:	81 5b 10 00 	add	r11,	16(r1)	;0x0010(r1)
    ecfe:	d3 3c       	jmp	$+424    	;abs 0xeea6
    ed00:	1f 41 0e 00 	mov	14(r1),	r15	;0x000e(r1)
    ed04:	6e 4f       	mov.b	@r15,	r14	
    ed06:	2f 53       	incd	r15		
    ed08:	81 4f 0e 00 	mov	r15,	14(r1)	;0x000e(r1)
    ed0c:	c4 3c       	jmp	$+394    	;abs 0xee96
    ed0e:	1b 41 0e 00 	mov	14(r1),	r11	;0x000e(r1)
    ed12:	2b 53       	incd	r11		
    ed14:	1f 41 0e 00 	mov	14(r1),	r15	;0x000e(r1)
    ed18:	2e 4f       	mov	@r15,	r14	
    ed1a:	0e 93       	tst	r14		
    ed1c:	02 20       	jnz	$+6      	;abs 0xed22
    ed1e:	3e 40 62 eb 	mov	#-5278,	r14	;#0xeb62
    ed22:	2c 41       	mov	@r1,	r12	
    ed24:	1d 41 10 00 	mov	16(r1),	r13	;0x0010(r1)
    ed28:	1f 41 18 00 	mov	24(r1),	r15	;0x0018(r1)
    ed2c:	b0 12 5e ea 	call	#0xea5e	
    ed30:	81 5f 12 00 	add	r15,	18(r1)	;0x0012(r1)
    ed34:	81 4b 0e 00 	mov	r11,	14(r1)	;0x000e(r1)
    ed38:	b4 3c       	jmp	$+362    	;abs 0xeea2
    ed3a:	1f 41 0e 00 	mov	14(r1),	r15	;0x000e(r1)
    ed3e:	a1 4f 14 00 	mov	@r15,	20(r1)	;0x0014(r1)
    ed42:	1f 41 14 00 	mov	20(r1),	r15	;0x0014(r1)
    ed46:	8f 10       	swpb	r15		
    ed48:	8f 11       	sxt	r15		
    ed4a:	8f 10       	swpb	r15		
    ed4c:	8f 11       	sxt	r15		
    ed4e:	81 4f 16 00 	mov	r15,	22(r1)	;0x0016(r1)
    ed52:	15 41 14 00 	mov	20(r1),	r5	;0x0014(r1)
    ed56:	16 41 16 00 	mov	22(r1),	r6	;0x0016(r1)
    ed5a:	35 f3       	and	#-1,	r5	;r3 As==11
    ed5c:	06 f3       	and	#0,	r6	;r3 As==00
    ed5e:	f1 d2 00 00 	bis.b	#8,	0(r1)	;r2 As==11, 0x0000(r1)
    ed62:	a1 53 0e 00 	incd	14(r1)		;0x000e(r1)
    ed66:	30 3c       	jmp	$+98     	;abs 0xedc8
    ed68:	f1 d0 40 00 	bis.b	#64,	0(r1)	;#0x0040, 0x0000(r1)
    ed6c:	00 00 
    ed6e:	05 3c       	jmp	$+12     	;abs 0xed7a
    ed70:	e1 d3 00 00 	bis.b	#2,	0(r1)	;r3 As==10, 0x0000(r1)
    ed74:	34 40 0a 00 	mov	#10,	r4	;#0x000a
    ed78:	02 3c       	jmp	$+6      	;abs 0xed7e
    ed7a:	34 40 10 00 	mov	#16,	r4	;#0x0010
    ed7e:	6b 41       	mov.b	@r1,	r11	
    ed80:	4c 4b       	mov.b	r11,	r12	
    ed82:	5c f3       	and.b	#1,	r12	;r3 As==01
    ed84:	09 24       	jz	$+20     	;abs 0xed98
    ed86:	1f 41 0e 00 	mov	14(r1),	r15	;0x000e(r1)
    ed8a:	25 4f       	mov	@r15,	r5	
    ed8c:	16 4f 02 00 	mov	2(r15),	r6	;0x0002(r15)
    ed90:	2f 52       	add	#4,	r15	;r2 As==10
    ed92:	81 4f 0e 00 	mov	r15,	14(r1)	;0x000e(r1)
    ed96:	15 3c       	jmp	$+44     	;abs 0xedc2
    ed98:	6b f3       	and.b	#2,	r11	;r3 As==10
    ed9a:	1a 41 0e 00 	mov	14(r1),	r10	;0x000e(r1)
    ed9e:	2a 53       	incd	r10		
    eda0:	4b 9c       	cmp.b	r12,	r11	
    eda2:	09 24       	jz	$+20     	;abs 0xedb6
    eda4:	1f 41 0e 00 	mov	14(r1),	r15	;0x000e(r1)
    eda8:	25 4f       	mov	@r15,	r5	
    edaa:	06 45       	mov	r5,	r6	
    edac:	86 10       	swpb	r6		
    edae:	86 11       	sxt	r6		
    edb0:	86 10       	swpb	r6		
    edb2:	86 11       	sxt	r6		
    edb4:	04 3c       	jmp	$+10     	;abs 0xedbe
    edb6:	1f 41 0e 00 	mov	14(r1),	r15	;0x000e(r1)
    edba:	25 4f       	mov	@r15,	r5	
    edbc:	06 43       	clr	r6		
    edbe:	81 4a 0e 00 	mov	r10,	14(r1)	;0x000e(r1)
    edc2:	34 90 10 00 	cmp	#16,	r4	;#0x0010
    edc6:	0c 20       	jnz	$+26     	;abs 0xede0
    edc8:	05 93       	tst	r5		
    edca:	02 20       	jnz	$+6      	;abs 0xedd0
    edcc:	06 93       	tst	r6		
    edce:	06 24       	jz	$+14     	;abs 0xeddc
    edd0:	f1 b2 00 00 	bit.b	#8,	0(r1)	;r2 As==11, 0x0000(r1)
    edd4:	03 24       	jz	$+8      	;abs 0xeddc
    edd6:	f1 d0 10 00 	bis.b	#16,	0(r1)	;#0x0010, 0x0000(r1)
    edda:	00 00 
    eddc:	34 40 10 00 	mov	#16,	r4	;#0x0010
    ede0:	e1 b3 00 00 	bit.b	#2,	0(r1)	;r3 As==10, 0x0000(r1)
    ede4:	09 24       	jz	$+20     	;abs 0xedf8
    ede6:	06 93       	tst	r6		
    ede8:	07 34       	jge	$+16     	;abs 0xedf8
    edea:	f1 40 2d 00 	mov.b	#45,	1(r1)	;#0x002d, 0x0001(r1)
    edee:	01 00 
    edf0:	35 e3       	inv	r5		
    edf2:	36 e3       	inv	r6		
    edf4:	15 53       	inc	r5		
    edf6:	06 63       	adc	r6		
    edf8:	c1 43 0d 00 	mov.b	#0,	13(r1)	;r3 As==00, 0x000d(r1)
    edfc:	6f 41       	mov.b	@r1,	r15	
    edfe:	7f f0 40 00 	and.b	#64,	r15	;#0x0040
    ee02:	c1 4f 1e 00 	mov.b	r15,	30(r1)	;0x001e(r1)
    ee06:	07 41       	mov	r1,	r7	
    ee08:	37 50 0b 00 	add	#11,	r7	;#0x000b
    ee0c:	0f 44       	mov	r4,	r15	
    ee0e:	8f 10       	swpb	r15		
    ee10:	8f 11       	sxt	r15		
    ee12:	8f 10       	swpb	r15		
    ee14:	8f 11       	sxt	r15		
    ee16:	81 4f 1c 00 	mov	r15,	28(r1)	;0x001c(r1)
    ee1a:	0f 47       	mov	r7,	r15	
    ee1c:	1f 53       	inc	r15		
    ee1e:	81 4f 20 00 	mov	r15,	32(r1)	;0x0020(r1)
    ee22:	0c 45       	mov	r5,	r12	
    ee24:	0d 46       	mov	r6,	r13	
    ee26:	0a 44       	mov	r4,	r10	
    ee28:	1b 41 1c 00 	mov	28(r1),	r11	;0x001c(r1)
    ee2c:	b0 12 26 ef 	call	#0xef26	
    ee30:	3f 40 09 00 	mov	#9,	r15	;#0x0009
    ee34:	0f 9e       	cmp	r14,	r15	
    ee36:	05 38       	jl	$+12     	;abs 0xee42
    ee38:	7e 50 30 00 	add.b	#48,	r14	;#0x0030
    ee3c:	c7 4e 01 00 	mov.b	r14,	1(r7)	;0x0001(r7)
    ee40:	0b 3c       	jmp	$+24     	;abs 0xee58
    ee42:	c1 93 1e 00 	tst.b	30(r1)		;0x001e(r1)
    ee46:	03 24       	jz	$+8      	;abs 0xee4e
    ee48:	7f 40 37 00 	mov.b	#55,	r15	;#0x0037
    ee4c:	02 3c       	jmp	$+6      	;abs 0xee52
    ee4e:	7f 40 57 00 	mov.b	#87,	r15	;#0x0057
    ee52:	4f 5e       	add.b	r14,	r15	
    ee54:	c7 4f 01 00 	mov.b	r15,	1(r7)	;0x0001(r7)
    ee58:	0c 45       	mov	r5,	r12	
    ee5a:	0d 46       	mov	r6,	r13	
    ee5c:	0a 44       	mov	r4,	r10	
    ee5e:	1b 41 1c 00 	mov	28(r1),	r11	;0x001c(r1)
    ee62:	b0 12 26 ef 	call	#0xef26	
    ee66:	05 4c       	mov	r12,	r5	
    ee68:	06 4d       	mov	r13,	r6	
    ee6a:	37 53       	add	#-1,	r7	;r3 As==11
    ee6c:	0c 93       	tst	r12		
    ee6e:	d5 23       	jnz	$-84     	;abs 0xee1a
    ee70:	06 93       	tst	r6		
    ee72:	d3 23       	jnz	$-88     	;abs 0xee1a
    ee74:	34 90 0a 00 	cmp	#10,	r4	;#0x000a
    ee78:	02 24       	jz	$+6      	;abs 0xee7e
    ee7a:	c1 43 01 00 	mov.b	#0,	1(r1)	;r3 As==00, 0x0001(r1)
    ee7e:	2c 41       	mov	@r1,	r12	
    ee80:	1d 41 10 00 	mov	16(r1),	r13	;0x0010(r1)
    ee84:	1e 41 20 00 	mov	32(r1),	r14	;0x0020(r1)
    ee88:	1f 41 18 00 	mov	24(r1),	r15	;0x0018(r1)
    ee8c:	b0 12 5e ea 	call	#0xea5e	
    ee90:	81 5f 12 00 	add	r15,	18(r1)	;0x0012(r1)
    ee94:	06 3c       	jmp	$+14     	;abs 0xeea2
    ee96:	8e 11       	sxt	r14		
    ee98:	0f 4e       	mov	r14,	r15	
    ee9a:	91 12 1a 00 	call	26(r1)		;0x001a(r1)
    ee9e:	91 53 12 00 	inc	18(r1)		;0x0012(r1)
    eea2:	0a 43       	clr	r10		
    eea4:	01 3c       	jmp	$+4      	;abs 0xeea8
    eea6:	1a 43       	mov	#1,	r10	;r3 As==01
    eea8:	91 53 1a 00 	inc	26(r1)		;0x001a(r1)
    eeac:	1f 41 1a 00 	mov	26(r1),	r15	;0x001a(r1)
    eeb0:	6e 4f       	mov.b	@r15,	r14	
    eeb2:	4e 93       	tst.b	r14		
    eeb4:	02 24       	jz	$+6      	;abs 0xeeba
    eeb6:	30 40 9a eb 	br	#0xeb9a	
    eeba:	1f 41 12 00 	mov	18(r1),	r15	;0x0012(r1)
    eebe:	31 50 22 00 	add	#34,	r1	;#0x0022
    eec2:	34 41       	pop	r4		
    eec4:	35 41       	pop	r5		
    eec6:	36 41       	pop	r6		
    eec8:	37 41       	pop	r7		
    eeca:	38 41       	pop	r8		
    eecc:	39 41       	pop	r9		
    eece:	3a 41       	pop	r10		
    eed0:	3b 41       	pop	r11		
    eed2:	30 41       	ret			

0000eed4 <__divmodhi4>:
    eed4:	0d 43       	clr	r13		
    eed6:	3c b0 00 80 	bit	#-32768,r12	;#0x8000
    eeda:	03 28       	jnc	$+8      	;abs 0xeee2
    eedc:	3c e3       	inv	r12		
    eede:	1c 53       	inc	r12		
    eee0:	2d d2       	bis	#4,	r13	;r2 As==10
    eee2:	3a b0 00 80 	bit	#-32768,r10	;#0x8000
    eee6:	03 28       	jnc	$+8      	;abs 0xeeee
    eee8:	3a e3       	inv	r10		
    eeea:	1a 53       	inc	r10		
    eeec:	3d d2       	bis	#8,	r13	;r2 As==11
    eeee:	b0 12 0a ef 	call	#0xef0a	
    eef2:	0d 10       	rrc	r13		
    eef4:	2d b2       	bit	#4,	r13	;r2 As==10
    eef6:	04 28       	jnc	$+10     	;abs 0xef00
    eef8:	3e e3       	inv	r14		
    eefa:	1e 53       	inc	r14		
    eefc:	3c e3       	inv	r12		
    eefe:	1c 53       	inc	r12		
    ef00:	3d b2       	bit	#8,	r13	;r2 As==11
    ef02:	02 28       	jnc	$+6      	;abs 0xef08
    ef04:	3c e3       	inv	r12		
    ef06:	1c 53       	inc	r12		
    ef08:	30 41       	ret			

0000ef0a <__udivmodhi4>:
    ef0a:	0e ee       	xor	r14,	r14	
    ef0c:	3b 40 11 00 	mov	#17,	r11	;#0x0011
    ef10:	05 3c       	jmp	$+12     	;abs 0xef1c
    ef12:	0d 10       	rrc	r13		
    ef14:	0e 6e       	rlc	r14		
    ef16:	0e 9a       	cmp	r10,	r14	
    ef18:	01 28       	jnc	$+4      	;abs 0xef1c
    ef1a:	0e 8a       	sub	r10,	r14	
    ef1c:	0c 6c       	rlc	r12		
    ef1e:	0d 6d       	rlc	r13		
    ef20:	1b 83       	dec	r11		
    ef22:	f7 23       	jnz	$-16     	;abs 0xef12
    ef24:	30 41       	ret			

0000ef26 <__udivmodsi4>:
    ef26:	0f ef       	xor	r15,	r15	
    ef28:	0e ee       	xor	r14,	r14	
    ef2a:	39 40 21 00 	mov	#33,	r9	;#0x0021
    ef2e:	0a 3c       	jmp	$+22     	;abs 0xef44
    ef30:	08 10       	rrc	r8		
    ef32:	0e 6e       	rlc	r14		
    ef34:	0f 6f       	rlc	r15		
    ef36:	0f 9b       	cmp	r11,	r15	
    ef38:	05 28       	jnc	$+12     	;abs 0xef44
    ef3a:	02 20       	jnz	$+6      	;abs 0xef40
    ef3c:	0e 9a       	cmp	r10,	r14	
    ef3e:	02 28       	jnc	$+6      	;abs 0xef44
    ef40:	0e 8a       	sub	r10,	r14	
    ef42:	0f 7b       	subc	r11,	r15	
    ef44:	0c 6c       	rlc	r12		
    ef46:	0d 6d       	rlc	r13		
    ef48:	08 68       	rlc	r8		
    ef4a:	19 83       	dec	r9		
    ef4c:	f1 23       	jnz	$-28     	;abs 0xef30
    ef4e:	30 41       	ret			

0000ef50 <_unexpected_>:
    ef50:	00 13       	reti			

0000ef52 <__stop_progExec__>:
    ef52:	32 d0 f0 00 	bis	#240,	r2	;#0x00f0
    ef56:	fd 3f       	jmp	$-4      	;abs 0xef52

Disassembly of section .vectors:

0000ffe0 <__ivtbl_16>:
    ffe0:	ea c2 ea c2 54 c3 ea c2 ea c2 ea c2 ea c2 ea c2     ....T...........
    fff0:	ea c2 2c c3 ee c2 ea c2 ea c2 ea c2 ea c2 00 c0     ..,.............
