<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>CFS Stored Command Application on: CFS Stored Command Operation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="index.html">CFS Stored Command (SC) User's Guide</a>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="cfsscopr">CFS Stored Command Operation </a></h1><h2>Initialization</h2>
<p>SC can do different things on initialization depending on the type of initialization taking place and how SC is configured. SC can be configured to try to fly through a reset by uncommenting the SC_SAVE_TO_CDS configuration parameter.</p>
<h2>Power On Resets</h2>
<p>Power On resets are handled exactly like Processor resets, but there is no chance the CDS information is saved because that region of memory is cleared on a Power On reset. Power On resets will begin with a clean startup as shown below.</p>
<p>As with any file, any RTS or ATS table file that is stored on a RAM drive will not survive a Power On reset.</p>
<h2>Processor Resets</h2>
<p>If SC is configured to fly through a reset, it will try to do the following things:<br/>
</p>
<ol>
<li>
Attempt to read the SC table information that was saved in the Critical Data Store (CDS). </li>
<li>
Attempt to read the SC Application Data that was saved in the CDS. </li>
<li>
Verify that the CDS information was all properly saved before SC exited the previous time. </li>
</ol>
<p>If any of those checks fail, SC will start up clean, without using any information from the CDS. If those checks pass, SC will copy that data to it's internal structures and tables to start processing from where it left off previously. If SC detects that a table has been corrupted upon restore, the data residing in that table is not automatically cleared until the next table load is performed.</p>
<p>If SC is not configured to try to fly though a reset, it will perform a clean start up. A clean start up entails: <br/>
</p>
<ol>
<li>
Load all RTS tables located in EEPROM </li>
<li>
Initialize all internal tables and set all RTS's to disabled </li>
<li>
Enable and execute RTS #1 </li>
</ol>
<h2>Absolute Time Processor (ATP)</h2>
<p>The ATP is used to schedule spacecraft commands for an extended period of time. Under normal operations one of the ATS buffers will be loaded with all anticipated commands to operate the spacecraft for a day. While one ATS buffer is being used, the second ATS buffer can be prepared for the next day. The job of the ATP is to send out the commands in the ATS buffer in time order. Each command will be sent out to the data system when the command time tag matches the UTC Time. Because the ATS command time tag only has seconds, the resolution of each ATS command is in seconds. Commands with the same time tag are legal and will be sent to the data system in the same second. In the case where the time tags are equal, the command with the lower command number will be executed first. When it is time for an ATS command to be executed, the corresponding command status from the ATS Command Status Table is checked. If the command status is valid (i.e. LOADED) the command will be executed. If the command status indicates any status other than LOADED, the command is not executed. After the command status is checked and determined to be valid, the checksum on the ATS command is verified. If the checksum fails, the status of the command in the ATS Command Status Table will be marked as FAILED_CHECKSUM. If the checksum is valid, the command is sent out to the data system via the Software Bus. If the command is targeted for the SC (i.e. START RTS), the Software Bus will route the command back to the input pipeline for the SC. After the command has been sent to the Software Bus, the return status will be checked. If the Software Bus was able to send the command with no errors, the status will be marked as EXECUTED. If the Software Bus returns an error code, the status will be marked as FAILED_DISTRIBUTION. After a command has been sent to the Software Bus, the ATP sets up the next ATS command for processing. If the ATP detects the end of the ATS buffer, it will stop the ATS. After finding the next command (or stopping the ATS buffer) the ATP will return control to the main function of the SC.</p>
<h2>ATP Error Handling</h2>
<p>There are many error checks built in to the ATP to assure that it does not cause any ill effects on the spacecraft. The error handling within the ATP can be thought of in four different categories: ground command validation, sequence error detection, load error detection, and memory error detection.</p>
<p>Each ground command sent to the SC is first checked to see if the parameters are valid. For example, the command to execute ATS number 24 will never be accepted. After the parameter is checked, there is a logical check on each command. An example of the logical check is the Ground Switch command checking to see if the ATP is actually executing an ATS before a switch is attempted. If the ATP is idle, then it makes no sense to switch the ATS buffer. The exception to this rule is the Stop ATS ground command. This command will be executed even if there is not an ATS currently running. This feature is useful in the very unlikely case that the ATP is running an ATS but does not "think" it is actually running an ATS (i.e. processor memory becomes corrupted). The Stop ATS command simply cleans up the ATP control block regardless of the ATP status.<br/>
</p>
<p>The ATP also catches errors within ATSs. The common errors it checks for include: invalid packet IDs, and end of buffer detection (not really an error). The ATP also checks the ATS Command Status Table for each command to make sure that each command is loaded and ready to go. As mentioned in the section on ATS loads, the ATP also parses through the load to try to assure that the ATS loads are valid and not corrupted. If the ATS does not pass the load checks, it will be rejected. This check will eliminate many of the run-time errors before the ATS gets started. The ATP also does memory error checking. Before each command is sent out, the checksum in the command secondary header is recomputed and compared to the checksum stored with the command. If the checksum fails, the command is not sent out and the appropriate entry in the ATS Command Status Table is set to FAILED_CHECKSUM. Also, the command number is checked to make sure it matches the number of the next ATS command to execute.</p>
<h2>Appending to an ATS</h2>
<p>Version 2.1.0.0 of the SC application contains a capability to append commands to an existing ATS. The user loads the desired commands into the ATS Append Table using the cFE Table Services. The new commands will be added to the end of the ATS being appended. The new commands can replace existing commands in the ATS as long as those commands have not executed yet. The ATS being appended can be executing or idle. Once the data in the Append Table is loaded, validated and activated, the SC_APPENDATS command can be sent to add the contents of the Append Table to the specified ATS. When the SC_AppendATS command is processed, the SC application will copy the contents of the Append Table to the specified ATS and rebuild the pending execution list with the new commands.</p>
<h2>ATP Precaution</h2>
<p>Despite the many error checks built in to the ATP to assure that it does not cause any ill effects on the spacecraft, there is a crucial safety measure that is required of all ATS tables. The ATP relies on a sentinel word of zeroes at the end of an ATS table to signal the end of the ATS table (end of data marker). cFE Table Services, when loading a new table, unconditionally fills the table working buffer with the contents of the current table prior to placing the new table file contents into the buffer. If a newly loaded ATS table does not contain the sentinel word of zeroes at the end of the table and is smaller than the table that was previously loaded, the newly loaded table has potential to execute the "old" invalid commands that were part of the prior table load. It is therefore essential for operators to place the sentinel word of zeroes at the end of each ATS table including ATS append tables.</p>
<h2>Relative Time Processor (RTP)</h2>
<p>When the sequence is started, the RTP reads the delay of the first command. After the amount of seconds listed in the delay, the RTP will fetch the command, check the checksum of the command, and send the command out to the data system. The RTP will then fetch the next command in the sequence and determine when this command needs to execute.</p>
<p>The RTP will continue to process commands in the RTS until one of the following conditions occur: </p>
<ol>
<li>
The SCP receives a Stop RTS command from any source. </li>
<li>
The RTP detects the end of the RTS sequence (Zero value for the first word of the cFE command) or detect the end of the buffer. </li>
<li>
The RTP encounters an RTS command with an invalid CCSDS length field. Because the RTS commands are variable length, the RTP relies on the length field in each command to find the next command. If the length field is not valid, then the RTP cannot assume that it can find the next command so it must stop the sequence. </li>
<li>
The RTP encounters a command that runs past the end of the RTS buffer. </li>
<li>
The RTP processes a command with a bad checksum. </li>
</ol>
<p><b>NOTE:</b> The RTS will stop if it encounters the end of its buffer. If the last command in an RTS is a command to stop the RTS, the command will be 'sent out' to the SC. Meanwhile, the RTP will detect the end of the buffer and stop the RTS. Then the SC will process the Stop RTS command and stop an RTS that is already stopped. This is not an error, but it shows that the Stop RTS command is not needed within the buffer.</p>
<p>Each RTS can be started and run independently of the other RTSs. The only restriction is that an RTS cannot be started a second time while it is executing. When there is more than one RTS running concurrently, each RTS has a priority associated with it. The priority is assigned by the buffer number. In other words, RTS buffer 1 has the highest priority and the last RTS buffer has the lowest priority. This priority only comes into play when there is more than one RTS that has commands to be executed in the SAME SECOND. For example, if RTS 1 has a command to go out at 12:00:01 and RTS 50 has 8 commands to go out at 12:00:00, all 8 commands from RTS 50 will be executed before RTS 1 executes it's command. However, if the 8 commands from RTS 50 are scheduled to go out at 12:00:01, then the command from RTS 1 will be sent first, followed by 7 commands from RTS 50. At 12:00:02, the 8th command from RTS 50 will be sent.</p>
<h2>RTP Error Handling</h2>
<p>Like the ATP, the RTP performs many error checks. The RTP detects and handles errors in ground commands, in sequences and in memory. Each ground command sent to the RTP must pass validation checks on each of the parameters required for that command. After the parameter check, a logical check is performed to see if the command can be safely executed. For example, if a command to Start RTS 1 is sent and RTS 1 is already executing, the command is rejected because that RTS is already in use. Any command that is rejected is reported by an event message as well as in telemetry. In addition to ground command errors, the RTP detects a number of sequence errors once the RTS is running. The RTP checks for invalid packet length, invalid packet application ids, command packets that run off the end of the RTS buffer, and end of buffer detection. The RTP also checks for memory errors. When it is time for the command to be sent out to the data system, the checksum in the command secondary header is computed and compared to the checksum attached to the command. If the checksum fails, the command is discarded, the error is reported through an event message, and the RTS is stopped.</p>
<p>Next: <a class="el" href="cfsscreq.html">CFS Stored Command Requirements</a> <br/>
 Prev: <a class="el" href="cfsscovr.html">CFS Stored Command Overview</a> </p>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 17 Oct 2016 for CFS Stored Command Application on by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
