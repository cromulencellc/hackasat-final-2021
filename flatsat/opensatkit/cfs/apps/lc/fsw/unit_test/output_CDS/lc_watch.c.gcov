        -:    0:Source:../src/lc_watch.c
        -:    0:Graph:lc_watch.gcno
        -:    0:Data:lc_watch.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*************************************************************************
        -:    2:** File:
        -:    3:**   $Id: lc_watch.c.gcov 1.1 2012/07/31 16:53:49EDT nschweis Exp  $
        -:    4:**
        -:    5:** Purpose: 
        -:    6:**   Functions used for CFS Limit Checker watchpoint processing
        -:    7:**
        -:    8:**   $Log: lc_watch.c.gcov  $
        -:    8:**   Revision 1.1 2012/07/31 16:53:49EDT nschweis 
        -:    8:**   Initial revision
        -:    8:**   Member added to project c:/MKSDATA/MKS-REPOSITORY/CFS-REPOSITORY/lcx/fsw/unit_test/output_CDS/project.pj
        -:    8:**   Revision 1.1 2009/01/15 15:27:22EST dahardis 
        -:    8:**   Initial revision
        -:    8:**   Member added to project c:/MKSDATA/MKS-REPOSITORY/CFS-REPOSITORY/lc/fsw/unit_test/output_CDS/project.pj
        -:    9:**   Revision 1.2 2008/12/03 13:59:46EST dahardis 
        -:   10:**   Corrections from peer code review
        -:   11:**   Revision 1.1 2008/10/29 14:19:52EDT dahardison 
        -:   12:**   Initial revision
        -:   13:**   Member added to project c:/MKSDATA/MKS-REPOSITORY/CFS-REPOSITORY/lc/fsw/src/project.pj
        -:   14:** 
        -:   15:*************************************************************************/
        -:   16:
        -:   17:/*************************************************************************
        -:   18:** Includes
        -:   19:*************************************************************************/
        -:   20:#include "lc_app.h"
        -:   21:#include "lc_events.h"
        -:   22:#include "lc_custom.h"
        -:   23:#include "lc_perfids.h"
        -:   24:
        -:   25:/************************************************************************
        -:   26:** Local Macro Definitions
        -:   27:*************************************************************************/
        -:   28:/**
        -:   29:** \name LC Byte Order Identifiers */ 
        -:   30:/** \{ */
        -:   31:#define LC_BIG_ENDIAN       1
        -:   32:#define LC_LITTLE_ENDIAN    2
        -:   33:/** \} */
        -:   34:
        -:   35:/*************************************************************************
        -:   36:** Local Function Prototypes
        -:   37:*************************************************************************/
        -:   38:/************************************************************************/
        -:   39:/** \brief Process a single watchpoint
        -:   40:**  
        -:   41:**  \par Description
        -:   42:**       Support function for watchpoint processing that will
        -:   43:**       evaluate a single watchpoint
        -:   44:**
        -:   45:**  \par Assumptions, External Events, and Notes:
        -:   46:**       None
        -:   47:**       
        -:   48:**  \param [in]   WatchIndex  The watchpoint number to evaluate (zero
        -:   49:**                            based watchpoint definition table index)
        -:   50:**
        -:   51:**  \param [in]   MessagePtr  A #CFE_SB_MsgPtr_t pointer that
        -:   52:**                            references the software bus message that
        -:   53:**                            contains the watchpoint data
        -:   54:**
        -:   55:**  \param [in]   Timestamp   A #CFE_TIME_SysTime_t timestamp to use
        -:   56:**                            to update the watchpoint results data
        -:   57:**                            if a state transition is detected
        -:   58:**
        -:   59:*************************************************************************/
        -:   60:void LC_ProcessWP(uint16             WatchIndex, 
        -:   61:                  CFE_SB_MsgPtr_t    MessagePtr,
        -:   62:                  CFE_TIME_SysTime_t Timestamp);
        -:   63:
        -:   64:/************************************************************************/
        -:   65:/** \brief Operator comparison
        -:   66:**  
        -:   67:**  \par Description
        -:   68:**       Support function for watchpoint processing that will perform
        -:   69:**       the watchpoint data comparison based upon the operator and
        -:   70:**       data type specified in the watchpoint definition table
        -:   71:**
        -:   72:**  \par Assumptions, External Events, and Notes:
        -:   73:**       None
        -:   74:**       
        -:   75:**  \param [in] WatchIndex         The watchpoint number to compare (zero
        -:   76:**                                 based watchpoint definition table index)
        -:   77:**
        -:   78:**  \param [in] ProcessedWPData    The watchpoint data extracted from
        -:   79:**                                 the message that it was contained
        -:   80:**                                 in. This is the data after any
        -:   81:**                                 sizing, bit-masking, and endianess
        -:   82:**                                 fixing that LC might have done
        -:   83:**                                 according to the watchpoint definition
        -:   84:**
        -:   85:**  \returns
        -:   86:**  \retcode #LC_WATCH_ERROR  \retdesc \copydoc LC_WATCH_ERROR \endcode
        -:   87:**  \retstmt Return codes from #LC_SignedCompare    \endcode
        -:   88:**  \retstmt Return codes from #LC_UnsignedCompare  \endcode
        -:   89:**  \retstmt Return codes from #LC_FloatCompare     \endcode
        -:   90:**  \endreturns
        -:   91:**
        -:   92:*************************************************************************/
        -:   93:uint8 LC_OperatorCompare(uint16 WatchIndex,
        -:   94:                         uint32 ProcessedWPData);
        -:   95:
        -:   96:/************************************************************************/
        -:   97:/** \brief Signed comparison
        -:   98:**  
        -:   99:**  \par Description
        -:  100:**       Support function for watchpoint processing that will perform
        -:  101:**       a signed watchpoint data comparison based upon the operator
        -:  102:**       specified in the watchpoint definition table
        -:  103:**
        -:  104:**  \par Assumptions, External Events, and Notes:
        -:  105:**       None
        -:  106:**       
        -:  107:**  \param [in] WatchIndex    The watchpoint number to compare (zero
        -:  108:**                            based watchpoint definition table index)
        -:  109:**
        -:  110:**  \param [in] WPValue       The watchpoint data extracted from
        -:  111:**                            the message that it was contained
        -:  112:**                            in. This is the data after any
        -:  113:**                            sizing, bit-masking, and endianess
        -:  114:**                            fixing that LC might have done
        -:  115:**                            according to the watchpoint definition
        -:  116:**
        -:  117:**  \param [in] CompareValue  The comparison value specified in the 
        -:  118:**                            watchpoint definition table (sign
        -:  119:**                            extended, if needed, in an int32)
        -:  120:**
        -:  121:**  \returns
        -:  122:**  \retcode #LC_WATCH_TRUE  \retdesc \copydoc LC_WATCH_TRUE  \endcode
        -:  123:**  \retcode #LC_WATCH_FALSE \retdesc \copydoc LC_WATCH_FALSE \endcode
        -:  124:**  \retcode #LC_WATCH_ERROR \retdesc \copydoc LC_WATCH_ERROR \endcode
        -:  125:**  \endreturns
        -:  126:**
        -:  127:*************************************************************************/
        -:  128:uint8 LC_SignedCompare(uint16 WatchIndex,
        -:  129:                       int32  WPValue, 
        -:  130:                       int32  CompareValue);
        -:  131:  
        -:  132:/************************************************************************/
        -:  133:/** \brief Unsigned comparison
        -:  134:**  
        -:  135:**  \par Description
        -:  136:**       Support function for watchpoint processing that will perform
        -:  137:**       an unsigned watchpoint data comparison based upon the operator
        -:  138:**       specified in the watchpoint definition table
        -:  139:**
        -:  140:**  \par Assumptions, External Events, and Notes:
        -:  141:**       None
        -:  142:**       
        -:  143:**  \param [in] WatchIndex    The watchpoint number to compare (zero
        -:  144:**                            based watchpoint definition table index)
        -:  145:**
        -:  146:**  \param [in] WPValue       The watchpoint data extracted from
        -:  147:**                            the message that it was contained
        -:  148:**                            in. This is the data after any
        -:  149:**                            sizing, bit-masking, and endianess
        -:  150:**                            fixing that LC might have done
        -:  151:**                            according to the watchpoint definition
        -:  152:**
        -:  153:**  \param [in] CompareValue  The comparison value specified in the 
        -:  154:**                            watchpoint definition table (zero
        -:  155:**                            extended, if needed, in an uint32)
        -:  156:**
        -:  157:**  \returns
        -:  158:**  \retcode #LC_WATCH_TRUE  \retdesc \copydoc LC_WATCH_TRUE  \endcode
        -:  159:**  \retcode #LC_WATCH_FALSE \retdesc \copydoc LC_WATCH_FALSE \endcode
        -:  160:**  \retcode #LC_WATCH_ERROR \retdesc \copydoc LC_WATCH_ERROR \endcode
        -:  161:**  \endreturns
        -:  162:**
        -:  163:*************************************************************************/
        -:  164:uint8 LC_UnsignedCompare(uint16 WatchIndex,
        -:  165:                         uint32 WPValue, 
        -:  166:                         uint32 CompareValue);
        -:  167:  
        -:  168:/************************************************************************/
        -:  169:/** \brief Float comparison
        -:  170:**  
        -:  171:**  \par Description
        -:  172:**       Support function for watchpoint processing that will perform
        -:  173:**       an floating point watchpoint data comparison based upon the operator
        -:  174:**       specified in the watchpoint definition table
        -:  175:**
        -:  176:**  \par Assumptions, External Events, and Notes:
        -:  177:**       None
        -:  178:**       
        -:  179:**  \param [in] WatchIndex        The watchpoint number to compare (zero
        -:  180:**                                based watchpoint definition table index)
        -:  181:**
        -:  182:**  \param [in] WPMultiType       The watchpoint data extracted from
        -:  183:**                                the message that it was contained
        -:  184:**                                in. Stored in a multi-type union.
        -:  185:**                                This is the data after any sizing,
        -:  186:**                                bit-masking, and endianess fixing
        -:  187:**                                that LC might have done according
        -:  188:**                                to the watchpoint definition
        -:  189:**
        -:  190:**  \param [in] CompareMultiType  The comparison value specified in the 
        -:  191:**                                watchpoint definition table. Stored
        -:  192:**                                in a muti-type union so it can easily
        -:  193:**                                be accessed as a uint32 for validity
        -:  194:**                                checks
        -:  195:**
        -:  196:**  \returns
        -:  197:**  \retcode #LC_WATCH_TRUE  \retdesc \copydoc LC_WATCH_TRUE  \endcode
        -:  198:**  \retcode #LC_WATCH_FALSE \retdesc \copydoc LC_WATCH_FALSE \endcode
        -:  199:**  \retcode #LC_WATCH_ERROR \retdesc \copydoc LC_WATCH_ERROR \endcode
        -:  200:**  \endreturns
        -:  201:**
        -:  202:*************************************************************************/
        -:  203:uint8 LC_FloatCompare(uint16 WatchIndex,
        -:  204:                      LC_MultiType_t WPMultiType, 
        -:  205:                      LC_MultiType_t CompareMultiType);
        -:  206:
        -:  207:/************************************************************************/
        -:  208:/** \brief Watchpoint offset valid
        -:  209:**  
        -:  210:**  \par Description
        -:  211:**       Support function for watchpoint processing that will check if
        -:  212:**       the watchpoint offset specified in the definition table would
        -:  213:**       extend past the message that contains the watchpoint data
        -:  214:**
        -:  215:**  \par Assumptions, External Events, and Notes:
        -:  216:**       None
        -:  217:**       
        -:  218:**  \param [in]   WatchIndex  The watchpoint number to check (zero
        -:  219:**                            based watchpoint definition table index)
        -:  220:**
        -:  221:**  \param [in]   MessagePtr  A #CFE_SB_MsgPtr_t pointer that
        -:  222:**                            references the software bus message that
        -:  223:**                            contains the watchpoint data
        -:  224:**
        -:  225:**  \returns
        -:  226:**  \retstmt Returns TRUE if the offset is within the message size \endcode
        -:  227:**  \retstmt Returns FALSE if the offset extends past message end  \endcode
        -:  228:**  \endreturns
        -:  229:**
        -:  230:*************************************************************************/
        -:  231:boolean LC_WPOffsetValid(uint16          WatchIndex, 
        -:  232:                         CFE_SB_MsgPtr_t MessagePtr);
        -:  233:
        -:  234:/************************************************************************/
        -:  235:/** \brief Get sized data
        -:  236:**  
        -:  237:**  \par Description
        -:  238:**       Support function for watchpoint processing that will extract
        -:  239:**       the watchpoint data from a software bus message based upon the
        -:  240:**       data type specified in the watchpoint definition table and 
        -:  241:**       store it in a uint32. If there are any endian differences between
        -:  242:**       LC and the watchpoint data, this is where it will get fixed up.
        -:  243:**
        -:  244:**  \par Assumptions, External Events, and Notes:
        -:  245:**       None
        -:  246:**       
        -:  247:**  \param [in]  WatchIndex     The watchpoint number to extract (zero
        -:  248:**                              based watchpoint definition table index)
        -:  249:**
        -:  250:**  \param [in]  WPDataPtr      A pointer to the first byte of the 
        -:  251:**                              watchpoint data as it exists in the 
        -:  252:**                              software bus message it was received in
        -:  253:**
        -:  254:**  \param [in]  SizedDataPtr   A pointer to where the extracted watchpoint
        -:  255:*                               data should be stored
        -:  256:**
        -:  257:**  \param [out] *SizedDataPtr  Contains the extracted watchpoint data.
        -:  258:**                              This will be set to zero on error
        -:  259:**
        -:  260:**  \returns
        -:  261:**  \retstmt Returns TRUE if no error           \endcode
        -:  262:**  \retstmt Returns FALSE if an error occurred \endcode
        -:  263:**  \endreturns
        -:  264:**
        -:  265:*************************************************************************/
        -:  266:boolean LC_GetSizedWPData(uint16 WatchIndex,
        -:  267:                          uint8  *WPDataPtr,
        -:  268:                          uint32 *SizedDataPtr);
        -:  269:
        -:  270:/************************************************************************/
        -:  271:/** \brief Check uint32 for float NAN
        -:  272:**  
        -:  273:**  \par Description
        -:  274:**       Utility function for watchpoint processing that will test if
        -:  275:**       a uint32 value would result in a NAN (not-a-number) value if
        -:  276:**       it was interpreted as a float.
        -:  277:**
        -:  278:**  \par Assumptions, External Events, and Notes:
        -:  279:**       None
        -:  280:**       
        -:  281:**  \param [in]  Data     The uint32 value to check
        -:  282:**
        -:  283:**  \returns
        -:  284:**  \retstmt Returns TRUE if value is a float NAN      \endcode
        -:  285:**  \retstmt Returns FALSE if value is not a float NAN \endcode
        -:  286:**  \endreturns
        -:  287:**
        -:  288:*************************************************************************/
        -:  289:boolean LC_Uint32IsNAN(uint32 Data);
        -:  290:
        -:  291:/************************************************************************/
        -:  292:/** \brief Check uint32 for float infinite
        -:  293:**  
        -:  294:**  \par Description
        -:  295:**       Utility function for watchpoint processing that will test if
        -:  296:**       a uint32 value would result in an infinite value if
        -:  297:**       it was interpreted as a float.
        -:  298:**
        -:  299:**  \par Assumptions, External Events, and Notes:
        -:  300:**       None
        -:  301:**       
        -:  302:**  \param [in]  Data     The uint32 value to check
        -:  303:**
        -:  304:**  \returns
        -:  305:**  \retstmt Returns TRUE if value is an inifinite float      \endcode
        -:  306:**  \retstmt Returns FALSE if value is not an inifinite float \endcode
        -:  307:**  \endreturns
        -:  308:**
        -:  309:*************************************************************************/
        -:  310:boolean LC_Uint32IsInfinite(uint32 Data);
        -:  311:
        -:  312:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  313:/*                                                                 */
        -:  314:/* Handle a message with possible watchpoints                      */
        -:  315:/*                                                                 */
        -:  316:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  317:void LC_CheckMsgForWPs(CFE_SB_MsgId_t  MessageID, 
        -:  318:                       CFE_SB_MsgPtr_t MessagePtr)
function LC_CheckMsgForWPs called 33 returned 100% blocks executed 100%
       33:  319:{
       33:  320:    CFE_TIME_SysTime_t Timestamp;
       33:  321:    uint16   WatchIndex;  
       33:  322:    boolean  WPFound = FALSE;
        -:  323:    
        -:  324:    /*
        -:  325:    ** We don't do anything with possible watchpoint messages
        -:  326:    ** if we're disabled at the application level
        -:  327:    */
       33:  328:    if (LC_AppData.CurrentLCState != LC_STATE_DISABLED)
        -:  329:    {
        -:  330:        /*
        -:  331:        ** Get the message's timestamp, if there is none,
        -:  332:        ** use the current time (we need this for the results
        -:  333:        ** table).
        -:  334:        */
       32:  335:        Timestamp = CFE_SB_GetMsgTime(MessagePtr);
        -:  336:        
       32:  337:        if ((Timestamp.Seconds == 0) && (Timestamp.Subseconds == 0))
        -:  338:        {
       32:  339:            Timestamp = CFE_TIME_GetTime();
        -:  340:        }
        -:  341:        
        -:  342:        /*
        -:  343:        ** Performance Log (start time counter)
        -:  344:        */
       32:  345:        CFE_ES_PerfLogEntry(LC_WDT_SEARCH_PERF_ID);
        -:  346:        
        -:  347:        /*
        -:  348:        ** Search the watchpoint definition table for 
        -:  349:        ** matches to this message ID 
        -:  350:        */
     5664:  351:        for (WatchIndex = 0; WatchIndex < LC_MAX_WATCHPOINTS; WatchIndex++)
        -:  352:        {
     5632:  353:            if ((LC_OperData.WDTPtr[WatchIndex].DataType != LC_WATCH_NOT_USED) &&
        -:  354:                (LC_OperData.WDTPtr[WatchIndex].MessageID == MessageID))
        -:  355:            {
       31:  356:                WPFound = TRUE;
        -:  357:                
        -:  358:                /*
        -:  359:                ** Make sure the offset is okay with the recieved message
        -:  360:                ** length and continue if it is
        -:  361:                */
       31:  362:                if (LC_WPOffsetValid(WatchIndex, MessagePtr) == TRUE)
        -:  363:                {
       26:  364:                    LC_ProcessWP(WatchIndex, MessagePtr, Timestamp);
        -:  365:                }
        -:  366:            }
        -:  367:            
        -:  368:        } /* end WatchIndex for */
        -:  369:
        -:  370:        /*
        -:  371:        ** Performance Log (stop time counter)
        -:  372:        */
       32:  373:        CFE_ES_PerfLogExit(LC_WDT_SEARCH_PERF_ID);
        -:  374:        
        -:  375:        /*
        -:  376:        ** If we found one or more defined watchpoints for this message,
        -:  377:        ** bump the monitored message counter
        -:  378:        */  
       32:  379:        if (WPFound == TRUE)
        -:  380:        {
       31:  381:            LC_AppData.MonitoredMsgCount++;
        -:  382:        }
        -:  383:        else
        -:  384:        {
        -:  385:          /*
        -:  386:          ** We got a message with no defined watchpoints
        -:  387:          */
        1:  388:          CFE_EVS_SendEvent(LC_MID_INF_EID, CFE_EVS_INFORMATION,
        -:  389:                            "Msg with unreferenced message ID rcvd: ID = 0x%04X",
        -:  390:                            MessageID);
        -:  391:        }
        -:  392:        
        -:  393:    } /* end LC_STATE_DISABLED if */
        -:  394:    
       33:  395:    return;
        -:  396:   
        -:  397:} /* end LC_CheckMsgForWPs */
        -:  398:
        -:  399:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  400:/*                                                                 */
        -:  401:/* Process a single watchpoint                                     */
        -:  402:/*                                                                 */
        -:  403:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  404:void LC_ProcessWP(uint16             WatchIndex, 
        -:  405:                  CFE_SB_MsgPtr_t    MessagePtr,
        -:  406:                  CFE_TIME_SysTime_t Timestamp)
function LC_ProcessWP called 26 returned 100% blocks executed 100%
       26:  407:{
       26:  408:    uint8   *WPDataPtr;
       26:  409:    uint8   PreviousResult;
       26:  410:    uint8   WPEvalResult;
       26:  411:    uint32  SizedWPData;
       26:  412:    uint32  MaskedWPData;
       26:  413:    boolean SizedDataValid;
        -:  414:    
        -:  415:    /*
        -:  416:    ** Setup the pointer and get the massaged data
        -:  417:    */
       26:  418:    WPDataPtr = ((uint8 *)MessagePtr) + 
        -:  419:                 LC_OperData.WDTPtr[WatchIndex].WatchpointOffset;
        -:  420:    
       26:  421:    SizedDataValid = LC_GetSizedWPData(WatchIndex, 
        -:  422:                                       WPDataPtr,
        -:  423:                                       &SizedWPData);
       26:  424:    if (SizedDataValid == TRUE)
        -:  425:    {
        -:  426:        /*
        -:  427:        ** Get the last evalution result for this watchpoint
        -:  428:        */
       26:  429:        PreviousResult = LC_OperData.WRTPtr[WatchIndex].WatchResult;
        -:  430:        
        -:  431:        /*
        -:  432:        ** Apply the defined bitmask for this watchpoint and then
        -:  433:        ** call the mission defined custom function or do our own 
        -:  434:        ** relational comparison.
        -:  435:        */
       26:  436:        MaskedWPData = SizedWPData & LC_OperData.WDTPtr[WatchIndex].BitMask;
        -:  437:        
       26:  438:        if (LC_OperData.WDTPtr[WatchIndex].OperatorID == LC_OPER_CUSTOM)
        -:  439:        {
        1:  440:           WPEvalResult = LC_CustomFunction(WatchIndex,
        -:  441:                                            MaskedWPData,
        -:  442:                                            MessagePtr,
        -:  443:                                            LC_OperData.WDTPtr[WatchIndex].CustomFuncArgument);
        -:  444:        }
        -:  445:        else
        -:  446:        {
       25:  447:           WPEvalResult = LC_OperatorCompare(WatchIndex, MaskedWPData);
        -:  448:        }
        -:  449:     
        -:  450:        /*
        -:  451:        ** Update the watch result
        -:  452:        */
       26:  453:        LC_OperData.WRTPtr[WatchIndex].WatchResult = WPEvalResult;
        -:  454:        
        -:  455:        /*
        -:  456:        ** Update the watchpoint statistics based on the evaluation
        -:  457:        ** result
        -:  458:        */
       26:  459:        LC_OperData.WRTPtr[WatchIndex].EvaluationCount++;
        -:  460:        
       26:  461:        if (WPEvalResult == LC_WATCH_TRUE)
        -:  462:        {
       12:  463:            LC_OperData.WRTPtr[WatchIndex].CumulativeTrueCount++;
       12:  464:            LC_OperData.WRTPtr[WatchIndex].ConsecutiveTrueCount++;
        -:  465:            
       12:  466:            if (PreviousResult == LC_WATCH_FALSE)
        -:  467:            {
       12:  468:                LC_OperData.WRTPtr[WatchIndex].FalseToTrueCount++;
        -:  469:                
       12:  470:                LC_OperData.WRTPtr[WatchIndex].LastFalseToTrue
        -:  471:                                              .Value = MaskedWPData;
        -:  472:                
       12:  473:                LC_OperData.WRTPtr[WatchIndex].LastFalseToTrue
        -:  474:                                              .Timestamp.Seconds = Timestamp.Seconds; 
        -:  475:                
       12:  476:                LC_OperData.WRTPtr[WatchIndex].LastFalseToTrue
        -:  477:                                              .Timestamp.Subseconds = Timestamp.Subseconds; 
        -:  478:            }
        -:  479:        }
       14:  480:        else if (WPEvalResult == LC_WATCH_FALSE)
        -:  481:        {
       10:  482:            LC_OperData.WRTPtr[WatchIndex].ConsecutiveTrueCount = 0;
        -:  483:            
       10:  484:            if (PreviousResult == LC_WATCH_TRUE)
        -:  485:            {
       10:  486:                LC_OperData.WRTPtr[WatchIndex].LastTrueToFalse
        -:  487:                                              .Value = MaskedWPData;
        -:  488:                
       10:  489:                LC_OperData.WRTPtr[WatchIndex].LastTrueToFalse
        -:  490:                                              .Timestamp.Seconds = Timestamp.Seconds; 
        -:  491:                
       10:  492:                LC_OperData.WRTPtr[WatchIndex].LastTrueToFalse
        -:  493:                                              .Timestamp.Subseconds = Timestamp.Subseconds; 
        -:  494:            }
        -:  495:        }
        -:  496:        
        -:  497:    } /* end SizedDataValid if */
        -:  498:    
       26:  499:    return;
        -:  500:    
        -:  501:} /* end LC_ProcessWP */
        -:  502:
        -:  503:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  504:/*                                                                 */
        -:  505:/* Perform a watchpoint relational comparison                      */
        -:  506:/*                                                                 */
        -:  507:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  508:uint8 LC_OperatorCompare(uint16 WatchIndex,
        -:  509:                         uint32 ProcessedWPData)
function LC_OperatorCompare called 26 returned 100% blocks executed 100%
       26:  510:{
       26:  511:    uint8          EvalResult;
       26:  512:    LC_MultiType_t WatchpointValue;
       26:  513:    LC_MultiType_t ComparisonValue;
        -:  514:
       26:  515:    WatchpointValue.Unsigned32 = ProcessedWPData;
       26:  516:    ComparisonValue = LC_OperData.WDTPtr[WatchIndex].ComparisonValue;
        -:  517:
        -:  518:    /*
        -:  519:    ** Handle the comparison appropriately depending on the data type
        -:  520:    ** Any endian difference was handled when the watchpoint 
        -:  521:    ** data was extracted from the SB message
        -:  522:    */
       26:  523:    switch (LC_OperData.WDTPtr[WatchIndex].DataType)
        -:  524:    {
        -:  525:        /*
        -:  526:        ** Signed integer types will get sign extended
        -:  527:        */
        -:  528:        case LC_DATA_BYTE:
        5:  529:            EvalResult = LC_SignedCompare(WatchIndex,
        -:  530:                                          WatchpointValue.Signed8in32.Signed8,
        -:  531:                                          ComparisonValue.Signed8in32.Signed8);
        5:  532:            break;
        -:  533:              
        -:  534:        case LC_DATA_WORD_BE:
        -:  535:        case LC_DATA_WORD_LE:
        2:  536:            EvalResult = LC_SignedCompare(WatchIndex,
        -:  537:                                          WatchpointValue.Signed16in32.Signed16,
        -:  538:                                          ComparisonValue.Signed16in32.Signed16);
        2:  539:            break;
        -:  540:
        -:  541:        case LC_DATA_DWORD_BE:
        -:  542:        case LC_DATA_DWORD_LE:
        2:  543:            EvalResult = LC_SignedCompare(WatchIndex,
        -:  544:                                          WatchpointValue.Signed32,
        -:  545:                                          ComparisonValue.Signed32);
        2:  546:            break;
        -:  547:
        -:  548:        /*
        -:  549:        ** Unsigned integer types will get zero extended
        -:  550:        */
        -:  551:        case LC_DATA_UBYTE:
        5:  552:            EvalResult = LC_UnsignedCompare(WatchIndex,
        -:  553:                                            WatchpointValue.Unsigned8in32.Unsigned8,
        -:  554:                                            ComparisonValue.Unsigned8in32.Unsigned8);
        5:  555:            break;
        -:  556:
        -:  557:        case LC_DATA_UWORD_BE:
        -:  558:        case LC_DATA_UWORD_LE:
        2:  559:            EvalResult = LC_UnsignedCompare(WatchIndex,
        -:  560:                                            WatchpointValue.Unsigned16in32.Unsigned16,
        -:  561:                                            ComparisonValue.Unsigned16in32.Unsigned16);
        2:  562:            break;
        -:  563:
        -:  564:        case LC_DATA_UDWORD_BE:
        -:  565:        case LC_DATA_UDWORD_LE:
        1:  566:            EvalResult = LC_UnsignedCompare(WatchIndex,
        -:  567:                                            WatchpointValue.Unsigned32,
        -:  568:                                            ComparisonValue.Unsigned32);
        1:  569:            break;
        -:  570:
        -:  571:        /*
        -:  572:        ** Floating point values are handled separately
        -:  573:        */
        -:  574:        case LC_DATA_FLOAT_BE:
        -:  575:        case LC_DATA_FLOAT_LE:            
        8:  576:            EvalResult = LC_FloatCompare(WatchIndex,
        -:  577:                                         WatchpointValue,
        -:  578:                                         ComparisonValue);
        8:  579:            break;
        -:  580:
        -:  581:        default:
        -:  582:            /*
        -:  583:            ** This should have been caught before now, but we'll 
        -:  584:            ** handle it just in case we ever get here.
        -:  585:            */ 
        1:  586:            CFE_EVS_SendEvent(LC_WP_DATATYPE_ERR_EID, CFE_EVS_ERROR,
        -:  587:                              "WP has undefined data type: WP = %d, DataType = %d",
        -:  588:                              WatchIndex, LC_OperData.WDTPtr[WatchIndex].DataType);
        -:  589:            
        1:  590:            EvalResult = LC_WATCH_ERROR;
       26:  591:            break;
        -:  592:    }
        -:  593:    
       26:  594:    return (EvalResult);
        -:  595:    
        -:  596:} /* end LC_OperatorCompare */
        -:  597:
        -:  598:
        -:  599:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  600:/*                                                                 */
        -:  601:/* Perform a watchpoint signed integer comparison                  */
        -:  602:/*                                                                 */
        -:  603:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  604:uint8 LC_SignedCompare(uint16 WatchIndex,
        -:  605:                       int32  WPValue, 
        -:  606:                       int32  CompareValue)
function LC_SignedCompare called 9 returned 100% blocks executed 100%
        9:  607:{
        9:  608:    uint8   EvalResult;
        9:  609:    uint8   OperatorID;
        -:  610:    
        9:  611:    OperatorID      = LC_OperData.WDTPtr[WatchIndex].OperatorID;
        -:  612:    
        9:  613:    switch (OperatorID)
        -:  614:        {
        -:  615:        case LC_OPER_LE:
        1:  616:            EvalResult = (WPValue <= CompareValue) ? LC_WATCH_TRUE : LC_WATCH_FALSE;
        1:  617:            break;
        -:  618:
        -:  619:        case LC_OPER_LT:
        2:  620:            EvalResult = (WPValue <  CompareValue) ? LC_WATCH_TRUE : LC_WATCH_FALSE;
        2:  621:            break;
        -:  622:
        -:  623:        case LC_OPER_EQ:
        2:  624:            EvalResult = (WPValue == CompareValue) ? LC_WATCH_TRUE : LC_WATCH_FALSE;
        2:  625:            break;
        -:  626:
        -:  627:        case LC_OPER_NE:
        1:  628:            EvalResult = (WPValue != CompareValue) ? LC_WATCH_TRUE : LC_WATCH_FALSE;
        1:  629:            break;
        -:  630:
        -:  631:        case LC_OPER_GT:
        1:  632:            EvalResult = (WPValue >  CompareValue) ? LC_WATCH_TRUE : LC_WATCH_FALSE;
        1:  633:            break;
        -:  634:
        -:  635:        case LC_OPER_GE:
        1:  636:            EvalResult = (WPValue >= CompareValue) ? LC_WATCH_TRUE : LC_WATCH_FALSE;
        1:  637:            break;
        -:  638:
        -:  639:        default:
        -:  640:            /*
        -:  641:            ** This should have been caught before now, but we'll 
        -:  642:            ** handle it just in case we ever get here.
        -:  643:            */ 
        1:  644:            CFE_EVS_SendEvent(LC_WP_OPERID_ERR_EID, CFE_EVS_ERROR,
        -:  645:                              "WP has invalid operator ID: WP = %d, OperID = %d",
        -:  646:                              WatchIndex, OperatorID);
        -:  647:            
        1:  648:            EvalResult = LC_WATCH_ERROR;
        9:  649:            break;
        -:  650:        }
        -:  651:    
        9:  652:    return (EvalResult);
        -:  653:    
        -:  654:} /* end LC_SignedCompare */
        -:  655:
        -:  656:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  657:/*                                                                 */
        -:  658:/* Perform a watchpoint unsigned integer comparison                */
        -:  659:/*                                                                 */
        -:  660:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  661:uint8 LC_UnsignedCompare(uint16 WatchIndex,
        -:  662:                         uint32 WPValue, 
        -:  663:                         uint32 CompareValue)
function LC_UnsignedCompare called 8 returned 100% blocks executed 100%
        8:  664:{
        8:  665:    uint8   EvalResult;
        8:  666:    uint8   OperatorID;
        -:  667:    
        8:  668:    OperatorID      = LC_OperData.WDTPtr[WatchIndex].OperatorID;
        -:  669:    
        8:  670:    switch (OperatorID)
        -:  671:        {
        -:  672:        case LC_OPER_LE:
        1:  673:            EvalResult = (WPValue <= CompareValue) ? LC_WATCH_TRUE : LC_WATCH_FALSE;
        1:  674:            break;
        -:  675:
        -:  676:        case LC_OPER_LT:
        2:  677:            EvalResult = (WPValue <  CompareValue) ? LC_WATCH_TRUE : LC_WATCH_FALSE;
        2:  678:            break;
        -:  679:
        -:  680:        case LC_OPER_EQ:
        1:  681:            EvalResult = (WPValue == CompareValue) ? LC_WATCH_TRUE : LC_WATCH_FALSE;
        1:  682:            break;
        -:  683:
        -:  684:        case LC_OPER_NE:
        1:  685:            EvalResult = (WPValue != CompareValue) ? LC_WATCH_TRUE : LC_WATCH_FALSE;
        1:  686:            break;
        -:  687:
        -:  688:        case LC_OPER_GT:
        1:  689:            EvalResult = (WPValue >  CompareValue) ? LC_WATCH_TRUE : LC_WATCH_FALSE;
        1:  690:            break;
        -:  691:
        -:  692:        case LC_OPER_GE:
        1:  693:            EvalResult = (WPValue >= CompareValue) ? LC_WATCH_TRUE : LC_WATCH_FALSE;
        1:  694:            break;
        -:  695:
        -:  696:        default:
        -:  697:            /*
        -:  698:            ** This should have been caught before now, but we'll 
        -:  699:            ** handle it just in case we ever get here.
        -:  700:            */ 
        1:  701:            CFE_EVS_SendEvent(LC_WP_OPERID_ERR_EID, CFE_EVS_ERROR,
        -:  702:                              "WP has invalid operator ID: WP = %d, OperID = %d",
        -:  703:                              WatchIndex, OperatorID);
        -:  704:            
        1:  705:            EvalResult = LC_WATCH_ERROR;
        8:  706:            break;
        -:  707:        }
        -:  708:    
        8:  709:    return (EvalResult);
        -:  710:    
        -:  711:} /* end LC_UnsignedCompare */
        -:  712:
        -:  713:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  714:/*                                                                 */
        -:  715:/* Perform a floating point number comparison                      */
        -:  716:/*                                                                 */
        -:  717:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  718:uint8 LC_FloatCompare(uint16 WatchIndex,
        -:  719:                      LC_MultiType_t WPMultiType, 
        -:  720:                      LC_MultiType_t CompareMultiType)
function LC_FloatCompare called 8 returned 100% blocks executed 91%
        8:  721:{
        8:  722:    uint8   EvalResult;
        8:  723:    uint8   OperatorID;
        8:  724:    float   WPFloat;
        8:  725:    float   CompareFloat;
        8:  726:    float   Diff;
        -:  727:
        8:  728:    OperatorID      = LC_OperData.WDTPtr[WatchIndex].OperatorID;
        -:  729:   
        -:  730:    /*
        -:  731:    ** Before we do any comparison, check the watchpoint value for
        -:  732:    ** a floating point NAN (not-a-number). NAN comparisons don't
        -:  733:    ** work and can generate floating point exceptions. By contrast
        -:  734:    ** comparisons with infinite numbers will behave as they should
        -:  735:    ** so we don't try to catch those (we would rather they generate
        -:  736:    ** watchpoint violations).
        -:  737:    ** 
        -:  738:    ** The comparison (threshold) value comes from the Watchpoint
        -:  739:    ** Definition Table (WDT) and any weird values should get nailed
        -:  740:    ** during table validation.
        -:  741:    */
        8:  742:    if (LC_Uint32IsNAN(WPMultiType.Unsigned32) == FALSE)
        -:  743:    {
        7:  744:        WPFloat      = WPMultiType.Float32;
        7:  745:        CompareFloat = CompareMultiType.Float32;
        -:  746:        
        7:  747:        switch (OperatorID)
        -:  748:            {
        -:  749:            case LC_OPER_LE:
        1:  750:                EvalResult = (WPFloat <= CompareFloat) ? LC_WATCH_TRUE : LC_WATCH_FALSE;
        1:  751:                break;
        -:  752:
        -:  753:            case LC_OPER_LT:
        1:  754:                EvalResult = (WPFloat <  CompareFloat) ? LC_WATCH_TRUE : LC_WATCH_FALSE;
        1:  755:                break;
        -:  756:
        -:  757:            case LC_OPER_EQ:
        1:  758:                Diff = (WPFloat > CompareFloat) ? (WPFloat - CompareFloat) : (CompareFloat - WPFloat);
        1:  759:                EvalResult = (Diff <= (float) LC_FLOAT_TOLERANCE) ? LC_WATCH_TRUE : LC_WATCH_FALSE;
        1:  760:                break;
        -:  761:                
        -:  762:            case LC_OPER_NE:
        1:  763:                Diff = (WPFloat > CompareFloat) ? (WPFloat - CompareFloat) : (CompareFloat - WPFloat);
        1:  764:                EvalResult = (Diff > (float) LC_FLOAT_TOLERANCE) ? LC_WATCH_TRUE : LC_WATCH_FALSE;
        1:  765:                break;
        -:  766:                
        -:  767:            case LC_OPER_GT:
        1:  768:                EvalResult = (WPFloat >  CompareFloat) ? LC_WATCH_TRUE : LC_WATCH_FALSE;
        1:  769:                break;
        -:  770:
        -:  771:            case LC_OPER_GE:
        1:  772:                EvalResult = (WPFloat >= CompareFloat) ? LC_WATCH_TRUE : LC_WATCH_FALSE;
        1:  773:                break;
        -:  774:
        -:  775:            default:
        -:  776:                /*
        -:  777:                ** This should have been caught before now, but we'll 
        -:  778:                ** handle it just in case we ever get here.
        -:  779:                */ 
        1:  780:                CFE_EVS_SendEvent(LC_WP_OPERID_ERR_EID, CFE_EVS_ERROR,
        -:  781:                                  "WP has invalid operator ID: WP = %d, OperID = %d",
        -:  782:                                  WatchIndex, OperatorID);
        -:  783:                
        1:  784:                EvalResult = LC_WATCH_ERROR;
        1:  785:                break;
        -:  786:                     
        -:  787:            } /*  end of switch  */
        -:  788:        
        -:  789:    } /* end LC_WPIsNAN if */
        -:  790:    else
        -:  791:    {
        1:  792:        CFE_EVS_SendEvent(LC_WP_NAN_ERR_EID, CFE_EVS_ERROR,
        -:  793:                          "WP data value is a float NAN: WP = %d, Value = 0x%08X",
        -:  794:                          WatchIndex, WPMultiType.Unsigned32);
        -:  795:        
        1:  796:        EvalResult = LC_WATCH_ERROR;
        -:  797:    }
        -:  798:    
        8:  799:    return (EvalResult);
        -:  800:    
        -:  801:} /* end LC_FloatCompare */
        -:  802:
        -:  803:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  804:/*                                                                 */
        -:  805:/* Checks if a defined watchpoint offset will send us past the     */ 
        -:  806:/* end of the received message                                     */
        -:  807:/*                                                                 */
        -:  808:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  809:boolean LC_WPOffsetValid(uint16             WatchIndex, 
        -:  810:                         CFE_SB_MsgPtr_t    MessagePtr)
function LC_WPOffsetValid called 31 returned 100% blocks executed 100%
       31:  811:{
       31:  812:    uint16          MsgLength;
       31:  813:    uint32          Offset;
       31:  814:    uint32          NumOfDataBytes = 0;
       31:  815:    boolean         OffsetValid    = TRUE; 
       31:  816:    CFE_SB_MsgId_t  MessageID      = 0;
        -:  817:    
        -:  818:    /*
        -:  819:    ** Check the message length against the watchpoint
        -:  820:    ** offset and data type to make sure we won't
        -:  821:    ** try to read past it.
        -:  822:    */
       31:  823:    switch (LC_OperData.WDTPtr[WatchIndex].DataType)
        -:  824:        {
        -:  825:        case LC_DATA_BYTE:
        -:  826:        case LC_DATA_UBYTE:
       11:  827:            NumOfDataBytes = sizeof (uint8);
       11:  828:            break;
        -:  829:
        -:  830:        case LC_DATA_WORD_BE:
        -:  831:        case LC_DATA_WORD_LE:
        -:  832:        case LC_DATA_UWORD_BE:
        -:  833:        case LC_DATA_UWORD_LE:
        5:  834:            NumOfDataBytes = sizeof (uint16);
        5:  835:            break;
        -:  836:
        -:  837:        case LC_DATA_DWORD_BE:
        -:  838:        case LC_DATA_DWORD_LE:
        -:  839:        case LC_DATA_UDWORD_BE:
        -:  840:        case LC_DATA_UDWORD_LE:
        5:  841:            NumOfDataBytes = sizeof (uint32);
        5:  842:            break;
        -:  843:            
        -:  844:        case LC_DATA_FLOAT_BE:
        -:  845:        case LC_DATA_FLOAT_LE:
        9:  846:            NumOfDataBytes = sizeof (float);
        9:  847:            break;
        -:  848:            
        -:  849:        default:
        -:  850:            /*
        -:  851:            ** This should have been caught before now, but we'll 
        -:  852:            ** handle it just in case we ever get here.
        -:  853:            */ 
        1:  854:            CFE_EVS_SendEvent(LC_WP_DATATYPE_ERR_EID, CFE_EVS_ERROR,
        -:  855:                              "WP has undefined data type: WP = %d, DataType = %d",
        -:  856:                              WatchIndex, LC_OperData.WDTPtr[WatchIndex].DataType);
        -:  857:            
        1:  858:            LC_OperData.WRTPtr[WatchIndex].WatchResult = LC_WATCH_ERROR;
        -:  859:            
        1:  860:            return (FALSE);
        -:  861:            break;
        -:  862:            
        -:  863:        } /* end switch */     
        -:  864:    
       30:  865:    MsgLength = CFE_SB_GetTotalMsgLength(MessagePtr);
        -:  866:    
       30:  867:    Offset = LC_OperData.WDTPtr[WatchIndex].WatchpointOffset;
        -:  868:    
       30:  869:    if ((Offset + NumOfDataBytes) > MsgLength)
        -:  870:    {
        4:  871:        OffsetValid = FALSE;   
        -:  872:
        4:  873:        MessageID = CFE_SB_GetMsgId(MessagePtr);
        -:  874:        
        4:  875:        CFE_EVS_SendEvent(LC_WP_OFFSET_ERR_EID, CFE_EVS_ERROR,
        -:  876:                "WP offset error: MID = %d, WP = %d, Offset = %d, DataSize = %d, MsgLen = %d",
        -:  877:                MessageID, WatchIndex, Offset, NumOfDataBytes, MsgLength);
        -:  878:        
        4:  879:        LC_OperData.WRTPtr[WatchIndex].WatchResult = LC_WATCH_ERROR;
        -:  880:    }
        -:  881:    
       30:  882:    return (OffsetValid);
        -:  883:   
        -:  884:} /* end LC_WPOffsetValid */
        -:  885:
        -:  886:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  887:/*                                                                 */
        -:  888:/* Get sized watchpoint data                                       */
        -:  889:/*                                                                 */
        -:  890:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */   
        -:  891:boolean LC_GetSizedWPData(uint16 WatchIndex,
        -:  892:                          uint8  *WPDataPtr,
        -:  893:                          uint32 *SizedDataPtr)
function LC_GetSizedWPData called 27 returned 100% blocks executed 79%
       27:  894:{
       27:  895:    boolean Success    = TRUE;
       27:  896:    uint32  uint32Data = 0;
       27:  897:    uint16  uint16Data;
        -:  898:
       27:  899:    int32   int32Data;
       27:  900:    int16   int16Data;
       27:  901:    int8    int8Data;
        -:  902:
       27:  903:    uint8   *uint8Ptr;
       27:  904:    uint8   *RawBytePtr = WPDataPtr;
        -:  905:    
        -:  906:    /*
        -:  907:    ** Use these OSAL compiler flags to figure out what
        -:  908:    ** the target's byte order is that LC was compiled for.
        -:  909:    ** We define these this way so if neither (or both) are
        -:  910:    ** defined, we'll get a build error
        -:  911:    */
        -:  912:#ifdef _STRUCT_HIGH_BIT_FIRST_
        -:  913:    int32 OurByteOrder = LC_BIG_ENDIAN;
        -:  914:#endif    
        -:  915:
        -:  916:#ifdef _STRUCT_LOW_BIT_FIRST_
       27:  917:    int32 OurByteOrder = LC_LITTLE_ENDIAN;
        -:  918:#endif
        -:  919:
        -:  920:    /* 
        -:  921:    ** Get the watchpoint data value (which may be on a misaligned
        -:  922:    ** address boundary) and put it into an unsigned 32 properly
        -:  923:    ** handling endian and sign extension issues 
        -:  924:    */
       27:  925:    switch (LC_OperData.WDTPtr[WatchIndex].DataType)
        -:  926:        {
        -:  927:        case LC_DATA_BYTE:
        5:  928:            int8Data   =   (int8) RawBytePtr[0];
        5:  929:            int32Data  =  (int32) int8Data;
        5:  930:            uint32Data = (uint32) int32Data;
        5:  931:            break;
        -:  932:              
        -:  933:        case LC_DATA_UBYTE:
        5:  934:            uint32Data = (uint32) RawBytePtr[0];
        5:  935:            break;
        -:  936:
        -:  937:        case LC_DATA_WORD_BE:
        1:  938:            uint8Ptr    = (uint8 *) &int16Data;
        1:  939:            if (OurByteOrder == LC_BIG_ENDIAN)
        -:  940:            {
    #####:  941:                uint8Ptr[0] = RawBytePtr[0];
    #####:  942:                uint8Ptr[1] = RawBytePtr[1];
        -:  943:            }
        -:  944:            else
        -:  945:            {
        1:  946:                uint8Ptr[0] = RawBytePtr[1];
        1:  947:                uint8Ptr[1] = RawBytePtr[0];
        -:  948:            }
        1:  949:            int32Data   =  (int32) int16Data;
        1:  950:            uint32Data  = (uint32) int32Data;
        1:  951:            break;
        -:  952:
        -:  953:        case LC_DATA_WORD_LE:
        1:  954:            uint8Ptr    = (uint8 *) &int16Data;
        1:  955:            if (OurByteOrder == LC_LITTLE_ENDIAN)
        -:  956:            {
        1:  957:                uint8Ptr[0] = RawBytePtr[0];
        1:  958:                uint8Ptr[1] = RawBytePtr[1];
        -:  959:            }
        -:  960:            else
        -:  961:            {
    #####:  962:                uint8Ptr[0] = RawBytePtr[1];
    #####:  963:                uint8Ptr[1] = RawBytePtr[0];
        -:  964:            }
        1:  965:            int32Data   =  (int32) int16Data;
        1:  966:            uint32Data  = (uint32) int32Data;
        1:  967:            break;
        -:  968:
        -:  969:        case LC_DATA_UWORD_BE:
        1:  970:            uint8Ptr    = (uint8 *) &uint16Data;
        1:  971:            if (OurByteOrder == LC_BIG_ENDIAN)
        -:  972:            {
    #####:  973:                uint8Ptr[0] = RawBytePtr[0];
    #####:  974:                uint8Ptr[1] = RawBytePtr[1];
        -:  975:            }
        -:  976:            else
        -:  977:            {
        1:  978:                uint8Ptr[0] = RawBytePtr[1];
        1:  979:                uint8Ptr[1] = RawBytePtr[0];
        -:  980:            }
        1:  981:            uint32Data  = (uint32) uint16Data;
        1:  982:            break;
        -:  983:            
        -:  984:        case LC_DATA_UWORD_LE:
        1:  985:            uint8Ptr    = (uint8 *) &uint16Data;
        1:  986:            if (OurByteOrder == LC_LITTLE_ENDIAN)
        -:  987:            {
        1:  988:                uint8Ptr[0] = RawBytePtr[0];
        1:  989:                uint8Ptr[1] = RawBytePtr[1];
        -:  990:            }
        -:  991:            else
        -:  992:            {
    #####:  993:                uint8Ptr[0] = RawBytePtr[1];
    #####:  994:                uint8Ptr[1] = RawBytePtr[0];
        -:  995:            }
        1:  996:            uint32Data  = (uint32) uint16Data;
        1:  997:            break;
        -:  998:
        -:  999:        case LC_DATA_DWORD_BE:
        -: 1000:        case LC_DATA_UDWORD_BE:
        -: 1001:        case LC_DATA_FLOAT_BE:
        1: 1002:            uint8Ptr    = (uint8 *) &uint32Data;
        1: 1003:            if (OurByteOrder == LC_BIG_ENDIAN)
        -: 1004:            {
    #####: 1005:                uint8Ptr[0] = RawBytePtr[0];
    #####: 1006:                uint8Ptr[1] = RawBytePtr[1];
    #####: 1007:                uint8Ptr[2] = RawBytePtr[2];
    #####: 1008:                uint8Ptr[3] = RawBytePtr[3];
        -: 1009:            }
        -: 1010:            else
        -: 1011:            {
        1: 1012:                uint8Ptr[0] = RawBytePtr[3];
        1: 1013:                uint8Ptr[1] = RawBytePtr[2];
        1: 1014:                uint8Ptr[2] = RawBytePtr[1];
        1: 1015:                uint8Ptr[3] = RawBytePtr[0];
        -: 1016:            }
        1: 1017:            break;
        -: 1018:                
        -: 1019:        case LC_DATA_DWORD_LE:
        -: 1020:        case LC_DATA_UDWORD_LE:
        -: 1021:        case LC_DATA_FLOAT_LE:
       11: 1022:            uint8Ptr    = (uint8 *) &uint32Data;
       11: 1023:            if (OurByteOrder == LC_LITTLE_ENDIAN)
        -: 1024:            {
       11: 1025:                uint8Ptr[0] = RawBytePtr[0];
       11: 1026:                uint8Ptr[1] = RawBytePtr[1];
       11: 1027:                uint8Ptr[2] = RawBytePtr[2];
       11: 1028:                uint8Ptr[3] = RawBytePtr[3];
        -: 1029:            }
        -: 1030:            else
        -: 1031:            {
    #####: 1032:                uint8Ptr[0] = RawBytePtr[3];
    #####: 1033:                uint8Ptr[1] = RawBytePtr[2];
    #####: 1034:                uint8Ptr[2] = RawBytePtr[1];
    #####: 1035:                uint8Ptr[3] = RawBytePtr[0];
        -: 1036:            }
    #####: 1037:            break;
        -: 1038:            
        -: 1039:        default:
        -: 1040:            /*
        -: 1041:            ** This should have been caught before now, but we'll 
        -: 1042:            ** handle it just in case we ever get here.
        -: 1043:            */ 
        1: 1044:            CFE_EVS_SendEvent(LC_WP_DATATYPE_ERR_EID, CFE_EVS_ERROR,
        -: 1045:                              "WP has undefined data type: WP = %d, DataType = %d",
        -: 1046:                              WatchIndex, LC_OperData.WDTPtr[WatchIndex].DataType);
        -: 1047:            
        1: 1048:            LC_OperData.WRTPtr[WatchIndex].WatchResult = LC_WATCH_ERROR;
        -: 1049:            
        1: 1050:            Success = FALSE;
       27: 1051:            break;
        -: 1052:            
        -: 1053:        } /* end switch */     
        -: 1054:    
        -: 1055:    /*
        -: 1056:    ** Set result value
        -: 1057:    */
       27: 1058:    *SizedDataPtr = uint32Data;
        -: 1059:    
        -: 1060:    /*
        -: 1061:    ** Return success flag
        -: 1062:    */
       27: 1063:    return (Success);
        -: 1064:    
        -: 1065:} /* end LC_GetSizedWPData */
        -: 1066:
        -: 1067:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -: 1068:/*                                                                 */
        -: 1069:/* Validate the watchpoint definition table (WDT)                  */
        -: 1070:/*                                                                 */
        -: 1071:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */   
        -: 1072:int32 LC_ValidateWDT(void *TableData)
function LC_ValidateWDT called 7 returned 100% blocks executed 100%
        7: 1073:{
        7: 1074:    LC_WDTEntry_t *TableArray = (LC_WDTEntry_t *) TableData;
        -: 1075:
        7: 1076:    int32 EntryResult = LC_WDTVAL_NO_ERR;
        7: 1077:    int32 TableResult = CFE_SUCCESS;
        7: 1078:    int32 TableIndex;
        -: 1079:    
        7: 1080:    uint8  DataType;
        7: 1081:    uint8  OperatorID;
        7: 1082:    uint16 MessageID;
        7: 1083:    uint32 CompareValue;
        -: 1084:    
        7: 1085:    int32 GoodCount   = 0;
        7: 1086:    int32 BadCount    = 0;
        7: 1087:    int32 UnusedCount = 0;
        -: 1088:
        -: 1089:    /*
        -: 1090:    ** Verify each entry in the pending watchpoint definition table
        -: 1091:    */
     1239: 1092:    for (TableIndex = 0; TableIndex < LC_MAX_WATCHPOINTS; TableIndex++ )
        -: 1093:    {
     1232: 1094:        DataType     = TableArray[TableIndex].DataType;
     1232: 1095:        OperatorID   = TableArray[TableIndex].OperatorID;
     1232: 1096:        MessageID    = TableArray[TableIndex].MessageID;
     1232: 1097:        CompareValue = TableArray[TableIndex].ComparisonValue.Unsigned32;
        -: 1098:
     1232: 1099:        if (DataType == LC_WATCH_NOT_USED)
        -: 1100:        {
        -: 1101:            /*
        -: 1102:            ** Unused table entry
        -: 1103:            */
     1225: 1104:            UnusedCount++;
        -: 1105:        }
        7: 1106:        else if ((DataType != LC_DATA_BYTE)      &&
        -: 1107:                 (DataType != LC_DATA_UBYTE)     &&
        -: 1108:                 (DataType != LC_DATA_BYTE)      &&
        -: 1109:                 (DataType != LC_DATA_UBYTE)     &&
        -: 1110:                 (DataType != LC_DATA_WORD_BE)   &&
        -: 1111:                 (DataType != LC_DATA_WORD_LE)   &&
        -: 1112:                 (DataType != LC_DATA_UWORD_BE)  &&
        -: 1113:                 (DataType != LC_DATA_UWORD_LE)  &&
        -: 1114:                 (DataType != LC_DATA_DWORD_BE)  &&
        -: 1115:                 (DataType != LC_DATA_DWORD_LE)  &&
        -: 1116:                 (DataType != LC_DATA_UDWORD_BE) &&
        -: 1117:                 (DataType != LC_DATA_UDWORD_LE) &&
        -: 1118:                 (DataType != LC_DATA_FLOAT_BE)  &&
        -: 1119:                 (DataType != LC_DATA_FLOAT_LE))
        -: 1120:        {
        -: 1121:            /*
        -: 1122:            ** Invalid data type
        -: 1123:            */
        1: 1124:            BadCount++;
        1: 1125:            EntryResult = LC_WDTVAL_ERR_DATATYPE;
        -: 1126:        }
        6: 1127:        else if ((OperatorID != LC_OPER_LT)  &&
        -: 1128:                 (OperatorID != LC_OPER_LT)  &&
        -: 1129:                 (OperatorID != LC_OPER_LE)  &&
        -: 1130:                 (OperatorID != LC_OPER_NE)  &&
        -: 1131:                 (OperatorID != LC_OPER_EQ)  &&
        -: 1132:                 (OperatorID != LC_OPER_GE)  &&
        -: 1133:                 (OperatorID != LC_OPER_GT)  &&
        -: 1134:                 (OperatorID != LC_OPER_CUSTOM))
        -: 1135:        {
        -: 1136:            /*
        -: 1137:            ** Invalid operator
        -: 1138:            */
        1: 1139:            BadCount++;
        1: 1140:            EntryResult = LC_WDTVAL_ERR_OPER;
        -: 1141:        }
        5: 1142:        else if (MessageID > CFE_SB_HIGHEST_VALID_MSGID)
        -: 1143:        {
        -: 1144:            /*
        -: 1145:            ** Bad message ID (limit set by configuration parameter,
        -: 1146:            ** see cfe_platform_cfg.h)
        -: 1147:            */
        1: 1148:            BadCount++;
        1: 1149:            EntryResult = LC_WDTVAL_ERR_MID;
        -: 1150:        }
        4: 1151:        else if ((DataType == LC_DATA_FLOAT_BE) ||
        -: 1152:                 (DataType == LC_DATA_FLOAT_LE))
        -: 1153:        {
        -: 1154:            /*
        -: 1155:            ** Check the floating point comparison value for
        -: 1156:            ** NAN (not-a-number) or infinite values
        -: 1157:            */
        3: 1158:            if (LC_Uint32IsNAN(CompareValue) == TRUE)
        -: 1159:            {
        1: 1160:                BadCount++;
        1: 1161:                EntryResult = LC_WDTVAL_ERR_FPNAN;
        -: 1162:            }
        2: 1163:            else if (LC_Uint32IsInfinite(CompareValue) == TRUE)
        -: 1164:            {
        1: 1165:                BadCount++;
        1: 1166:                EntryResult = LC_WDTVAL_ERR_FPINF;
        -: 1167:            }
        -: 1168:            else
        -: 1169:            {
        -: 1170:                /*
        -: 1171:                ** We passed all checks for this floating point entry
        -: 1172:                */
        1: 1173:                GoodCount++;
        -: 1174:            }
        -: 1175:        }
        -: 1176:        else
        -: 1177:        {
        -: 1178:            /*
        -: 1179:            ** We passed all checks for this non-floating point entry
        -: 1180:            */
        1: 1181:            GoodCount++;
        -: 1182:        }
        -: 1183:        
        -: 1184:        /*
        -: 1185:        ** Generate detailed event for "first" error
        -: 1186:        */
     1232: 1187:        if ((EntryResult != LC_WDTVAL_NO_ERR) && (TableResult == CFE_SUCCESS))
        -: 1188:        {
        5: 1189:            if ((EntryResult == LC_WDTVAL_ERR_FPNAN) ||
        -: 1190:                (EntryResult == LC_WDTVAL_ERR_FPINF))
        -: 1191:            {
        2: 1192:                CFE_EVS_SendEvent(LC_WDTVAL_FPERR_EID, CFE_EVS_ERROR,
        -: 1193:                        "WDT verify float err: WP = %d, Err = %d, ComparisonValue = 0x%08X",
        -: 1194:                        TableIndex, EntryResult, CompareValue);
        -: 1195:            }
        -: 1196:            else
        -: 1197:            {
        3: 1198:                CFE_EVS_SendEvent(LC_WDTVAL_ERR_EID, CFE_EVS_ERROR,
        -: 1199:                        "WDT verify err: WP = %d, Err = %d, DType = %d, Oper = %d, MID = %d",
        -: 1200:                        TableIndex, EntryResult, DataType, OperatorID, MessageID);
        -: 1201:            }
        -: 1202:            
        5: 1203:            TableResult = EntryResult;
        -: 1204:        }
        -: 1205:        
        -: 1206:    } /* end TableIndex for */
        -: 1207:    
        -: 1208:    /*
        -: 1209:    ** Generate informational event with error totals
        -: 1210:    */
        7: 1211:    CFE_EVS_SendEvent(LC_WDTVAL_INF_EID, CFE_EVS_INFORMATION,
        -: 1212:                     "WDT verify results: good = %d, bad = %d, unused = %d",
        -: 1213:                      GoodCount, BadCount, UnusedCount);
        -: 1214:
        7: 1215:    return(TableResult);
        -: 1216:    
        -: 1217:} /* end LC_ValidateWDT */
        -: 1218:
        -: 1219:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -: 1220:/*                                                                 */
        -: 1221:/* Test if a 32 bit integer's value would be a floating point      */
        -: 1222:/* NAN (not-a-number). Assumes IEEE-754 floating point format      */
        -: 1223:/*                                                                 */
        -: 1224:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */   
        -: 1225:boolean LC_Uint32IsNAN(uint32 Data)
function LC_Uint32IsNAN called 11 returned 100% blocks executed 100%
       11: 1226:{
       11: 1227:    boolean Result = FALSE;
       11: 1228:    uint32  Exponent;
       11: 1229:    uint32  Fraction;
        -: 1230:    
        -: 1231:    /*
        -: 1232:    ** Check if the exponent field is all 1's
        -: 1233:    */
       11: 1234:    Exponent = Data & 0x7F800000;
        -: 1235:    
       11: 1236:    if (Exponent == 0x7F800000)
        -: 1237:    {
        -: 1238:        /*
        -: 1239:        ** If the fraction field is also non-zero,
        -: 1240:        ** it's a NAN
        -: 1241:        */
        3: 1242:        Fraction = Data & 0x007FFFFF;
        -: 1243:        
        3: 1244:        if (Fraction > 0)
        -: 1245:        {
        2: 1246:            Result = TRUE;
        -: 1247:        }
        -: 1248:    }
        -: 1249:    
       11: 1250:    return (Result);
        -: 1251:    
        -: 1252:} /* end LC_Uint32IsNAN */
        -: 1253:
        -: 1254:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -: 1255:/*                                                                 */
        -: 1256:/* Test if a 32 bit integer's value would be an infinite           */
        -: 1257:/* (positive or negative) floating point number. Assumes           */
        -: 1258:/* IEEE-754 floating point format                                  */
        -: 1259:/*                                                                 */
        -: 1260:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */   
        -: 1261:boolean LC_Uint32IsInfinite(uint32 Data)
function LC_Uint32IsInfinite called 2 returned 100% blocks executed 100%
        2: 1262:{
        2: 1263:    boolean Result = FALSE;
        2: 1264:    uint32  Exponent;
        2: 1265:    uint32  Fraction;
        -: 1266:    
        -: 1267:    /*
        -: 1268:    ** Check if the exponent field is all 1's
        -: 1269:    */
        2: 1270:    Exponent = Data & 0x7F800000;
        -: 1271:    
        2: 1272:    if (Exponent == 0x7F800000)
        -: 1273:    {
        -: 1274:        /*
        -: 1275:        ** If the fraction field is also zero,
        -: 1276:        ** it's infinite
        -: 1277:        */
        1: 1278:        Fraction = Data & 0x007FFFFF;
        -: 1279:        
        1: 1280:        if (Fraction == 0)
        -: 1281:        {
        1: 1282:            Result = TRUE;
        -: 1283:        }
        -: 1284:    }
        -: 1285:    
        2: 1286:    return (Result);
        -: 1287:    
        -: 1288:} /* end LC_Uint32IsInfinite */
        -: 1289:
        -: 1290:/************************/
        -: 1291:/*  End of File Comment */
        -: 1292:/************************/
