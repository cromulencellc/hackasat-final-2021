<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>CFS CFDP (CF) Application on  User&apos;s Guide: CFS CF Overview</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="index.html">index</a></div>
<h1><a class="anchor" name="cfscfovr">CFS CF Overview</a></h1>The CF application is a flight software application that is responsible for transmitting and receiving files. It is a CFS application which is designed to interface to the Core Flight Executive (cFE).<p>
CF is a highly configurable application that is designed to be used on a wide range of flight missions. CF obtains its initial configuration through a configuration table and its platform and mission configuration files. The table contains default configuration settings and is loaded during CF initialization. The platform and mission configuration files are compile-time configuration parameters.<p>
To transfer files using CFDP, the CF application must communicate with a CFDP compliant peer. CF may be configured to have any number of peers.The ASIST and ITOS ground systems contain a compliant peer that may be used for flight to ground (and ground to flight) transfers.<p>
CF sends and receives file information and file-data in Protocol Data Units (PDUs) that are compliant with the CFDP standard protocol defined in the CCSDS 727.0-B-4 Blue Book. The PDUs are transferred to and from the CF application via CCSDS packets on the software bus. The system must be configured to get the PDU packets from the peer to the software bus (and vice-versa).<p>
On a typical spacecraft using the cFE, science files and engineering files are continuously being created and queued for downlink. When transmission begins, the files are converted into a series of PDUs by CF, one after another essentially creating a continuous stream of file-data PDUs.<p>
There are special features listed in the CFDP standard that are not applicable to flight software and are therefore not supported by this version of CF. See the constraints section of this document for more information.<h2><a class="anchor" name="cfscfovrdsn">
CF Design Overview</a></h2>
CF is an event driven, single threaded application that wakes up when one of the following four messages are received on its software bus pipe. Ground command, Housekeeping Request command, Incoming PDU or the Wake-up command. The Wake-up command tells CF to do file transaction processing. This command is typically sent periodically by the scheduler. The amount of file-transaction processing that is executed when this command is received, is configurable through the table parameter engine-cycles per wake-up.<p>
For simplicity, the examples through-out this document refer to a typical operational scenario whereby the peer to the CF application is located on the ground. The CF applications knows only of incoming file transactions and outgoing file transactions. The terms uplink, downlink and playback are often used, but only apply when the peer is located on the ground. CF may be configured to have more than one peer. One peer may be located onboard the spacecraft while another is located on the ground.<h2><a class="anchor" name="cfscfovreng">
Engine</a></h2>
The CF application has a single internal core referred to as the engine. The engine is capable of transmitting and receiving a configurable number of transactions simultaneously.The engine builds outgoing Protocol Data Units (PDUs) and interprets the incoming PDUs. It handles all details regarding the CFDP standard protocol which is defined in the CCSDS 727.0-B-4 Blue Book. The engine processes the file transactions when it is 'cycled'. The number of engine cycles per wake up is a configuration parameter defined in the table. At most one PDU will be sent on a single engine cycle. Typically, the peer node also has an engine. When CF is transferring files to and from the ground, the peer is sometimes referred to as the ground engine. When faults and timeouts occur, it is important to indicate which engine detected the event.<h2><a class="anchor" name="cfscfovrstr">
Starting a Transaction</a></h2>
To transfer a file from the ground to the spacecraft, a 'put' request is given to the ground engine. There is no ground command telling CF to 'get' a file. The first indication to CF that an uplink transaction has started, is the receipt of the first PDU sent by the ground and received by CF.<p>
To transfer a file from the spacecraft to the ground, a playback file, ground command is sent to CF. This ground command translates into a 'put' request to the flight engine.<p>
The CFDP protocol does not support the concept of a 'get' request. The request to transfer a file is always made with a 'put' request at the source peer (i.e. where the file is located).<h2><a class="anchor" name="cfscfovrtrc">
Transaction Class</a></h2>
All transfers are sent and received in one of two modes, class 1 or class 2. The CF application is capable of sending and receiving in class 1 and class 2. Class 1 transfers are similar to UDP in that they send the data once and expect no feedback from the peer. Class 2 transfers are more reliable and attempt to fill in data that may have been dropped on the first attempt. Class 2 transfers are analogous to TCP.<h2><a class="anchor" name="cfscfovrqen">
Queue Entries</a></h2>
The CF application keeps track of files in queue entries. There is one queue entry per transaction. The queue entries contain information such as filename and path, priority, class, channel etc. about each transaction. For incoming file transactions, the queue entry starts on the incoming active queue and is moved to the incoming history queue when the transaction is complete. For outgoing transactions, all queue entries start out on the pending queue (in response to a playback file command for example). The queue entry is then moved to the outgoing active queue when the transaction begins and to the history queue when complete.<h2><a class="anchor" name="cfscfovrque">
Queues</a></h2>
The CF application tracks pending transactions, active transactions and completed transactions in its queues. For downlink (or outgoing) transactions there are three queues per channel, a pending queue, an active queue and a history queue. All queues hold queue entries that are described in the 'Queue Entries' section of this document. When a request to downlink a file is received, a queue entry is created and placed on the pending queue. When the transaction begins, the corresponding queue entry is moved from the pending queue to the active queue. After the transaction completes, (whether successful or not) the queue entry is moved from the active queue to the history queue. The history queue has a fixed depth, defined by the user in the CF configuration table. If a transaction is added when the history queue is full, the oldest queue entry is deleted.<p>
For uplink (or incoming) transactions there are two queues, an active queue and a history queue. Uplink transactions do not have a pending queue as with outgoing transactions. When an uplink transaction begins, a queue entry is added to the active queue. When the transaction completes, the queue entry is moved from the active queue to the history queue. The history queue depth is specified by the user in the CF configuration table. When the history queue is full and an active transaction finishes, the oldest entry on the history queue is deleted.<h2><a class="anchor" name="cfscfovrift">
Incoming File Transactions</a></h2>
When files are transferred in the uplink direction, the ground peer receives the initial request to send the file. This action causes the ground peer to send a series of PDUs that are routed to the CF application. The CF application does not get a request to receive a file. The first indication to the CF application that an uplink transaction has started, is the receipt of the first PDU of the transaction.<p>
The CF application is capable of receiving files in class 1 or class 2 mode on a per-file basis. The class mode is embedded in the PDUs received.<p>
The message ID for incoming PDUs is defined in the CF configuration table.<p>
When a file is uploaded to the spacecraft in class 2 mode, the CF app must acknowledge the receipt of the file by sending an acknowledgment PDU to the ground. This response must be sent on a specified output channel (output channels are described later). The channel number for this response is defined by the user in the configuration table.<p>
The CF application keeps a list of all incoming transactions in its internal queues. There are two queues designated for incoming transfers. The incoming active queue holds information about all incoming transactions that are currently active. The incoming history queue holds information about all incoming transactions that are complete. The full contents of either queue can be viewed on command. The depth of the history queue is defined in the table.<h2><a class="anchor" name="cfscfovroft">
Outgoing File Transactions</a></h2>
All outgoing file transactions are initiated by the CF application in response to a playback file command, a playback directory command or a file found in a polling directory. The peer entity does not request to receive a file. All outgoing file transactions are inserted into a pending queue by CF before they are actually sent. The CF application reads the pending queue (if reading is enabled) and starts the next transaction immediately after the data from the previous file has been sent. This process of queueing files and sending them sequentially, prevents the engine from being inundated when the user requests to send multiple files. Once the transactions begins, the queue entry is moved to the outgoing active queue and then to the outgoing history queue when it's complete. The engine processes the outgoing file transactions when it is 'cycled'. The number of engine cycles per wake up is defined in the table. At most one PDU will be sent on a single engine cycle.<h2><a class="anchor" name="cfscfovroc">
Output Channels</a></h2>
The CF application supports sending files to a configurable number of destinations. The output channels are configured through table parameters. Each channel has a pending queue, active queue and history queue. All queue entries for outgoing transactions start out on the pending queue, then get moved to the active queue when the transaction begins. After the transaction is complete the queue entry is moved to the history queue. The queues may be viewed by command at any time. The pending queue reads may be enabled or disabled at anytime. Each channel has a dedicated throttling semaphore, peer entity ID, message ID for outgoing PDUs and a configurable number of polling directories. File output transactions may occur simultaneously on different channels. The engine processes all active outgoing transactions in a round-robin fashion so as not to starve any one transaction. CF is not capable of prioritizing across channels.<h2><a class="anchor" name="cfscfovrqfo">
Queueing Files for Output</a></h2>
There are three ways to request a file (or files) to be sent. The file playback command, the directory playback command or through poll directory processing. The CF polling directory feature continually checks a directory for files and after detecting a new file in the directory, inserts a queue entry containing the file name (and other info) on the pending queue.<h2><a class="anchor" name="cfscfovrpri">
Priority</a></h2>
Each file-send transaction has an associated priority which is specified by the user. The priority of the transaction determines where it is inserted in the pending queue. High priority transactions get inserted toward the front of the queue. There are 256 levels of priority, zero being the highest. Priority is given as a command parameter for the playback file command and the playback directory command. For poll directory processing, each polling directory has an associated priority given as a table parameter. Please note that this priority applies only within a channel. CF does not support prioritization across channels. Prioritization across channels (if needed) would typically be implemented by the application receiving the PDUs.<h2><a class="anchor" name="cfscfovrprs">
Preserve Setting</a></h2>
When an outgoing file transaction is successfully complete, the user may want the file to be deleted by CF. The preserve setting allows the user to specify whether the file is deleted or not. The preserve setting gives two choices, delete or keep. This setting is specified as a parameter in the playback file command, the playback directory command and on each polling directory. If a file transaction is not successful, the file cannot be deleted by CF.<h2><a class="anchor" name="cfscfovrts">
Throttling Semaphore</a></h2>
Throttling outgoing PDUs may be necessary when the application that receives the outgoing PDUs (typically TO) needs to control the flow of packets. The throttling semaphore is a counting semaphore that is shared between another application and CF. Throttling may be configured as in-use or not-in-use on a per-channel basis. To configure as in-use, the receiving app must create a counting semaphore during initialization, using the name defined in the CF table. After creation, the receiving app must 'give' the semaphore each time it is ready to receive a PDU. On the CF side, CF attempts to get the semaphore ID by calling an OSAL function to Get-SemaphoreID-by-Name during CF initialization. The name defined in the table is given as a parameter to this call. CF has code to ensure that this call is executed after the receiving app initializes. If the attempt to Get-SemaphoreID-by-Name fails, then throttling on that channel is not-in-use and PDUs are sent whenever the engine has a PDU ready to output. If successful, each time the engine has a PDU to output, CF will attempt a non-blocking 'take' on the throttling semaphore. If the 'take' is successful, the green light counter in telemetry is incremented and the PDU is sent on the software bus. If the 'take' is not successful, the PDU is held by the engine, the red-light counter is incremented and the 'take' is called again on the next engine cycle.<h2><a class="anchor" name="cfscfovrpd">
Polling Directories</a></h2>
A polling directory is a directory that is polled by CF periodically. CF does not create these directories. They must be created before they can be enabled. When files are found in a polling directory that is enabled, the files are automatically queued by CF for output. The polling rate is configurable and each channel has a configurable number of polling directories. Each polling directory has an enable, a class setting, a priority setting, a preserve setting and a destination directory. When enabled, CF will periodically check the polling directories for files. When a file is found, CF will place the file information on the pending queue if it is closed and not already on the queue and not currently active. All polling directories are checked at the same frequency which is defined by the table parameter NumWakeupsPerPollDirChk. Setting this parameter to one will cause CF to check the polling directories at the fastest possible rate, every time it receives a 'wake-up' command. Checking polling directories is a processor-intensive effort, it is best to keep the polling rate as low as possible.<h2><a class="anchor" name="cfscfovreff">
Efficiency</a></h2>
The CF application can be a processor intensive application. Some operating systems have significant overhead associated with file system operations. Opening and closing a file, querying the file system for file size, deleting the file, opening directories, looping through a directory list can consume a considerable amount of processor time. For this reason, transmitting small files at a high rate for long periods of time may be a worst-case-timing scenario. File system overhead is less of an issue when file sizes are large. The terms 'large' and 'small' used here are relative to the downlink rate. With a downlink rate of 1 Mbps for example, a good file size would be 1 MByte or larger.<p>
Also, it is best to keep the number of files on the pending queue to a minimum. When the number of files on the pending queue is high, (such as hundreds) prioritization and standard checking causes CF processing to be significant each time a file is added to the queue.<p>
Polling directory processing is also subject to file system overhead. It is recommended that the rate of poll processing be kept low and unused polling directories should be disabled.<h2><a class="anchor" name="CF">
cfscfovrmu Memory-Use</a></h2>
CF uses the CFE ES memory pool to manage a statically allocated heap of the size defined by the CF_MEMORY_POOL_BYTES configuration parameter. This heap is used to hold memory for queue entries. The life cycle of a queue entry begins when a request to queue a file for downlink is received. Or in the case of incoming transactions, the queue entry is allocated when the meta-data PDU is received by CF. For the incoming transaction case, the queue entry starts out on the incoming active queue, then the entry is moved to the history queue when the transaction completes. For outgoing transactions, the queue entry starts out on the pending queue, then moves to the active queue when the transaction begins, then moves to the history queue when the transaction is complete.<p>
The history queue has a sliding window affect. When the queue is full and a new transaction needs to be added, the oldest transaction will be removed, making room for the new transaction.<p>
The history queue depth is a configuration parameter and specified in the CF configuration table. When the queue entry is 'pushed-off' the history queue, the memory for the queue will be returned to the heap.<p>
For incoming-file-transactions, CF statically allocates an incoming pdu buffer. The size of this buffer is defined by the platform configuration parameter, CF_INCOMING_PDU_BUF_SIZE. The incoming PDU's are copied from the Software Bus into this buffer and then passed to the engine.<p>
For outgoing-file-transactions, the engine statically allocates a buffer for PDUs. The size of this buffer is defined by platform configuration parameter, CF_OUTGOING_PDU_BUF_SIZE. The engine informs the CF app when it has a PDU ready to go out. In response to this, the CF app checks with the downlink app (e.g. TO) to see if it is ready to receive a PDU. This is done by the CF app trying to 'take' the throttling semaphore defined in the CF configuration table. If the CF app successfully 'takes' the semaphore, it gives a green light to the engine and the PDU is then released by the engine and sent to the software bus via the zero-copy delivery mode. There is a green light counter and a red light counter for each output channel in telemetry.<p>
Prev: <a class="el" href="cfscfintro.html">CFS CF Introduction</a> <br>
 Next: <a class="el" href="cfscfopr.html">CFS CF Operation</a> <hr size="1"><address style="align: right;"><small>Generated on Fri Mar 6 15:45:28 2015 for CFS CFDP (CF) Application on  User's Guide by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
