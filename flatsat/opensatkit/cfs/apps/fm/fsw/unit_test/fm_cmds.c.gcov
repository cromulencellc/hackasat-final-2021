        -:    0:Source:../src/fm_cmds.c
        -:    0:Programs:5
        -:    1:/*
        -:    2:** $Id: fm_cmds.c.gcov 1.2.1.1 2017/01/25 00:20:21EST mdeschu Exp  $
        -:    3:**
        -:    4:**  Copyright (c) 2007-2014 United States Government as represented by the 
        -:    5:**  Administrator of the National Aeronautics and Space Administration. 
        -:    6:**  All Other Rights Reserved.  
        -:    7:**
        -:    8:**  This software was created at NASA's Goddard Space Flight Center.
        -:    9:**  This software is governed by the NASA Open Source Agreement and may be 
        -:   10:**  used, distributed and modified only pursuant to the terms of that 
        -:   11:**  agreement.
        -:   12:**
        -:   13:** Title: File Manager (FM) Application Ground Commands
        -:   14:**
        -:   15:** Purpose: Provides functions for the execution of the FM ground commands
        -:   16:**
        -:   17:** Author: Susanne L. Strege, Code 582 NASA GSFC
        -:   18:**
        -:   19:** Notes:
        -:   20:**
        -:   21:*/
        -:   22:
        -:   23:#include "cfe.h"
        -:   24:#include "fm_msg.h"
        -:   25:#include "fm_msgdefs.h"
        -:   26:#include "fm_msgids.h"
        -:   27:#include "fm_events.h"
        -:   28:#include "fm_app.h"
        -:   29:#include "fm_cmds.h"
        -:   30:#include "fm_cmd_utils.h"
        -:   31:#include "fm_perfids.h"
        -:   32:#include "fm_platform_cfg.h"
        -:   33:#include "fm_version.h"
        -:   34:#include "fm_verify.h"
        -:   35:
        -:   36:#include <string.h>
        -:   37:
        -:   38:
        -:   39:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:   40:/*                                                                 */
        -:   41:/* FM command handler -- NOOP                                      */
        -:   42:/*                                                                 */
        -:   43:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:   44:
        3:   45:boolean FM_NoopCmd(CFE_SB_MsgPtr_t MessagePtr)
        -:   46:{
        3:   47:    char *CmdText = "No-op";
        -:   48:    boolean CommandResult;
        -:   49:
        -:   50:    /* Verify message length */
        3:   51:    CommandResult = FM_IsValidCmdPktLength(MessagePtr, sizeof(FM_NoopCmd_t),
        -:   52:                                           FM_NOOP_PKT_ERR_EID, CmdText);
        -:   53:
        -:   54:    /* Send command completion event (info) */
        3:   55:    if (CommandResult == TRUE)
        -:   56:    {
        3:   57:        CFE_EVS_SendEvent(FM_NOOP_CMD_EID, CFE_EVS_INFORMATION,
        -:   58:                         "%s command: FM version %d.%d.%d.%d", CmdText,
        -:   59:                          FM_MAJOR_VERSION, FM_MINOR_VERSION, FM_REVISION, FM_MISSION_REV);
        -:   60:    }
        -:   61:
        3:   62:    return(CommandResult);
        -:   63:
        -:   64:} /* End of FM_NoopCmd() */
        -:   65:
        -:   66:
        -:   67:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:   68:/*                                                                 */
        -:   69:/* FM command handler -- Reset Counters                            */
        -:   70:/*                                                                 */
        -:   71:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:   72:
        2:   73:boolean FM_ResetCountersCmd(CFE_SB_MsgPtr_t MessagePtr)
        -:   74:{
        2:   75:    char *CmdText = "Reset Counters";
        -:   76:    boolean CommandResult;
        -:   77:
        -:   78:    /* Verify message length */
        2:   79:    CommandResult = FM_IsValidCmdPktLength(MessagePtr, sizeof(FM_ResetCmd_t),
        -:   80:                                           FM_RESET_PKT_ERR_EID, CmdText);
        -:   81:
        -:   82:    /* Reset command counters */
        2:   83:    if (CommandResult == TRUE)
        -:   84:    {
        2:   85:        FM_GlobalData.CommandCounter = 0;
        2:   86:        FM_GlobalData.CommandErrCounter = 0;
        -:   87:
        2:   88:        FM_GlobalData.ChildCmdCounter = 0;
        2:   89:        FM_GlobalData.ChildCmdErrCounter = 0;
        2:   90:        FM_GlobalData.ChildCmdWarnCounter = 0;
        -:   91:
        -:   92:        /* Send command completion event (debug) */
        2:   93:        CFE_EVS_SendEvent(FM_RESET_CMD_EID, CFE_EVS_DEBUG, "%s command", CmdText);
        -:   94:    }
        -:   95:
        2:   96:    return(CommandResult);
        -:   97:
        -:   98:} /* End of FM_ResetCountersCmd() */
        -:   99:
        -:  100:
        -:  101:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  102:/*                                                                 */
        -:  103:/* FM command handler -- Copy File                                 */
        -:  104:/*                                                                 */
        -:  105:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  106:
        3:  107:boolean FM_CopyFileCmd(CFE_SB_MsgPtr_t MessagePtr)
        -:  108:{
        3:  109:    FM_CopyFileCmd_t *CmdPtr = (FM_CopyFileCmd_t *) MessagePtr;
        -:  110:    FM_ChildQueueEntry_t *CmdArgs;
        3:  111:    char *CmdText = "Copy File";
        -:  112:    boolean CommandResult;
        -:  113:
        -:  114:    /* Verify command packet length */
        3:  115:    CommandResult = FM_IsValidCmdPktLength(MessagePtr, sizeof(FM_CopyFileCmd_t),
        -:  116:                                           FM_COPY_PKT_ERR_EID, CmdText);
        -:  117:
        -:  118:    /* Verify that overwrite argument is valid */
        3:  119:    if (CommandResult == TRUE)
        -:  120:    {
        3:  121:        CommandResult = FM_VerifyOverwrite(CmdPtr->Overwrite,
        -:  122:                                           FM_COPY_OVR_ERR_EID, CmdText);
        -:  123:    }
        -:  124:
        -:  125:    /* Verify that source file exists and is not a directory */
        3:  126:    if (CommandResult == TRUE)
        -:  127:    {
        3:  128:        CommandResult = FM_VerifyFileExists(CmdPtr->Source, sizeof(CmdPtr->Source),
        -:  129:                                            FM_COPY_SRC_ERR_EID, CmdText);
        -:  130:    }
        -:  131:
        -:  132:    /* Verify target filename per the overwrite argument */
        3:  133:    if (CommandResult == TRUE)
        -:  134:    {
        2:  135:        if (CmdPtr->Overwrite == 0)
        -:  136:        {
        1:  137:            CommandResult = FM_VerifyFileNoExist(CmdPtr->Target, sizeof(CmdPtr->Target),
        -:  138:                                                 FM_COPY_TGT_ERR_EID, CmdText);
        -:  139:        }
        -:  140:        else
        -:  141:        {
        1:  142:            CommandResult = FM_VerifyFileNotOpen(CmdPtr->Target, sizeof(CmdPtr->Target),
        -:  143:                                                 FM_COPY_TGT_ERR_EID, CmdText);
        -:  144:        }
        -:  145:    }
        -:  146:
        -:  147:    /* Check for lower priority child task availability */
        3:  148:    if (CommandResult == TRUE)
        -:  149:    {
        2:  150:        CommandResult = FM_VerifyChildTask(FM_COPY_CHILD_ERR_EID, CmdText);
        -:  151:    }
        -:  152:
        -:  153:    /* Prepare command for child task execution */
        3:  154:    if (CommandResult == TRUE)
        -:  155:    {
        2:  156:        CmdArgs = &FM_GlobalData.ChildQueue[FM_GlobalData.ChildWriteIndex];
        -:  157:
        -:  158:        /* Set handshake queue command args */
        2:  159:        CmdArgs->CommandCode = FM_COPY_CC;
        2:  160:        strcpy(CmdArgs->Source1, CmdPtr->Source);
        2:  161:        strcpy(CmdArgs->Target,  CmdPtr->Target);
        -:  162:
        -:  163:        /* Invoke lower priority child task */
        2:  164:        FM_InvokeChildTask();
        -:  165:    }
        -:  166:
        3:  167:    return(CommandResult);
        -:  168:
        -:  169:} /* End of FM_CopyFileCmd() */
        -:  170:
        -:  171:
        -:  172:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  173:/*                                                                 */
        -:  174:/* FM command handler -- Move File                                 */
        -:  175:/*                                                                 */
        -:  176:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  177:
        3:  178:boolean FM_MoveFileCmd(CFE_SB_MsgPtr_t MessagePtr)
        -:  179:{
        3:  180:    FM_MoveFileCmd_t  *CmdPtr = (FM_MoveFileCmd_t *) MessagePtr;
        -:  181:    FM_ChildQueueEntry_t *CmdArgs;
        3:  182:    char *CmdText = "Move File";
        -:  183:    boolean CommandResult;
        -:  184:
        -:  185:    /* Verify command packet length */
        3:  186:    CommandResult = FM_IsValidCmdPktLength(MessagePtr, sizeof(FM_MoveFileCmd_t),
        -:  187:                                           FM_MOVE_PKT_ERR_EID, CmdText);
        -:  188:
        -:  189:    /* Verify that overwrite argument is valid */
        3:  190:    if (CommandResult == TRUE)
        -:  191:    {
        3:  192:        CommandResult = FM_VerifyOverwrite(CmdPtr->Overwrite,
        -:  193:                                           FM_MOVE_OVR_ERR_EID, CmdText);
        -:  194:    }
        -:  195:
        -:  196:    /* Verify that source file exists and not a directory */
        3:  197:    if (CommandResult == TRUE)
        -:  198:    {
        3:  199:        CommandResult = FM_VerifyFileExists(CmdPtr->Source, sizeof(CmdPtr->Source),
        -:  200:                                            FM_MOVE_SRC_ERR_EID, CmdText);
        -:  201:    }
        -:  202:
        -:  203:    /* Verify target filename per the overwrite argument */
        3:  204:    if (CommandResult == TRUE)
        -:  205:    {
        2:  206:        if (CmdPtr->Overwrite == 0)
        -:  207:        {
        1:  208:            CommandResult = FM_VerifyFileNoExist(CmdPtr->Target, sizeof(CmdPtr->Target),
        -:  209:                                                 FM_MOVE_TGT_ERR_EID, CmdText);
        -:  210:        }
        -:  211:        else
        -:  212:        {
        1:  213:            CommandResult = FM_VerifyFileNotOpen(CmdPtr->Target, sizeof(CmdPtr->Target),
        -:  214:                                                 FM_MOVE_TGT_ERR_EID, CmdText);
        -:  215:        }
        -:  216:    }
        -:  217:
        -:  218:    /* Check for lower priority child task availability */
        3:  219:    if (CommandResult == TRUE)
        -:  220:    {
        2:  221:        CommandResult = FM_VerifyChildTask(FM_MOVE_CHILD_ERR_EID, CmdText);
        -:  222:    }
        -:  223:
        -:  224:    /* Prepare command for child task execution */
        3:  225:    if (CommandResult == TRUE)
        -:  226:    {
        2:  227:        CmdArgs = &FM_GlobalData.ChildQueue[FM_GlobalData.ChildWriteIndex];
        -:  228:
        -:  229:        /* Set handshake queue command args */
        2:  230:        CmdArgs->CommandCode = FM_MOVE_CC;
        2:  231:        strcpy(CmdArgs->Source1, CmdPtr->Source);
        2:  232:        strcpy(CmdArgs->Target,  CmdPtr->Target);
        -:  233:
        -:  234:        /* Invoke lower priority child task */
        2:  235:        FM_InvokeChildTask();
        -:  236:    }
        -:  237:
        3:  238:    return(CommandResult);
        -:  239:
        -:  240:} /* End of FM_MoveFileCmd() */
        -:  241:
        -:  242:
        -:  243:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  244:/*                                                                 */
        -:  245:/* FM command handler -- Rename File                               */
        -:  246:/*                                                                 */
        -:  247:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  248:
        2:  249:boolean FM_RenameFileCmd(CFE_SB_MsgPtr_t MessagePtr)
        -:  250:{
        2:  251:    FM_RenameFileCmd_t  *CmdPtr = (FM_RenameFileCmd_t *) MessagePtr;
        -:  252:    FM_ChildQueueEntry_t *CmdArgs;
        2:  253:    char *CmdText = "Rename File";
        -:  254:    boolean CommandResult;
        -:  255:
        -:  256:    /* Verify command packet length */
        2:  257:    CommandResult = FM_IsValidCmdPktLength(MessagePtr, sizeof(FM_RenameFileCmd_t),
        -:  258:                                           FM_RENAME_PKT_ERR_EID, CmdText);
        -:  259:
        -:  260:    /* Verify that source file exists and is not a directory */
        2:  261:    if (CommandResult == TRUE)
        -:  262:    {
        2:  263:        CommandResult = FM_VerifyFileExists(CmdPtr->Source, sizeof(CmdPtr->Source),
        -:  264:                                            FM_RENAME_SRC_ERR_EID, CmdText);
        -:  265:    }
        -:  266:
        -:  267:    /* Verify that target file does not exist */
        2:  268:    if (CommandResult == TRUE)
        -:  269:    {
        1:  270:        CommandResult = FM_VerifyFileNoExist(CmdPtr->Target, sizeof(CmdPtr->Target),
        -:  271:                                             FM_RENAME_TGT_ERR_EID, CmdText);
        -:  272:    }
        -:  273:
        -:  274:    /* Check for lower priority child task availability */
        2:  275:    if (CommandResult == TRUE)
        -:  276:    {
        1:  277:        CommandResult = FM_VerifyChildTask(FM_RENAME_CHILD_ERR_EID, CmdText);
        -:  278:    }
        -:  279:
        -:  280:    /* Prepare command for child task execution */
        2:  281:    if (CommandResult == TRUE)
        -:  282:    {
        1:  283:        CmdArgs = &FM_GlobalData.ChildQueue[FM_GlobalData.ChildWriteIndex];
        -:  284:
        -:  285:        /* Set handshake queue command args */
        1:  286:        CmdArgs->CommandCode = FM_RENAME_CC;
        1:  287:        strcpy(CmdArgs->Source1, CmdPtr->Source);
        1:  288:        strcpy(CmdArgs->Target,  CmdPtr->Target);
        -:  289:
        -:  290:        /* Invoke lower priority child task */
        1:  291:        FM_InvokeChildTask();
        -:  292:    }
        -:  293:
        2:  294:    return(CommandResult);
        -:  295:
        -:  296:} /* End of FM_RenameFileCmd() */
        -:  297:
        -:  298:
        -:  299:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  300:/*                                                                 */
        -:  301:/* FM command handler -- Delete File                               */
        -:  302:/*                                                                 */
        -:  303:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  304:
        3:  305:boolean FM_DeleteFileCmd(CFE_SB_MsgPtr_t MessagePtr)
        -:  306:{
        3:  307:    FM_DeleteFileCmd_t *CmdPtr = (FM_DeleteFileCmd_t *) MessagePtr;
        -:  308:    FM_ChildQueueEntry_t *CmdArgs;
        3:  309:    char *CmdText = "Delete File";
        -:  310:    boolean CommandResult;
        -:  311:
        -:  312:    /* Verify command packet length */
        3:  313:    CommandResult = FM_IsValidCmdPktLength(MessagePtr, sizeof(FM_DeleteFileCmd_t),
        -:  314:                                           FM_DELETE_PKT_ERR_EID, CmdText);
        -:  315:
        -:  316:    /* Verify that file exists, is not a directory and is not open */
        3:  317:    if (CommandResult == TRUE)
        -:  318:    {
        3:  319:        CommandResult = FM_VerifyFileClosed(CmdPtr->Filename, sizeof(CmdPtr->Filename),
        -:  320:                                            FM_DELETE_SRC_ERR_EID, CmdText);
        -:  321:    }
        -:  322:
        -:  323:    /* Check for lower priority child task availability */
        3:  324:    if (CommandResult == TRUE)
        -:  325:    {
        2:  326:        CommandResult = FM_VerifyChildTask(FM_DELETE_CHILD_ERR_EID, CmdText);
        -:  327:    }
        -:  328:
        -:  329:    /* Prepare command for child task execution */
        3:  330:    if (CommandResult == TRUE)
        -:  331:    {
        2:  332:        CmdArgs = &FM_GlobalData.ChildQueue[FM_GlobalData.ChildWriteIndex];
        -:  333:
        -:  334:        /* Set handshake queue command args - might be global or internal CC */
        2:  335:        CmdArgs->CommandCode = CFE_SB_GetCmdCode(MessagePtr);
        2:  336:        strcpy(CmdArgs->Source1, CmdPtr->Filename);
        -:  337:
        -:  338:        /* Invoke lower priority child task */
        2:  339:        FM_InvokeChildTask();
        -:  340:    }
        -:  341:
        3:  342:    return(CommandResult);
        -:  343:
        -:  344:} /* End of FM_DeleteFileCmd() */
        -:  345:
        -:  346:
        -:  347:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  348:/*                                                                 */
        -:  349:/* FM command handler -- Delete All Files                          */
        -:  350:/*                                                                 */
        -:  351:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  352:
        2:  353:boolean FM_DeleteAllFilesCmd(CFE_SB_MsgPtr_t MessagePtr)
        -:  354:{
        2:  355:    FM_DeleteAllCmd_t *CmdPtr = (FM_DeleteAllCmd_t *) MessagePtr;
        2:  356:    char *CmdText = "Delete All Files";
        -:  357:    char DirWithSep[OS_MAX_PATH_LEN];
        -:  358:    FM_ChildQueueEntry_t *CmdArgs;
        -:  359:    boolean CommandResult;
        -:  360:
        -:  361:    /* Verify message length */
        2:  362:    CommandResult = FM_IsValidCmdPktLength(MessagePtr, sizeof(FM_DeleteAllCmd_t),
        -:  363:                                           FM_DELETE_ALL_PKT_ERR_EID, CmdText);
        -:  364:
        -:  365:    /* Verify that the directory exists */
        2:  366:    if (CommandResult == TRUE)
        -:  367:    {
        2:  368:        CommandResult = FM_VerifyDirExists(CmdPtr->Directory, sizeof(CmdPtr->Directory),
        -:  369:                                           FM_DELETE_ALL_SRC_ERR_EID, CmdText);
        -:  370:    }
        -:  371:
        2:  372:    if (CommandResult == TRUE)
        -:  373:    {
        -:  374:        /* Append a path separator to the end of the directory name */
        1:  375:        strcpy(DirWithSep, CmdPtr->Directory);
        1:  376:        FM_AppendPathSep(DirWithSep, OS_MAX_PATH_LEN);
        -:  377:
        -:  378:        /* Check for lower priority child task availability */
        1:  379:        CommandResult = FM_VerifyChildTask(FM_DELETE_ALL_CHILD_ERR_EID, CmdText);
        -:  380:    }
        -:  381:
        -:  382:    /* Prepare command for child task execution */
        2:  383:    if (CommandResult == TRUE)
        -:  384:    {
        1:  385:        CmdArgs = &FM_GlobalData.ChildQueue[FM_GlobalData.ChildWriteIndex];
        -:  386:
        -:  387:        /* Set handshake queue command args */
        1:  388:        CmdArgs->CommandCode = FM_DELETE_ALL_CC;
        1:  389:        strcpy(CmdArgs->Source1, CmdPtr->Directory);
        1:  390:        strcpy(CmdArgs->Source2, DirWithSep);
        -:  391:
        -:  392:        /* Invoke lower priority child task */
        1:  393:        FM_InvokeChildTask();
        -:  394:    }
        -:  395:
        2:  396:    return(CommandResult);
        -:  397:
        -:  398:} /* End of FM_DeleteAllFilesCmd() */
        -:  399:
        -:  400:
        -:  401:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  402:/*                                                                 */
        -:  403:/* FM command handler -- Decompress File                           */
        -:  404:/*                                                                 */
        -:  405:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  406:
        2:  407:boolean FM_DecompressFileCmd(CFE_SB_MsgPtr_t MessagePtr)
        -:  408:{
        2:  409:    FM_DecompressCmd_t  *CmdPtr = (FM_DecompressCmd_t *) MessagePtr;
        2:  410:    char *CmdText = "Decompress File";
        -:  411:    FM_ChildQueueEntry_t *CmdArgs;
        -:  412:    boolean CommandResult;
        -:  413:
        -:  414:    /* Verify command packet length */
        2:  415:    CommandResult = FM_IsValidCmdPktLength(MessagePtr, sizeof(FM_DecompressCmd_t),
        -:  416:                                           FM_DECOM_PKT_ERR_EID, CmdText);
        -:  417:
        -:  418:    /* Verify that source file exists, is not a directory and is not open */
        2:  419:    if (CommandResult == TRUE)
        -:  420:    {
        2:  421:        CommandResult = FM_VerifyFileClosed(CmdPtr->Source, sizeof(CmdPtr->Source),
        -:  422:                                            FM_DECOM_SRC_ERR_EID, CmdText);
        -:  423:    }
        -:  424:
        -:  425:    /* Verify that target file does not exist */
        2:  426:    if (CommandResult == TRUE)
        -:  427:    {
        1:  428:        CommandResult = FM_VerifyFileNoExist(CmdPtr->Target, sizeof(CmdPtr->Target),
        -:  429:                                             FM_DECOM_TGT_ERR_EID, CmdText);
        -:  430:    }
        -:  431:
        -:  432:    /* Check for lower priority child task availability */
        2:  433:    if (CommandResult == TRUE)
        -:  434:    {
        1:  435:        CommandResult = FM_VerifyChildTask(FM_DECOM_CHILD_ERR_EID, CmdText);
        -:  436:    }
        -:  437:
        -:  438:    /* Prepare command for child task execution */
        2:  439:    if (CommandResult == TRUE)
        -:  440:    {
        1:  441:        CmdArgs = &FM_GlobalData.ChildQueue[FM_GlobalData.ChildWriteIndex];
        -:  442:
        -:  443:        /* Set handshake queue command args */
        1:  444:        CmdArgs->CommandCode = FM_DECOMPRESS_CC;
        1:  445:        strcpy(CmdArgs->Source1, CmdPtr->Source);
        1:  446:        strcpy(CmdArgs->Target, CmdPtr->Target);
        -:  447:
        -:  448:        /* Invoke lower priority child task */
        1:  449:        FM_InvokeChildTask();
        -:  450:    }
        -:  451:
        2:  452:    return(CommandResult);
        -:  453:
        -:  454:} /* End of FM_DecompressFileCmd() */
        -:  455:
        -:  456:
        -:  457:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  458:/*                                                                 */
        -:  459:/* FM command handler -- Concatenate Files                         */
        -:  460:/*                                                                 */
        -:  461:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  462:
        2:  463:boolean FM_ConcatFilesCmd(CFE_SB_MsgPtr_t MessagePtr)
        -:  464:{
        2:  465:    FM_ConcatCmd_t *CmdPtr = (FM_ConcatCmd_t *) MessagePtr;
        2:  466:    char *CmdText = "Concat Files";
        -:  467:    FM_ChildQueueEntry_t *CmdArgs;
        -:  468:    boolean CommandResult;
        -:  469:
        -:  470:    /* Verify command packet length */
        2:  471:    CommandResult = FM_IsValidCmdPktLength(MessagePtr, sizeof(FM_ConcatCmd_t),
        -:  472:                                           FM_CONCAT_PKT_ERR_EID, CmdText);
        -:  473:
        -:  474:    /* Verify that source file #1 exists, is not a directory and is not open */
        2:  475:    if (CommandResult == TRUE)
        -:  476:    {
        2:  477:        CommandResult = FM_VerifyFileClosed(CmdPtr->Source1, sizeof(CmdPtr->Source1),
        -:  478:                                            FM_CONCAT_SRC1_ERR_EID, CmdText);
        -:  479:    }
        -:  480:
        -:  481:    /* Verify that source file #2 exists, is not a directory and is not open */
        2:  482:    if (CommandResult == TRUE)
        -:  483:    {
        1:  484:        CommandResult = FM_VerifyFileClosed(CmdPtr->Source2, sizeof(CmdPtr->Source2),
        -:  485:                                            FM_CONCAT_SRC2_ERR_EID, CmdText);
        -:  486:    }
        -:  487:
        -:  488:    /* Verify that target file does not exist */
        2:  489:    if (CommandResult == TRUE)
        -:  490:    {
        1:  491:        CommandResult = FM_VerifyFileNoExist(CmdPtr->Target, sizeof(CmdPtr->Target),
        -:  492:                                             FM_CONCAT_TGT_ERR_EID, CmdText);
        -:  493:    }
        -:  494:
        -:  495:    /* Check for lower priority child task availability */
        2:  496:    if (CommandResult == TRUE)
        -:  497:    {
        1:  498:        CommandResult = FM_VerifyChildTask(FM_CONCAT_CHILD_ERR_EID, CmdText);
        -:  499:    }
        -:  500:
        -:  501:    /* Prepare command for child task execution */
        2:  502:    if (CommandResult == TRUE)
        -:  503:    {
        1:  504:        CmdArgs = &FM_GlobalData.ChildQueue[FM_GlobalData.ChildWriteIndex];
        -:  505:
        -:  506:        /* Set handshake queue command args */
        1:  507:        CmdArgs->CommandCode = FM_CONCAT_CC;
        1:  508:        strcpy(CmdArgs->Source1, CmdPtr->Source1);
        1:  509:        strcpy(CmdArgs->Source2, CmdPtr->Source2);
        1:  510:        strcpy(CmdArgs->Target, CmdPtr->Target);
        -:  511:
        -:  512:        /* Invoke lower priority child task */
        1:  513:        FM_InvokeChildTask();
        -:  514:    }
        -:  515:
        2:  516:    return(CommandResult);
        -:  517:
        -:  518:} /* End of FM_ConcatFilesCmd() */
        -:  519:
        -:  520:
        -:  521:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  522:/*                                                                 */
        -:  523:/* FM command handler -- Get File Info                             */
        -:  524:/*                                                                 */
        -:  525:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  526:
        3:  527:boolean FM_GetFileInfoCmd(CFE_SB_MsgPtr_t MessagePtr)
        -:  528:{
        3:  529:    FM_GetFileInfoCmd_t *CmdPtr = (FM_GetFileInfoCmd_t *) MessagePtr;
        3:  530:    char *CmdText = "Get File Info";
        -:  531:    FM_ChildQueueEntry_t *CmdArgs;
        -:  532:    boolean CommandResult;
        -:  533:    uint32 FilenameState;
        -:  534:
        -:  535:    /* Verify command packet length */
        3:  536:    CommandResult = FM_IsValidCmdPktLength(MessagePtr, sizeof(FM_GetFileInfoCmd_t),
        -:  537:                                           FM_GET_FILE_INFO_PKT_ERR_EID, CmdText);
        -:  538:
        -:  539:    /* Verify that the source name is valid for a file or directory */
        3:  540:    if (CommandResult == TRUE)
        -:  541:    {
        3:  542:        FilenameState = FM_VerifyNameValid(CmdPtr->Filename, sizeof(CmdPtr->Filename),
        -:  543:                                           FM_GET_FILE_INFO_SRC_ERR_EID, CmdText);
        -:  544:
        3:  545:        if (FilenameState == FM_NAME_IS_INVALID)
        -:  546:        {
        2:  547:            CommandResult = FALSE;
        -:  548:        }
        -:  549:    }
        -:  550:
        -:  551:    /* Check for lower priority child task availability */
        3:  552:    if (CommandResult == TRUE)
        -:  553:    {
        1:  554:        CommandResult = FM_VerifyChildTask(FM_GET_FILE_INFO_CHILD_ERR_EID, CmdText);
        -:  555:    }
        -:  556:
        -:  557:    /* Prepare command for child task execution */
        3:  558:    if (CommandResult == TRUE)
        -:  559:    {
        1:  560:        CmdArgs = &FM_GlobalData.ChildQueue[FM_GlobalData.ChildWriteIndex];
        -:  561:
        -:  562:        /* Set handshake queue command args */
        1:  563:        CmdArgs->CommandCode = FM_GET_FILE_INFO_CC;
        1:  564:        strcpy(CmdArgs->Source1, CmdPtr->Filename);
        1:  565:        CmdArgs->FileInfoState = FilenameState;
        1:  566:        CmdArgs->FileInfoCRC = CmdPtr->FileInfoCRC;
        -:  567:
        -:  568:        /* Global data set during call to FM_VerifyNameValid */
        1:  569:        CmdArgs->FileInfoSize = FM_GlobalData.FileStatSize;
        1:  570:        CmdArgs->FileInfoTime = CFE_TIME_FS2CFESeconds(FM_GlobalData.FileStatTime);
        -:  571:
        -:  572:        /* Invoke lower priority child task */
        1:  573:        FM_InvokeChildTask();
        -:  574:    }
        -:  575:
        3:  576:    return(CommandResult);
        -:  577:
        -:  578:} /* End of FM_GetFileInfoCmd() */
        -:  579:
        -:  580:
        -:  581:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  582:/*                                                                 */
        -:  583:/* FM command handler -- Get List of Open Files                    */
        -:  584:/*                                                                 */
        -:  585:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  586:
        2:  587:boolean FM_GetOpenFilesCmd(CFE_SB_MsgPtr_t MessagePtr)
        -:  588:{
        2:  589:    char *CmdText = "Get Open Files";
        -:  590:    boolean CommandResult;
        -:  591:    uint32 NumOpenFiles;
        -:  592:
        -:  593:    /* Verify command packet length */
        2:  594:    CommandResult = FM_IsValidCmdPktLength(MessagePtr, sizeof(FM_GetOpenFilesCmd_t),
        -:  595:                                           FM_GET_OPEN_FILES_PKT_ERR_EID, CmdText);
        2:  596:    if (CommandResult == TRUE)
        -:  597:    {
        -:  598:        /* Initialize open files telemetry packet */
        2:  599:        CFE_SB_InitMsg(&FM_GlobalData.OpenFilesPkt, FM_OPEN_FILES_TLM_MID,
        -:  600:                        sizeof(FM_OpenFilesPkt_t), TRUE);
        -:  601:
        -:  602:        /* Get list of open files and count */
        2:  603:        NumOpenFiles = FM_GetOpenFilesData(FM_GlobalData.OpenFilesPkt.OpenFilesList);
        2:  604:        FM_GlobalData.OpenFilesPkt.NumOpenFiles = NumOpenFiles;
        -:  605:
        -:  606:        /* Timestamp and send open files telemetry packet */
        2:  607:        CFE_SB_TimeStampMsg((CFE_SB_Msg_t *) &FM_GlobalData.OpenFilesPkt);
        2:  608:        CFE_SB_SendMsg((CFE_SB_Msg_t *) &FM_GlobalData.OpenFilesPkt);
        -:  609:
        -:  610:        /* Send command completion event (debug) */
        2:  611:        CFE_EVS_SendEvent(FM_GET_OPEN_FILES_CMD_EID, CFE_EVS_DEBUG,
        -:  612:                         "%s command", CmdText);
        -:  613:    }
        -:  614:
        2:  615:    return(CommandResult);
        -:  616:
        -:  617:} /* End of FM_GetOpenFilesCmd() */
        -:  618:
        -:  619:
        -:  620:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  621:/*                                                                 */
        -:  622:/* FM command handler -- Create Directory                          */
        -:  623:/*                                                                 */
        -:  624:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  625:
        2:  626:boolean FM_CreateDirectoryCmd(CFE_SB_MsgPtr_t MessagePtr)
        -:  627:{
        2:  628:    FM_CreateDirCmd_t *CmdPtr = (FM_CreateDirCmd_t *) MessagePtr;
        -:  629:    FM_ChildQueueEntry_t *CmdArgs;
        2:  630:    char *CmdText = "Create Directory";
        -:  631:    boolean CommandResult;
        -:  632:
        -:  633:    /* Verify command packet length */
        2:  634:    CommandResult = FM_IsValidCmdPktLength(MessagePtr, sizeof(FM_CreateDirCmd_t),
        -:  635:                                           FM_CREATE_DIR_PKT_ERR_EID, CmdText);
        -:  636:
        -:  637:    /* Verify that the directory name is not already in use */
        2:  638:    if (CommandResult == TRUE)
        -:  639:    {
        2:  640:        CommandResult = FM_VerifyDirNoExist(CmdPtr->Directory, sizeof(CmdPtr->Directory),
        -:  641:                                            FM_CREATE_DIR_SRC_ERR_EID, CmdText);
        -:  642:    }
        -:  643:
        -:  644:    /* Check for lower priority child task availability */
        2:  645:    if (CommandResult == TRUE)
        -:  646:    {
        1:  647:        CommandResult = FM_VerifyChildTask(FM_CREATE_DIR_CHILD_ERR_EID, CmdText);
        -:  648:    }
        -:  649:
        -:  650:    /* Prepare command for child task execution */
        2:  651:    if (CommandResult == TRUE)
        -:  652:    {
        1:  653:        CmdArgs = &FM_GlobalData.ChildQueue[FM_GlobalData.ChildWriteIndex];
        -:  654:
        -:  655:        /* Set handshake queue command args */
        1:  656:        CmdArgs->CommandCode = FM_CREATE_DIR_CC;
        1:  657:        strcpy(CmdArgs->Source1, CmdPtr->Directory);
        -:  658:
        -:  659:        /* Invoke lower priority child task */
        1:  660:        FM_InvokeChildTask();
        -:  661:    }
        -:  662:
        2:  663:    return(CommandResult);
        -:  664:
        -:  665:} /* End of FM_CreateDirectoryCmd() */
        -:  666:
        -:  667:
        -:  668:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  669:/*                                                                 */
        -:  670:/* FM command handler -- Delete Directory                          */
        -:  671:/*                                                                 */
        -:  672:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  673:
        2:  674:boolean FM_DeleteDirectoryCmd(CFE_SB_MsgPtr_t MessagePtr)
        -:  675:{
        2:  676:    FM_DeleteDirCmd_t *CmdPtr = (FM_DeleteDirCmd_t *) MessagePtr;
        -:  677:    FM_ChildQueueEntry_t *CmdArgs;
        2:  678:    char *CmdText = "Delete Directory";
        -:  679:    boolean CommandResult;
        -:  680:
        -:  681:    /* Verify command packet length */
        2:  682:    CommandResult = FM_IsValidCmdPktLength(MessagePtr, sizeof(FM_DeleteDirCmd_t),
        -:  683:                                           FM_DELETE_DIR_PKT_ERR_EID, CmdText);
        -:  684:
        -:  685:    /* Verify that the directory exists */
        2:  686:    if (CommandResult == TRUE)
        -:  687:    {
        2:  688:        CommandResult = FM_VerifyDirExists(CmdPtr->Directory, sizeof(CmdPtr->Directory),
        -:  689:                                           FM_DELETE_DIR_SRC_ERR_EID, CmdText);
        -:  690:    }
        -:  691:
        -:  692:    /* Check for lower priority child task availability */
        2:  693:    if (CommandResult == TRUE)
        -:  694:    {
        1:  695:        CommandResult = FM_VerifyChildTask(FM_DELETE_DIR_CHILD_ERR_EID, CmdText);
        -:  696:    }
        -:  697:
        -:  698:    /* Prepare command for child task execution */
        2:  699:    if (CommandResult == TRUE)
        -:  700:    {
        1:  701:        CmdArgs = &FM_GlobalData.ChildQueue[FM_GlobalData.ChildWriteIndex];
        -:  702:
        -:  703:        /* Set handshake queue command args */
        1:  704:        CmdArgs->CommandCode = FM_DELETE_DIR_CC;
        1:  705:        strcpy(CmdArgs->Source1, CmdPtr->Directory);
        -:  706:
        -:  707:        /* Invoke lower priority child task */
        1:  708:        FM_InvokeChildTask();
        -:  709:    }
        -:  710:
        2:  711:    return(CommandResult);
        -:  712:
        -:  713:} /* End of FM_DeleteDirectoryCmd() */
        -:  714:
        -:  715:
        -:  716:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  717:/*                                                                 */
        -:  718:/* FM command handler -- Get List of Directory Entries (to file)   */
        -:  719:/*                                                                 */
        -:  720:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  721:
        3:  722:boolean FM_GetDirListFileCmd(CFE_SB_MsgPtr_t MessagePtr)
        -:  723:{
        3:  724:    FM_GetDirFileCmd_t *CmdPtr = (FM_GetDirFileCmd_t *) MessagePtr;
        3:  725:    char *CmdText = "Directory List to File";
        -:  726:    char DirWithSep[OS_MAX_PATH_LEN];
        -:  727:    char Filename[OS_MAX_PATH_LEN];
        -:  728:    FM_ChildQueueEntry_t *CmdArgs;
        -:  729:    boolean CommandResult;
        -:  730:
        -:  731:    /* Verify command packet length */
        3:  732:    CommandResult = FM_IsValidCmdPktLength(MessagePtr, sizeof(FM_GetDirFileCmd_t),
        -:  733:                                           FM_GET_DIR_FILE_PKT_ERR_EID, CmdText);
        -:  734:
        -:  735:    /* Verify that source directory exists */
        3:  736:    if (CommandResult == TRUE)
        -:  737:    {
        3:  738:        CommandResult = FM_VerifyDirExists(CmdPtr->Directory, sizeof(CmdPtr->Directory),
        -:  739:                                           FM_GET_DIR_FILE_SRC_ERR_EID, CmdText);
        -:  740:    }
        -:  741:
        -:  742:    /* Verify that target file is not already open */
        3:  743:    if (CommandResult == TRUE)
        -:  744:    {
        -:  745:        /* Use default filename if not specified in the command */
        2:  746:        if (CmdPtr->Filename[0] == '\0')
        -:  747:        {
        1:  748:            strcpy(Filename, FM_DIR_LIST_FILE_DEFNAME);
        -:  749:        }
        -:  750:        else
        -:  751:        {
        1:  752:            CFE_PSP_MemCpy(Filename, CmdPtr->Filename, OS_MAX_PATH_LEN);
        -:  753:        }
        -:  754:
        -:  755:        /* Note: it is OK for this file to overwrite a previous version of the file */
        2:  756:        CommandResult = FM_VerifyFileNotOpen(Filename, sizeof(Filename),
        -:  757:                                             FM_GET_DIR_FILE_TGT_ERR_EID, CmdText);
        -:  758:    }
        -:  759:
        -:  760:    /* Check for lower priority child task availability */
        3:  761:    if (CommandResult == TRUE)
        -:  762:    {
        2:  763:        CommandResult = FM_VerifyChildTask(FM_GET_DIR_FILE_CHILD_ERR_EID, CmdText);
        -:  764:    }
        -:  765:
        -:  766:    /* Prepare command for child task execution */
        3:  767:    if (CommandResult == TRUE)
        -:  768:    {
        2:  769:        CmdArgs = &FM_GlobalData.ChildQueue[FM_GlobalData.ChildWriteIndex];
        -:  770:
        -:  771:        /* Append a path separator to the end of the directory name */
        2:  772:        strcpy(DirWithSep, CmdPtr->Directory);
        2:  773:        FM_AppendPathSep(DirWithSep, OS_MAX_PATH_LEN);
        -:  774:
        -:  775:        /* Set handshake queue command args */
        2:  776:        CmdArgs->CommandCode = FM_GET_DIR_FILE_CC;
        2:  777:        CmdArgs->GetSizeTimeMode = CmdPtr->GetSizeTimeMode;
        2:  778:        strcpy(CmdArgs->Source1, CmdPtr->Directory);
        2:  779:        strcpy(CmdArgs->Source2, DirWithSep);
        2:  780:        strcpy(CmdArgs->Target, Filename);
        -:  781:
        -:  782:        /* Invoke lower priority child task */
        2:  783:        FM_InvokeChildTask();
        -:  784:    }
        -:  785:
        3:  786:    return(CommandResult);
        -:  787:
        -:  788:} /* End of FM_GetDirListFileCmd() */
        -:  789:
        -:  790:
        -:  791:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  792:/*                                                                 */
        -:  793:/* FM command handler -- Get List of Directory Entries (to pkt)    */
        -:  794:/*                                                                 */
        -:  795:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  796:
        2:  797:boolean FM_GetDirListPktCmd(CFE_SB_MsgPtr_t MessagePtr)
        -:  798:{
        2:  799:    FM_GetDirPktCmd_t *CmdPtr = (FM_GetDirPktCmd_t *) MessagePtr;
        2:  800:    char *CmdText = "Directory List to Packet";
        -:  801:    char DirWithSep[OS_MAX_PATH_LEN];
        -:  802:    FM_ChildQueueEntry_t *CmdArgs;
        -:  803:    boolean CommandResult;
        -:  804:
        -:  805:    /* Verify command packet length */
        2:  806:    CommandResult = FM_IsValidCmdPktLength(MessagePtr, sizeof(FM_GetDirPktCmd_t),
        -:  807:                                           FM_GET_DIR_PKT_PKT_ERR_EID, CmdText);
        -:  808:
        -:  809:    /* Verify that source directory exists */
        2:  810:    if (CommandResult == TRUE)
        -:  811:    {
        2:  812:        CommandResult = FM_VerifyDirExists(CmdPtr->Directory, sizeof(CmdPtr->Directory),
        -:  813:                                           FM_GET_DIR_PKT_SRC_ERR_EID, CmdText);
        -:  814:    }
        -:  815:
        -:  816:    /* Check for lower priority child task availability */
        2:  817:    if (CommandResult == TRUE)
        -:  818:    {
        1:  819:        CommandResult = FM_VerifyChildTask(FM_GET_DIR_PKT_CHILD_ERR_EID, CmdText);
        -:  820:    }
        -:  821:
        -:  822:    /* Prepare command for child task execution */
        2:  823:    if (CommandResult == TRUE)
        -:  824:    {
        1:  825:        CmdArgs = &FM_GlobalData.ChildQueue[FM_GlobalData.ChildWriteIndex];
        -:  826:
        -:  827:        /* Append a path separator to the end of the directory name */
        1:  828:        strcpy(DirWithSep, CmdPtr->Directory);
        1:  829:        FM_AppendPathSep(DirWithSep, OS_MAX_PATH_LEN);
        -:  830:
        -:  831:        /* Set handshake queue command args */
        1:  832:        CmdArgs->CommandCode = FM_GET_DIR_PKT_CC;
        1:  833:        CmdArgs->GetSizeTimeMode = CmdPtr->GetSizeTimeMode;
        1:  834:        strcpy(CmdArgs->Source1, CmdPtr->Directory);
        1:  835:        strcpy(CmdArgs->Source2, DirWithSep);
        1:  836:        CmdArgs->DirListOffset = CmdPtr->DirListOffset;
        -:  837:
        -:  838:        /* Invoke lower priority child task */
        1:  839:        FM_InvokeChildTask();
        -:  840:    }
        -:  841:
        2:  842:    return(CommandResult);
        -:  843:
        -:  844:} /* End of FM_GetDirListPktCmd() */
        -:  845:
        -:  846:
        -:  847:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  848:/*                                                                 */
        -:  849:/* FM command handler -- Get File System Free Space                */
        -:  850:/*                                                                 */
        -:  851:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  852:
        3:  853:boolean FM_GetFreeSpaceCmd(CFE_SB_MsgPtr_t MessagePtr)
        -:  854:{
        3:  855:    char *CmdText = "Get Free Space";
        -:  856:    boolean CommandResult;
        -:  857:    uint32 i;
        -:  858:    uint64 FreeSpace64;
        -:  859:
        -:  860:
        -:  861:    /* Verify command packet length */
        3:  862:    CommandResult = FM_IsValidCmdPktLength(MessagePtr, sizeof(FM_GetFreeSpaceCmd_t),
        -:  863:                                           FM_GET_FREE_SPACE_PKT_ERR_EID, CmdText);
        3:  864:    if (CommandResult == TRUE)
        -:  865:    {
        -:  866:        /* Verify that we have a pointer to the file system table data */
        3:  867:        if (FM_GlobalData.FreeSpaceTablePtr == (FM_FreeSpaceTable_t *) NULL)
        -:  868:        {
        2:  869:            CommandResult = FALSE;
        -:  870:
        2:  871:            CFE_EVS_SendEvent(FM_GET_FREE_SPACE_TBL_ERR_EID, CFE_EVS_ERROR,
        -:  872:                             "%s error: file system free space table is not loaded", CmdText);
        -:  873:        }
        -:  874:        else
        -:  875:        {
        -:  876:            /* Initialize the file system free space telemetry packet */
        1:  877:            CFE_SB_InitMsg(&FM_GlobalData.FreeSpacePkt, FM_FREE_SPACE_TLM_MID,
        -:  878:                           sizeof(FM_FreeSpacePkt_t), TRUE);
        -:  879:
        -:  880:            /* Process enabled file system table entries */
        9:  881:            for (i = 0; i < FM_TABLE_ENTRY_COUNT; i++)
        -:  882:            {
        8:  883:                if (FM_GlobalData.FreeSpaceTablePtr->FileSys[i].State == FM_TABLE_ENTRY_ENABLED)
        -:  884:                {
        -:  885:                    /* Get file system name */
        1:  886:                    strcpy(FM_GlobalData.FreeSpacePkt.FileSys[i].Name,
        1:  887:                           FM_GlobalData.FreeSpaceTablePtr->FileSys[i].Name);
        -:  888:
        -:  889:                    /* Get file system free space */
        1:  890:                    FreeSpace64 = 0;
        1:  891:                    OS_fsBytesFree(FM_GlobalData.FreeSpacePkt.FileSys[i].Name,  &FreeSpace64);
        -:  892:
        -:  893:                    /* Store as bytes to avoid boundary, endian and strict-aliasing issues */
        1:  894:                    CFE_PSP_MemCpy(&FM_GlobalData.FreeSpacePkt.FileSys[i].FreeSpace_A,
        -:  895:                                   &FreeSpace64, sizeof(uint64));
        -:  896:                }
        -:  897:            }
        -:  898:
        -:  899:            /* Timestamp and send file system free space telemetry packet */
        1:  900:            CFE_SB_TimeStampMsg((CFE_SB_Msg_t *) &FM_GlobalData.FreeSpacePkt);
        1:  901:            CFE_SB_SendMsg((CFE_SB_Msg_t *) &FM_GlobalData.FreeSpacePkt);
        -:  902:
        -:  903:            /* Send command completion event (debug) */
        1:  904:            CFE_EVS_SendEvent(FM_GET_FREE_SPACE_CMD_EID, CFE_EVS_DEBUG,
        -:  905:                             "%s command", CmdText);
        -:  906:        }
        -:  907:    }
        -:  908:
        3:  909:    return(CommandResult);
        -:  910:
        -:  911:} /* End of FM_GetFreeSpaceCmd() */
        -:  912:
        -:  913:
        -:  914:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  915:/*                                                                 */
        -:  916:/* FM command handler -- Set Table Entry Enable/Disable State      */
        -:  917:/*                                                                 */
        -:  918:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  919:
        6:  920:boolean FM_SetTableStateCmd(CFE_SB_MsgPtr_t MessagePtr)
        -:  921:{
        6:  922:    FM_SetTableStateCmd_t *CmdPtr = (FM_SetTableStateCmd_t *) MessagePtr;
        6:  923:    char *CmdText = "Set Table State";
        -:  924:    boolean CommandResult;
        -:  925:
        -:  926:    /* Verify command packet length */
        6:  927:    CommandResult = FM_IsValidCmdPktLength(MessagePtr, sizeof(FM_SetTableStateCmd_t),
        -:  928:                                           FM_SET_TABLE_STATE_PKT_ERR_EID, CmdText);
        6:  929:    if (CommandResult == TRUE)
        -:  930:    {
        6:  931:        if (FM_GlobalData.FreeSpaceTablePtr == (FM_FreeSpaceTable_t *) NULL)
        -:  932:        {
        -:  933:            /* File system table has not been loaded */
        2:  934:            CommandResult = FALSE;
        -:  935:
        2:  936:            CFE_EVS_SendEvent(FM_SET_TABLE_STATE_TBL_ERR_EID, CFE_EVS_ERROR,
        -:  937:               "%s error: file system free space table is not loaded", CmdText);
        -:  938:        }
        4:  939:        else if (CmdPtr->TableEntryIndex >= FM_TABLE_ENTRY_COUNT)
        -:  940:        {
        -:  941:            /* Table index argument is out of range */
        1:  942:            CommandResult = FALSE;
        -:  943:
        1:  944:            CFE_EVS_SendEvent(FM_SET_TABLE_STATE_ARG_ERR_EID, CFE_EVS_ERROR,
        -:  945:               "%s error: invalid command argument: index = %d", CmdText, (int)CmdPtr->TableEntryIndex);
        -:  946:        }
        5:  947:        else if ((CmdPtr->TableEntryState != FM_TABLE_ENTRY_ENABLED) &&
        1:  948:            (CmdPtr->TableEntryState != FM_TABLE_ENTRY_DISABLED))
        -:  949:        {
        -:  950:            /* State argument must be either enabled or disabled */
        1:  951:            CommandResult = FALSE;
        -:  952:
        1:  953:            CFE_EVS_SendEvent(FM_SET_TABLE_STATE_ARG_ERR_EID, CFE_EVS_ERROR,
        -:  954:               "%s error: invalid command argument: state = %d", CmdText, (int)CmdPtr->TableEntryState);
        -:  955:        }
        2:  956:        else if (FM_GlobalData.FreeSpaceTablePtr->FileSys[CmdPtr->TableEntryIndex].State == FM_TABLE_ENTRY_UNUSED)
        -:  957:        {
        -:  958:            /* Current table entry state must not be unused */
        1:  959:            CommandResult = FALSE;
        -:  960:
        1:  961:            CFE_EVS_SendEvent(FM_SET_TABLE_STATE_UNUSED_ERR_EID, CFE_EVS_ERROR,
        -:  962:               "%s error: cannot modify unused table entry: index = %d", CmdText, (int)CmdPtr->TableEntryIndex);
        -:  963:        }
        -:  964:        else
        -:  965:        {
        -:  966:            /* Update the table entry state as commanded */
        1:  967:            FM_GlobalData.FreeSpaceTablePtr->FileSys[CmdPtr->TableEntryIndex].State = CmdPtr->TableEntryState;
        -:  968:
        -:  969:            /* Notify cFE that we have modified the table data */
        1:  970:            CFE_TBL_Modified(FM_GlobalData.FreeSpaceTableHandle);
        -:  971:
        -:  972:            /* Send command completion event (info) */
        1:  973:            CFE_EVS_SendEvent(FM_SET_TABLE_STATE_CMD_EID, CFE_EVS_INFORMATION,
        -:  974:               "%s command: index = %d, state = %d", CmdText, (int)CmdPtr->TableEntryIndex, (int)CmdPtr->TableEntryState);
        -:  975:        }
        -:  976:    }
        -:  977:
        6:  978:    return(CommandResult);
        -:  979:
        -:  980:} /* End of FM_SetTableStateCmd() */
        -:  981:
        -:  982:
        -:  983:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  984:/*                                                                 */
        -:  985:/* FM command handler -- Set Permissions for a file                */
        -:  986:/*                                                                 */
        -:  987:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  988:
        3:  989:boolean FM_SetPermissionsCmd(CFE_SB_MsgPtr_t MessagePtr)
        -:  990:{
        3:  991:    FM_SetPermCmd_t *CmdPtr = (FM_SetPermCmd_t *) MessagePtr;
        -:  992:    FM_ChildQueueEntry_t *CmdArgs;
        3:  993:    char *CmdText = "Set Permissions";
        -:  994:    boolean CommandResult;
        -:  995:    boolean FilenameState;
        -:  996:
        -:  997:    /* Verify command packet length */
        3:  998:    CommandResult = FM_IsValidCmdPktLength(MessagePtr, sizeof(FM_SetPermCmd_t),
        -:  999:                                           FM_SET_PERM_ERR_EID, CmdText);
        -: 1000:    
        -: 1001:    
        3: 1002:    if(CommandResult == TRUE)
        -: 1003:    {
        3: 1004:        FilenameState = FM_VerifyNameValid(CmdPtr->FileName, sizeof(CmdPtr->FileName),
        -: 1005:                                            0, CmdText);
        -: 1006:        
        3: 1007:        if (FilenameState == FM_NAME_IS_INVALID)
        -: 1008:        {
        2: 1009:            CommandResult = FALSE;
        -: 1010:        }
        -: 1011:    }
        -: 1012:    
        -: 1013:    /* Check for lower priority child task availability */
        3: 1014:    if (CommandResult == TRUE)
        -: 1015:    {
        1: 1016:        CommandResult = FM_VerifyChildTask(FM_SET_PERM_ERR_EID, CmdText);
        -: 1017:    }
        -: 1018:
        -: 1019:    /* Prepare command for child task execution */
        3: 1020:    if (CommandResult == TRUE)
        -: 1021:    {
        1: 1022:        CmdArgs = &FM_GlobalData.ChildQueue[FM_GlobalData.ChildWriteIndex];
        -: 1023:        /* Set handshake queue command args */
        1: 1024:        CmdArgs->CommandCode = FM_SET_FILE_PERM_CC;
        1: 1025:        strcpy(CmdArgs->Source1, CmdPtr->FileName);
        1: 1026:        CmdArgs->Mode = CmdPtr->Mode;
        -: 1027:
        -: 1028:        /* Invoke lower priority child task */
        1: 1029:        FM_InvokeChildTask();
        -: 1030:    }
        -: 1031:
        3: 1032:    return(CommandResult);
        -: 1033:
        -: 1034:} /* End of FM_SetPermissionsCmd() */
        -: 1035:
        -: 1036:/************************/
        -: 1037:/*  End of File Comment */
        -: 1038:/************************/
        -: 1039:
