        -:    0:Source:../src/fm_child.c
        -:    0:Programs:5
        -:    1:/*
        -:    2:** $Id: fm_child.c.gcov 1.3.1.2 2017/01/25 00:20:22EST mdeschu Exp  $
        -:    3:**
        -:    4:**  Copyright (c) 2007-2014 United States Government as represented by the 
        -:    5:**  Administrator of the National Aeronautics and Space Administration. 
        -:    6:**  All Other Rights Reserved.  
        -:    7:**
        -:    8:**  This software was created at NASA's Goddard Space Flight Center.
        -:    9:**  This software is governed by the NASA Open Source Agreement and may be 
        -:   10:**  used, distributed and modified only pursuant to the terms of that 
        -:   11:**  agreement.
        -:   12:**
        -:   13:** Purpose: File Manager (FM) Child task (low priority command handler)
        -:   14:**
        -:   15:** Author: Scott Walling (Microtel)
        -:   16:**
        -:   17:** Notes:
        -:   18:**
        -:   19:*/
        -:   20:
        -:   21:#include "cfe.h"
        -:   22:#include "fm_msg.h"
        -:   23:#include "fm_msgdefs.h"
        -:   24:#include "fm_msgids.h"
        -:   25:#include "fm_events.h"
        -:   26:#include "fm_app.h"
        -:   27:#include "fm_child.h"
        -:   28:#include "fm_cmds.h"
        -:   29:#include "fm_cmd_utils.h"
        -:   30:#include "fm_perfids.h"
        -:   31:#include "fm_platform_cfg.h"
        -:   32:#include "fm_verify.h"
        -:   33:
        -:   34:#include <string.h>
        -:   35:
        -:   36:/************************************************************************
        -:   37:** OSAL Compatibility for directory name access
        -:   38:** New OSAL version have an access macro to get the string.  If that
        -:   39:** macro is defined, use it, otherwise assume "d_name" structure member.
        -:   40:*************************************************************************/
        -:   41:#ifndef OS_DIRENTRY_NAME
        -:   42:#define OS_DIRENTRY_NAME(x)     ((x).d_name)
        -:   43:#endif
        -:   44:
        -:   45:
        -:   46:#define FM_QUEUE_SEM_NAME "FM_QUEUE_SEM"
        -:   47:
        -:   48:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:   49:/*                                                                 */
        -:   50:/* FM child task -- startup initialization                         */
        -:   51:/*                                                                 */
        -:   52:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:   53:
        6:   54:int32 FM_ChildInit(void)
        -:   55:{
        6:   56:    int32 TaskTextLen = 64;
        6:   57:    char TaskText[TaskTextLen];
        -:   58:    int32 Result;
        -:   59:    
        -:   60:
        -:   61:    /* Create counting semaphore (given by parent to wake-up child) */
        6:   62:    Result = OS_CountSemCreate(&FM_GlobalData.ChildSemaphore, FM_CHILD_SEM_NAME, 0, 0);
        6:   63:    if (Result != CFE_SUCCESS)
        -:   64:    {
        1:   65:        strncpy(TaskText, "create semaphore failed", TaskTextLen);
        -:   66:    }
        -:   67:    else
        -:   68:    {
        -:   69:        /* Create mutex semaphore (protect access to ChildQueueCount) */
        5:   70:        Result = OS_MutSemCreate(&FM_GlobalData.ChildQueueCountSem, FM_QUEUE_SEM_NAME, 0);
        -:   71:
        5:   72:        if (Result != CFE_SUCCESS)
        -:   73:        {
        1:   74:            strncpy(TaskText, "create queue count semaphore failed", TaskTextLen);
        -:   75:        }
        -:   76:        else
        -:   77:        {
        -:   78:            /* Create child task (low priority command handler) */
        4:   79:            Result = CFE_ES_CreateChildTask(&FM_GlobalData.ChildTaskID,
        -:   80:                                             FM_CHILD_TASK_NAME,
        -:   81:                                             FM_ChildTask, 0,
        -:   82:                                             FM_CHILD_TASK_STACK_SIZE,
        -:   83:                                             FM_CHILD_TASK_PRIORITY, 0);
        4:   84:            if (Result != CFE_SUCCESS)
        -:   85:            {
        1:   86:                strncpy(TaskText, "create task failed", TaskTextLen);
        -:   87:            }
        -:   88:        }
        -:   89:    }
        -:   90:    
        6:   91:    if (Result != CFE_SUCCESS)
        -:   92:    {   
        3:   93:        CFE_EVS_SendEvent(FM_CHILD_INIT_ERR_EID, CFE_EVS_ERROR,
        -:   94:           "Child Task initialization error: %s: result = %d",
        -:   95:            TaskText, (int)Result);
        -:   96:    }
        -:   97:
        6:   98:    return(Result);
        -:   99:
        -:  100:} /* End of FM_ChildInit() */
        -:  101:
        -:  102:
        -:  103:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  104:/*                                                                 */
        -:  105:/* FM child task -- task entry point                               */
        -:  106:/*                                                                 */
        -:  107:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  108:
        2:  109:void FM_ChildTask(void)
        -:  110:{
        2:  111:    char *TaskText = "Child Task";
        -:  112:    int32 Result;
        -:  113:
        -:  114:    /*
        -:  115:    ** The child task runs until the parent dies (normal end) or
        -:  116:    **  until it encounters a fatal error (semaphore error, etc.)...
        -:  117:    */
        2:  118:    Result = CFE_ES_RegisterChildTask();
        -:  119:
        2:  120:    if (Result != CFE_SUCCESS)
        -:  121:    {
        1:  122:        CFE_EVS_SendEvent(FM_CHILD_INIT_ERR_EID, CFE_EVS_ERROR,
        -:  123:           "%s initialization error: register child failed: result = %d",
        -:  124:            TaskText, (int)Result);
        -:  125:    }
        -:  126:    else
        -:  127:    {
        1:  128:        CFE_EVS_SendEvent(FM_CHILD_INIT_EID, CFE_EVS_INFORMATION,
        -:  129:           "%s initialization complete", TaskText);
        -:  130:
        -:  131:        /* Child task process loop */
        1:  132:        FM_ChildLoop();
        -:  133:    }
        -:  134:
        -:  135:    /* Stop the parent from invoking the child task */
        2:  136:    FM_GlobalData.ChildSemaphore = FM_CHILD_SEM_INVALID;
        -:  137:
        -:  138:    /* This call allows cFE to clean-up system resources */
        2:  139:    CFE_ES_ExitChildTask();
        -:  140:
        2:  141:    return;
        -:  142:
        -:  143:} /* End of FM_ChildTask() */
        -:  144:
        -:  145:
        -:  146:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  147:/*                                                                 */
        -:  148:/* FM child task -- main process loop                              */
        -:  149:/*                                                                 */
        -:  150:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  151:
        5:  152:void FM_ChildLoop(void)
        -:  153:{
        5:  154:    char *TaskText = "Child Task termination error: ";
        5:  155:    int32 Result = CFE_SUCCESS;
        -:  156:
       16:  157:    while (Result == CFE_SUCCESS)
        -:  158:    {
        -:  159:        /* Pend on the "handshake" semaphore */
        6:  160:        Result = OS_CountSemTake(FM_GlobalData.ChildSemaphore);
        -:  161:
        -:  162:        /* Mark the period when this task is active */
        6:  163:        CFE_ES_PerfLogEntry(FM_CHILD_TASK_PERF_ID);
        -:  164:
        6:  165:        if (Result == CFE_SUCCESS)
        -:  166:        {
        -:  167:            /* Make sure the parent/child handshake is not broken */
        5:  168:            if (FM_GlobalData.ChildQueueCount == 0)
        -:  169:            {
        3:  170:                FM_GlobalData.ChildCmdErrCounter++;
        3:  171:                CFE_EVS_SendEvent(FM_CHILD_TERM_ERR_EID, CFE_EVS_ERROR,
        -:  172:                                  "%s empty queue", TaskText);
        -:  173:
        -:  174:                /* Set result that will terminate child task run loop */
        3:  175:                Result = CFE_OS_ERROR;
        -:  176:            }
        2:  177:            else if (FM_GlobalData.ChildReadIndex >= FM_CHILD_QUEUE_DEPTH)
        -:  178:            {
        1:  179:                FM_GlobalData.ChildCmdErrCounter++;
        1:  180:                CFE_EVS_SendEvent(FM_CHILD_TERM_ERR_EID, CFE_EVS_ERROR,
        -:  181:                                  "%s invalid queue index: index = %d",
        -:  182:                                  TaskText, (int)FM_GlobalData.ChildReadIndex);
        -:  183:
        -:  184:                /* Set result that will terminate child task run loop */
        1:  185:                Result = CFE_OS_ERROR;
        -:  186:            }
        -:  187:            else
        -:  188:            {
        -:  189:                /* Invoke the child task command handler */
        1:  190:                FM_ChildProcess();
        -:  191:            }
        -:  192:        }
        -:  193:        else
        -:  194:        {
        1:  195:            CFE_EVS_SendEvent(FM_CHILD_TERM_ERR_EID, CFE_EVS_ERROR,
        -:  196:                              "%s semaphore take failed: result = %d",
        -:  197:                              TaskText, (int)Result);
        -:  198:        }
        -:  199:
        6:  200:        CFE_ES_PerfLogExit(FM_CHILD_TASK_PERF_ID);
        -:  201:    }
        -:  202:
        5:  203:    return;
        -:  204:
        -:  205:} /* End of FM_ChildLoop() */
        -:  206:
        -:  207:
        -:  208:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  209:/*                                                                 */
        -:  210:/* FM child task -- interface handshake processor                  */
        -:  211:/*                                                                 */
        -:  212:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  213:
       16:  214:void FM_ChildProcess(void)
        -:  215:{
       16:  216:    char *TaskText = "Child Task";
        -:  217:    FM_ChildQueueEntry_t *CmdArgs;
        -:  218:
       16:  219:    CmdArgs = &FM_GlobalData.ChildQueue[FM_GlobalData.ChildReadIndex];
        -:  220:
        -:  221:    /* Invoke the command specific handler */
       16:  222:    switch (CmdArgs->CommandCode)
        -:  223:    {
        -:  224:        case FM_COPY_CC:
        1:  225:            FM_ChildCopyCmd(CmdArgs);
        1:  226:            break;
        -:  227:
        -:  228:        case FM_MOVE_CC:
        1:  229:            FM_ChildMoveCmd(CmdArgs);
        1:  230:            break;
        -:  231:
        -:  232:        case FM_RENAME_CC:
        1:  233:            FM_ChildRenameCmd(CmdArgs);
        1:  234:            break;
        -:  235:
        -:  236:        case FM_DELETE_CC:
        1:  237:            FM_ChildDeleteCmd(CmdArgs);
        1:  238:            break;
        -:  239:
        -:  240:        case FM_DELETE_ALL_CC:
        1:  241:            FM_ChildDeleteAllCmd(CmdArgs);
        1:  242:            break;
        -:  243:
        -:  244:        case FM_DECOMPRESS_CC:
        1:  245:            FM_ChildDecompressCmd(CmdArgs);
        1:  246:            break;
        -:  247:
        -:  248:        case FM_CONCAT_CC:
        1:  249:            FM_ChildConcatCmd(CmdArgs);
        1:  250:            break;
        -:  251:
        -:  252:        case FM_CREATE_DIR_CC:
        1:  253:            FM_ChildCreateDirCmd(CmdArgs);
        1:  254:            break;
        -:  255:
        -:  256:        case FM_DELETE_DIR_CC:
        1:  257:            FM_ChildDeleteDirCmd(CmdArgs);
        1:  258:            break;
        -:  259:
        -:  260:        case FM_GET_FILE_INFO_CC:
        1:  261:            FM_ChildFileInfoCmd(CmdArgs);
        1:  262:            break;
        -:  263:
        -:  264:        case FM_GET_DIR_FILE_CC:
        1:  265:            FM_ChildDirListFileCmd(CmdArgs);
        1:  266:            break;
        -:  267:
        -:  268:        case FM_GET_DIR_PKT_CC:
        1:  269:            FM_ChildDirListPktCmd(CmdArgs);
        1:  270:            break;
        -:  271:
        -:  272:        case FM_DELETE_INT_CC:
        1:  273:            FM_ChildDeleteCmd(CmdArgs);
        1:  274:            break;
        -:  275:            
        -:  276:        case FM_SET_FILE_PERM_CC:
        1:  277:            FM_ChildSetPermissionsCmd(CmdArgs);
        1:  278:            break;
        -:  279:
        -:  280:        default:
        2:  281:            FM_GlobalData.ChildCmdErrCounter++;
        2:  282:            CFE_EVS_SendEvent(FM_CHILD_EXE_ERR_EID, CFE_EVS_ERROR,
        -:  283:               "%s execution error: invalid command code: cc = %d",
        -:  284:                TaskText, (int)CmdArgs->CommandCode);
        -:  285:            break;
        -:  286:    }
        -:  287:
        -:  288:    /* Update the handshake queue read index */
       16:  289:    FM_GlobalData.ChildReadIndex++;
        -:  290:
       16:  291:    if (FM_GlobalData.ChildReadIndex >= FM_CHILD_QUEUE_DEPTH)
        -:  292:    {
        1:  293:        FM_GlobalData.ChildReadIndex = 0;
        -:  294:    }
        -:  295:
        -:  296:    /* Prevent parent/child updating queue counter at same time */
       16:  297:    OS_MutSemTake(FM_GlobalData.ChildQueueCountSem);
       16:  298:    FM_GlobalData.ChildQueueCount--;
       16:  299:    OS_MutSemGive(FM_GlobalData.ChildQueueCountSem);
        -:  300:
       16:  301:    return;
        -:  302:
        -:  303:} /* End of FM_ChildProcess() */
        -:  304:
        -:  305:
        -:  306:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  307:/*                                                                 */
        -:  308:/* FM child task command handler -- Copy File                      */
        -:  309:/*                                                                 */
        -:  310:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  311:
        3:  312:void FM_ChildCopyCmd(FM_ChildQueueEntry_t *CmdArgs)
        -:  313:{
        3:  314:    char *CmdText = "Copy File";
        -:  315:    int32 OS_Status;
        -:  316:
        -:  317:    /* Report current child task activity */
        3:  318:    FM_GlobalData.ChildCurrentCC = CmdArgs->CommandCode;
        -:  319:
        -:  320:    /* Note the order of the arguments to OS_cp (src,tgt) */
        3:  321:    OS_Status = OS_cp(CmdArgs->Source1, CmdArgs->Target);
        -:  322:
        3:  323:    if (OS_Status != OS_SUCCESS)
        -:  324:    {
        1:  325:        FM_GlobalData.ChildCmdErrCounter++;
        -:  326:
        -:  327:        /* Send command failure event (error) */
        1:  328:        CFE_EVS_SendEvent(FM_COPY_OS_ERR_EID, CFE_EVS_ERROR,
        -:  329:           "%s error: OS_cp failed: result = %d, src = %s, tgt = %s",
        -:  330:            CmdText, (int)OS_Status, CmdArgs->Source1, CmdArgs->Target);
        -:  331:    }
        -:  332:    else
        -:  333:    {
        2:  334:        FM_GlobalData.ChildCmdCounter++;
        -:  335:
        -:  336:        /* Send command completion event (info) */
        2:  337:        CFE_EVS_SendEvent(FM_COPY_CMD_EID, CFE_EVS_DEBUG,
        -:  338:           "%s command: src = %s, tgt = %s",
        -:  339:            CmdText, CmdArgs->Source1, CmdArgs->Target);
        -:  340:    }
        -:  341:
        -:  342:    /* Report previous child task activity */
        3:  343:    FM_GlobalData.ChildPreviousCC = CmdArgs->CommandCode;
        3:  344:    FM_GlobalData.ChildCurrentCC = 0;
        -:  345:
        3:  346:    return;
        -:  347:
        -:  348:} /* End of FM_ChildCopyCmd() */
        -:  349:
        -:  350:
        -:  351:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  352:/*                                                                 */
        -:  353:/* FM child task command handler -- Move File                      */
        -:  354:/*                                                                 */
        -:  355:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  356:
        3:  357:void FM_ChildMoveCmd(FM_ChildQueueEntry_t *CmdArgs)
        -:  358:{
        3:  359:    char *CmdText = "Move File";
        -:  360:    int32 OS_Status;
        -:  361:
        -:  362:    /* Report current child task activity */
        3:  363:    FM_GlobalData.ChildCurrentCC = CmdArgs->CommandCode;
        -:  364:
        3:  365:    OS_Status = OS_mv(CmdArgs->Source1, CmdArgs->Target);
        -:  366:
        3:  367:    if (OS_Status != OS_SUCCESS)
        -:  368:    {
        1:  369:        FM_GlobalData.ChildCmdErrCounter++;
        -:  370:
        -:  371:        /* Send command failure event (error) */
        1:  372:        CFE_EVS_SendEvent(FM_MOVE_OS_ERR_EID, CFE_EVS_ERROR,
        -:  373:           "%s error: OS_mv failed: result = %d, src = %s, tgt = %s",
        -:  374:            CmdText, (int)OS_Status, CmdArgs->Source1, CmdArgs->Target);
        -:  375:    }
        -:  376:    else
        -:  377:    {
        2:  378:        FM_GlobalData.ChildCmdCounter++;
        -:  379:
        -:  380:        /* Send command completion event (info) */
        2:  381:        CFE_EVS_SendEvent(FM_MOVE_CMD_EID, CFE_EVS_DEBUG,
        -:  382:           "%s command: src = %s, tgt = %s",
        -:  383:            CmdText, CmdArgs->Source1, CmdArgs->Target);
        -:  384:    }
        -:  385:
        -:  386:    /* Report previous child task activity */
        3:  387:    FM_GlobalData.ChildPreviousCC = CmdArgs->CommandCode;
        3:  388:    FM_GlobalData.ChildCurrentCC = 0;
        -:  389:
        3:  390:    return;
        -:  391:
        -:  392:} /* End of FM_ChildMoveCmd() */
        -:  393:
        -:  394:
        -:  395:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  396:/*                                                                 */
        -:  397:/* FM child task command handler -- Rename File                    */
        -:  398:/*                                                                 */
        -:  399:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  400:
        3:  401:void FM_ChildRenameCmd(FM_ChildQueueEntry_t *CmdArgs)
        -:  402:{
        3:  403:    char *CmdText = "Rename File";
        -:  404:    int32 OS_Status;
        -:  405:
        -:  406:    /* Report current child task activity */
        3:  407:    FM_GlobalData.ChildCurrentCC = CmdArgs->CommandCode;
        -:  408:
        3:  409:    OS_Status = OS_rename(CmdArgs->Source1, CmdArgs->Target);
        -:  410:
        3:  411:    if (OS_Status != OS_SUCCESS)
        -:  412:    {
        1:  413:        FM_GlobalData.ChildCmdErrCounter++;
        -:  414:
        -:  415:        /* Send command failure event (error) */
        1:  416:        CFE_EVS_SendEvent(FM_RENAME_OS_ERR_EID, CFE_EVS_ERROR,
        -:  417:           "%s error: OS_rename failed: result = %d, src = %s, tgt = %s",
        -:  418:            CmdText, (int)OS_Status, CmdArgs->Source1, CmdArgs->Target);
        -:  419:    }
        -:  420:    else
        -:  421:    {
        2:  422:        FM_GlobalData.ChildCmdCounter++;
        -:  423:
        -:  424:        /* Send command completion event (info) */
        2:  425:        CFE_EVS_SendEvent(FM_RENAME_CMD_EID, CFE_EVS_DEBUG,
        -:  426:           "%s command: src = %s, tgt = %s",
        -:  427:            CmdText, CmdArgs->Source1, CmdArgs->Target);
        -:  428:    }
        -:  429:
        -:  430:    /* Report previous child task activity */
        3:  431:    FM_GlobalData.ChildPreviousCC = CmdArgs->CommandCode;
        3:  432:    FM_GlobalData.ChildCurrentCC = 0;
        -:  433:
        3:  434:    return;
        -:  435:
        -:  436:} /* End of FM_ChildRenameCmd() */
        -:  437:
        -:  438:
        -:  439:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  440:/*                                                                 */
        -:  441:/* FM child task command handler -- Delete File                    */
        -:  442:/*                                                                 */
        -:  443:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  444:
        4:  445:void FM_ChildDeleteCmd(FM_ChildQueueEntry_t *CmdArgs)
        -:  446:{
        4:  447:    char *CmdText = "Delete File";
        -:  448:    int32 OS_Status;
        -:  449:
        -:  450:    /* Report current child task activity */
        4:  451:    FM_GlobalData.ChildCurrentCC = CmdArgs->CommandCode;
        -:  452:
        4:  453:    OS_Status = OS_remove(CmdArgs->Source1);
        -:  454:
        4:  455:    if (OS_Status != OS_SUCCESS)
        -:  456:    {
        1:  457:        FM_GlobalData.ChildCmdErrCounter++;
        -:  458:
        -:  459:        /* Send command failure event (error) */
        1:  460:        CFE_EVS_SendEvent(FM_DELETE_OS_ERR_EID, CFE_EVS_ERROR,
        -:  461:           "%s error: OS_remove failed: result = %d, file = %s",
        -:  462:            CmdText, (int)OS_Status, CmdArgs->Source1);
        -:  463:    }
        -:  464:    else
        -:  465:    {
        3:  466:        FM_GlobalData.ChildCmdCounter++;
        -:  467:
        3:  468:        if (CmdArgs->CommandCode != FM_DELETE_INT_CC)
        -:  469:        {
        -:  470:            /* Send command completion event (info) */
        2:  471:            CFE_EVS_SendEvent(FM_DELETE_CMD_EID, CFE_EVS_DEBUG,
        -:  472:               "%s command: file = %s", CmdText, CmdArgs->Source1);
        -:  473:        }
        -:  474:    }
        -:  475:
        -:  476:    /* Report previous child task activity */
        4:  477:    FM_GlobalData.ChildPreviousCC = CmdArgs->CommandCode;
        4:  478:    FM_GlobalData.ChildCurrentCC = 0;
        -:  479:
        4:  480:    return;
        -:  481:
        -:  482:} /* End of FM_ChildDeleteCmd() */
        -:  483:
        -:  484:
        -:  485:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  486:/*                                                                 */
        -:  487:/* FM child task command handler -- Delete All Files               */
        -:  488:/*                                                                 */
        -:  489:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  490:
        9:  491:void FM_ChildDeleteAllCmd(FM_ChildQueueEntry_t *CmdArgs)
        -:  492:{
        9:  493:    char        *CmdText = "Delete All Files";
        -:  494:    char        *Directory;
        -:  495:    char        *DirWithSep;
        -:  496:    os_dirp_t    DirPtr;
        -:  497:    os_dirent_t *DirEntry;
        -:  498:    int32        OS_Status;
        -:  499:    uint32       FilenameState;
        -:  500:    uint32       NameLength;
        9:  501:    uint32       DeleteCount = 0;
        9:  502:    uint32       FilesNotDeletedCount = 0;
        9:  503:    uint32       DirectoriesSkippedCount = 0;
        -:  504:    char         Filename[OS_MAX_PATH_LEN];
        -:  505:
        -:  506:    /* Report current child task activity */
        9:  507:    FM_GlobalData.ChildCurrentCC = CmdArgs->CommandCode;
        -:  508:
        -:  509:    /*
        -:  510:    ** Command argument useage for this command:
        -:  511:    **
        -:  512:    **  CmdArgs->CommandCode = FM_DELETE_ALL_CC
        -:  513:    **  CmdArgs->Source1     = directory name
        -:  514:    **  CmdArgs->Source2     = directory name plus separator
        -:  515:    */
        9:  516:    Directory  = CmdArgs->Source1;
        9:  517:    DirWithSep = CmdArgs->Source2;
        -:  518:
        -:  519:    /* Open directory so that we can read from it */
        9:  520:    DirPtr = OS_opendir(Directory);
        -:  521:
        9:  522:    if (DirPtr == NULL)
        -:  523:    {
        2:  524:        FM_GlobalData.ChildCmdErrCounter++;
        -:  525:
        -:  526:        /* Send command failure event (error) */
        2:  527:        CFE_EVS_SendEvent(FM_DELETE_ALL_OS_ERR_EID, CFE_EVS_ERROR,
        -:  528:           "%s error: OS_opendir failed: dir = %s",
        -:  529:            CmdText, Directory);
        -:  530:    }
        -:  531:    else
        -:  532:    {
        -:  533:        /* Read each directory entry and delete the files */
       21:  534:        while ((DirEntry = OS_readdir(DirPtr)) != NULL )
        -:  535:        {
        -:  536:            /* 
        -:  537:            ** Ignore the "." and ".." directory entries 
        -:  538:            */
       14:  539:            if ((strcmp(OS_DIRENTRY_NAME(*DirEntry), FM_THIS_DIRECTORY) != 0) &&
        7:  540:                (strcmp(OS_DIRENTRY_NAME(*DirEntry), FM_PARENT_DIRECTORY) != 0))
        -:  541:            {
        -:  542:                /* Construct full path filename */
        7:  543:                NameLength = strlen(DirWithSep) + strlen(OS_DIRENTRY_NAME(*DirEntry));
        -:  544:
        7:  545:                if (NameLength >= OS_MAX_PATH_LEN)
        -:  546:                {
        1:  547:                   FilesNotDeletedCount++;
        -:  548:                }
        -:  549:                else
        -:  550:                {
        -:  551:                    /* Note: Directory name already has trailing "/" appended */
        6:  552:                    strcpy(Filename, DirWithSep);
        6:  553:                    strcat(Filename, OS_DIRENTRY_NAME(*DirEntry));
        -:  554:
        -:  555:                    /* What kind of directory entry is this? */
        6:  556:                    FilenameState = FM_GetFilenameState(Filename, OS_MAX_PATH_LEN, FALSE);
        -:  557:
        6:  558:                    if (FilenameState == FM_NAME_IS_INVALID)
        -:  559:                    {
        1:  560:                        FilesNotDeletedCount++;
        -:  561:                    }
        5:  562:                    else if (FilenameState == FM_NAME_IS_NOT_IN_USE)
        -:  563:                    {
        -:  564:                        /* This result is very unlikely - the */
        -:  565:                        /*   name existed a moment ago when   */
        -:  566:                        /*   the directory entry was read but */
        -:  567:                        /*   now the call to OS_stat() failed */
        -:  568:                        /*   implying that the entry is gone  */
        1:  569:                        FilesNotDeletedCount++;
        -:  570:                    }
        4:  571:                    else if (FilenameState == FM_NAME_IS_DIRECTORY)
        -:  572:                    {
        1:  573:                        DirectoriesSkippedCount++;
        -:  574:                    }
        3:  575:                    else if (FilenameState == FM_NAME_IS_FILE_OPEN)
        -:  576:                    {
        1:  577:                       FilesNotDeletedCount++;
        -:  578:                    }
        2:  579:                    else if (FilenameState == FM_NAME_IS_FILE_CLOSED)
        -:  580:                    {
        2:  581:                        if ((OS_Status = OS_remove(Filename)) == OS_SUCCESS)
        -:  582:                        {
        -:  583:                            /*
        -:  584:                            ** After deleting the file, rewind the directory
        -:  585:                            ** to keep the file system from getting confused
        -:  586:                            */
        1:  587:                            OS_rewinddir(DirPtr);
        -:  588:
        -:  589:                            /* Increment delete count */
        1:  590:                            DeleteCount++;
        -:  591:                        }
        -:  592:                        else
        -:  593:                        {
        1:  594:                            FilesNotDeletedCount++;
        -:  595:                        }
        -:  596:                    }
        -:  597:                }
        -:  598:            } /* end if "." or ".." directory entries */
        -:  599:        } /* End while OS_readdir */
        -:  600:
        7:  601:        OS_closedir(DirPtr);
        -:  602:       
        -:  603:        /* Send command completion event (info) */
        7:  604:        CFE_EVS_SendEvent(FM_DELETE_ALL_CMD_EID, CFE_EVS_DEBUG,
        -:  605:                          "%s command: deleted %d files: dir = %s",
        -:  606:                          CmdText, (int)DeleteCount, Directory);
        7:  607:        FM_GlobalData.ChildCmdCounter++;
        -:  608:
        7:  609:        if ( FilesNotDeletedCount > 0 )
        -:  610:        {
        -:  611:           /* If errors occured, report generic event(s) */
        5:  612:           CFE_EVS_SendEvent(FM_DELETE_ALL_WARNING_EID, CFE_EVS_INFORMATION,
        -:  613:           "%s command: one or more files could not be deleted. Files may be open : dir = %s",
        -:  614:            CmdText, Directory);
        5:  615:           FM_GlobalData.ChildCmdWarnCounter++;
        -:  616:        }
        -:  617:
        7:  618:        if ( DirectoriesSkippedCount > 0 )
        -:  619:        {
        -:  620:           /* If errors occured, report generic event(s) */
        1:  621:           CFE_EVS_SendEvent(FM_DELETE_ALL_WARNING_EID, CFE_EVS_INFORMATION,
        -:  622:           "%s command: one or more directories skipped : dir = %s",
        -:  623:            CmdText, Directory);
        1:  624:           FM_GlobalData.ChildCmdWarnCounter++;
        -:  625:        }
        -:  626:
        -:  627:    } /* end if DirPtr == NULL */
        -:  628:
        -:  629:    /* Report previous child task activity */
        9:  630:    FM_GlobalData.ChildPreviousCC = CmdArgs->CommandCode;
        9:  631:    FM_GlobalData.ChildCurrentCC = 0;
        -:  632:
        9:  633:    return;
        -:  634:
        -:  635:} /* End of FM_ChildDeleteAllCmd() */
        -:  636:
        -:  637:
        -:  638:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  639:/*                                                                 */
        -:  640:/* FM child task command handler -- Decompress File                */
        -:  641:/*                                                                 */
        -:  642:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  643:
        3:  644:void FM_ChildDecompressCmd(FM_ChildQueueEntry_t *CmdArgs)
        -:  645:{
        3:  646:    char    *CmdText = "Decompress File";
        -:  647:    int32    CFE_Status;
        -:  648:
        -:  649:    /* Report current child task activity */
        3:  650:    FM_GlobalData.ChildCurrentCC = CmdArgs->CommandCode;
        -:  651:
        -:  652:    /* Decompress source file into target file */
        3:  653:    CFE_Status = CFE_FS_Decompress(CmdArgs->Source1, CmdArgs->Target);
        -:  654:
        3:  655:    if (CFE_Status != CFE_SUCCESS)
        -:  656:    {
        1:  657:        FM_GlobalData.ChildCmdErrCounter++;
        -:  658:
        -:  659:        /* Send command failure event (error) */
        1:  660:        CFE_EVS_SendEvent(FM_DECOM_CFE_ERR_EID, CFE_EVS_ERROR,
        -:  661:           "%s error: CFE_FS_Decompress failed: result = %d, src = %s, tgt = %s",
        -:  662:            CmdText, (int)CFE_Status, CmdArgs->Source1, CmdArgs->Target);
        -:  663:    }
        -:  664:    else
        -:  665:    {
        2:  666:        FM_GlobalData.ChildCmdCounter++;
        -:  667:
        -:  668:        /* Send command completion event (info) */
        2:  669:        CFE_EVS_SendEvent(FM_DECOM_CMD_EID, CFE_EVS_DEBUG,
        -:  670:           "%s command: src = %s, tgt = %s",
        -:  671:            CmdText, CmdArgs->Source1, CmdArgs->Target);
        -:  672:    }
        -:  673:
        -:  674:    /* Report previous child task activity */
        3:  675:    FM_GlobalData.ChildPreviousCC = CmdArgs->CommandCode;
        3:  676:    FM_GlobalData.ChildCurrentCC = 0;
        -:  677:
        3:  678:    return;
        -:  679:
        -:  680:} /* End of FM_ChildDecompressCmd() */
        -:  681:
        -:  682:
        -:  683:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  684:/*                                                                 */
        -:  685:/* FM child task command handler -- Concatenate Files              */
        -:  686:/*                                                                 */
        -:  687:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  688:
        8:  689:void FM_ChildConcatCmd(FM_ChildQueueEntry_t *CmdArgs)
        -:  690:{
        8:  691:    char       *CmdText = "Concat Files";
        8:  692:    boolean     ConcatResult = FALSE;
        8:  693:    boolean     CopyInProgress = FALSE;
        8:  694:    boolean     CreatedTgtFile = FALSE;
        8:  695:    boolean     OpenedSource2 = FALSE;
        8:  696:    boolean     OpenedTgtFile = FALSE;
        -:  697:    int32       LoopCount;
        -:  698:    int32       OS_Status;
        -:  699:    int32       FileHandleSrc;
        -:  700:    int32       FileHandleTgt;
        -:  701:    int32       BytesRead;
        -:  702:    int32       BytesWritten;
        -:  703:
        -:  704:    /* Report current child task activity */
        8:  705:    FM_GlobalData.ChildCurrentCC = CmdArgs->CommandCode;
        -:  706:
        -:  707:    /* Copy source file #1 to the target file */
        8:  708:    OS_Status = OS_cp(CmdArgs->Source1, CmdArgs->Target);
        -:  709:
        8:  710:    if (OS_Status != OS_SUCCESS)
        -:  711:    {
        1:  712:        FM_GlobalData.ChildCmdErrCounter++;
        -:  713:
        -:  714:        /* Send command failure event (error) */
        1:  715:        CFE_EVS_SendEvent(FM_CONCAT_OS_ERR_EID, CFE_EVS_ERROR,
        -:  716:           "%s error: OS_cp failed: result = %d, src = %s, tgt = %s",
        -:  717:            CmdText, (int)OS_Status, CmdArgs->Source1, CmdArgs->Target);
        -:  718:    }
        -:  719:    else
        -:  720:    {
        7:  721:        CreatedTgtFile = TRUE;
        -:  722:    }
        -:  723:
        -:  724:    /* Open source file #2 */
        8:  725:    if (CreatedTgtFile)
        -:  726:    {
        7:  727:        FileHandleSrc = OS_open(CmdArgs->Source2, OS_READ_ONLY, 0);
        -:  728:
        7:  729:        if (FileHandleSrc < 0)
        -:  730:        {
        1:  731:            FM_GlobalData.ChildCmdErrCounter++;
        -:  732:
        -:  733:            /* Send command failure event (error) */
        1:  734:            CFE_EVS_SendEvent(FM_CONCAT_OS_ERR_EID, CFE_EVS_ERROR,
        -:  735:               "%s error: OS_open failed: result = %d, src2 = %s",
        -:  736:                CmdText, (int)FileHandleSrc, CmdArgs->Source2);
        -:  737:        }
        -:  738:        else
        -:  739:        {
        6:  740:            OpenedSource2 = TRUE;
        -:  741:        }
        -:  742:    }
        -:  743:
        -:  744:    /* Open target file */
        8:  745:    if (OpenedSource2)
        -:  746:    {
        6:  747:        FileHandleTgt = OS_open(CmdArgs->Target, OS_READ_WRITE, 0);
        -:  748:
        6:  749:        if (FileHandleTgt < 0)
        -:  750:        {
        1:  751:            FM_GlobalData.ChildCmdErrCounter++;
        -:  752:
        -:  753:            /* Send command failure event (error) */
        1:  754:            CFE_EVS_SendEvent(FM_CONCAT_OS_ERR_EID, CFE_EVS_ERROR,
        -:  755:               "%s error: OS_open failed: result = %d, tgt = %s",
        -:  756:                CmdText, (int)FileHandleTgt, CmdArgs->Target);
        -:  757:        }
        -:  758:        else
        -:  759:        {
        5:  760:            OpenedTgtFile = TRUE;
        -:  761:        }
        -:  762:    }
        -:  763:
        -:  764:    /* Append source file #2 to target file */
        8:  765:    if (OpenedTgtFile)
        -:  766:    {
        -:  767:        /* Seek to end of target file */
        5:  768:        OS_lseek(FileHandleTgt, 0, OS_SEEK_END);
        5:  769:        CopyInProgress = TRUE;
        5:  770:        LoopCount = 0;
        -:  771:
       31:  772:        while (CopyInProgress)
        -:  773:        {
       21:  774:            BytesRead = OS_read(FileHandleSrc, FM_GlobalData.ChildBuffer,
        -:  775:                                FM_CHILD_FILE_BLOCK_SIZE);
        -:  776:
       21:  777:            if (BytesRead == 0)
        -:  778:            {
        -:  779:                /* Success - finished reading source file #2 */
        3:  780:                CopyInProgress = FALSE;
        3:  781:                ConcatResult = TRUE;
        -:  782:            }
       18:  783:            else if (BytesRead < 0)
        -:  784:            {
        1:  785:                CopyInProgress = FALSE;
        1:  786:                FM_GlobalData.ChildCmdErrCounter++;
        -:  787:
        -:  788:                /* Send command failure event (error) */
        1:  789:                CFE_EVS_SendEvent(FM_CONCAT_OS_ERR_EID, CFE_EVS_ERROR,
        -:  790:                   "%s error: OS_read failed: result = %d, file = %s",
        -:  791:                    CmdText, (int)BytesRead, CmdArgs->Source2);
        -:  792:            }
        -:  793:            else
        -:  794:            {
        -:  795:                /* Write source file #2 to target file */
       17:  796:                BytesWritten = OS_write(FileHandleTgt, FM_GlobalData.ChildBuffer, BytesRead);
        -:  797:
       17:  798:                if (BytesWritten != BytesRead)
        -:  799:                {
        1:  800:                    CopyInProgress = FALSE;
        1:  801:                    FM_GlobalData.ChildCmdErrCounter++;
        -:  802:
        -:  803:                    /* Send command failure event (error) */
        1:  804:                    CFE_EVS_SendEvent(FM_CONCAT_OS_ERR_EID, CFE_EVS_ERROR,
        -:  805:                       "%s error: OS_write failed: result = %d, expected = %d",
        -:  806:                        CmdText, (int)BytesWritten, (int)BytesRead);
        -:  807:                }
        -:  808:            }
        -:  809:
        -:  810:            /* Avoid CPU hogging */
       21:  811:            if (CopyInProgress)
        -:  812:            {
       16:  813:                LoopCount++;
       16:  814:                if (LoopCount == FM_CHILD_FILE_LOOP_COUNT)
        -:  815:                {
        -:  816:                    /* Give up the CPU */
        1:  817:                    CFE_ES_PerfLogExit(FM_CHILD_TASK_PERF_ID);
        1:  818:                    OS_TaskDelay(FM_CHILD_FILE_SLEEP_MS);
        1:  819:                    CFE_ES_PerfLogEntry(FM_CHILD_TASK_PERF_ID);
        1:  820:                    LoopCount = 0;
        -:  821:                }
        -:  822:            }
        -:  823:        }
        -:  824:    }
        -:  825:
        8:  826:    if (OpenedTgtFile)
        -:  827:    {
        -:  828:        /* Close target file */
        5:  829:        OS_close(FileHandleTgt);
        -:  830:    }
        -:  831:
        8:  832:    if (OpenedSource2)
        -:  833:    {
        -:  834:        /* Close source file #2 */
        6:  835:        OS_close(FileHandleSrc);
        -:  836:    }
        -:  837:
        8:  838:    if ((CreatedTgtFile == TRUE) && (ConcatResult == FALSE))
        -:  839:    {
        -:  840:        /* Remove partial target file after concat error */
        4:  841:        OS_remove(CmdArgs->Target);
        -:  842:    }
        -:  843:
        8:  844:    if (ConcatResult == TRUE)
        -:  845:    {
        3:  846:        FM_GlobalData.ChildCmdCounter++;
        -:  847:
        -:  848:        /* Send command completion event (info) */
        3:  849:        CFE_EVS_SendEvent(FM_CONCAT_CMD_EID, CFE_EVS_DEBUG,
        -:  850:           "%s command: src1 = %s, src2 = %s, tgt = %s",
        -:  851:            CmdText, CmdArgs->Source1, CmdArgs->Source2, CmdArgs->Target);
        -:  852:    }
        -:  853:
        -:  854:    /* Report previous child task activity */
        8:  855:    FM_GlobalData.ChildPreviousCC = CmdArgs->CommandCode;
        8:  856:    FM_GlobalData.ChildCurrentCC = 0;
        -:  857:
        8:  858:    return;
        -:  859:
        -:  860:} /* End of FM_ChildConcatCmd() */
        -:  861:
        -:  862:
        -:  863:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  864:/*                                                                 */
        -:  865:/* FM child task command handler -- Get File Info                  */
        -:  866:/*                                                                 */
        -:  867:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  868:
        8:  869:void FM_ChildFileInfoCmd(FM_ChildQueueEntry_t *CmdArgs)
        -:  870:{
        8:  871:    char  *CmdText = "Get File Info";
        8:  872:    boolean GettingCRC = FALSE;
        8:  873:    uint32 CurrentCRC = 0;
        8:  874:    int32  LoopCount = 0;
        -:  875:    int32  BytesRead;
        -:  876:    int32  FileHandle;
        -:  877:
        -:  878:    /* Report current child task activity */
        8:  879:    FM_GlobalData.ChildCurrentCC = CmdArgs->CommandCode;
        -:  880:
        -:  881:    /*
        -:  882:    ** Command argument useage for this command:
        -:  883:    **
        -:  884:    **  CmdArgs->CommandCode   = FM_GET_DIR_FILE_CC
        -:  885:    **  CmdArgs->Source1       = name of directory or file
        -:  886:    **  CmdArgs->FileInfoState = state of directory or file
        -:  887:    **  CmdArgs->FileInfoSize  = file size, else zero
        -:  888:    **  CmdArgs->FileInfoTime  = last modify time
        -:  889:    */
        -:  890:
        -:  891:    /* Initialize file info packet (set all data to zero) */
        8:  892:    CFE_SB_InitMsg(&FM_GlobalData.FileInfoPkt, FM_FILE_INFO_TLM_MID,
        -:  893:                   sizeof(FM_FileInfoPkt_t), TRUE);
        -:  894:
        -:  895:    /* Report directory or filename state, name, size and time */
        8:  896:    FM_GlobalData.FileInfoPkt.FileStatus = (uint8) CmdArgs->FileInfoState;
        8:  897:    strcpy(FM_GlobalData.FileInfoPkt.Filename, CmdArgs->Source1);
        -:  898:
        8:  899:    FM_GlobalData.FileInfoPkt.FileSize = CmdArgs->FileInfoSize;
        8:  900:    FM_GlobalData.FileInfoPkt.LastModifiedTime = CmdArgs->FileInfoTime;
        -:  901:
        -:  902:    /* Validate CRC algorithm */
        8:  903:    if (CmdArgs->FileInfoCRC != FM_IGNORE_CRC)
        -:  904:    {
        7:  905:        if (CmdArgs->FileInfoState != FM_NAME_IS_FILE_CLOSED)
        -:  906:        {
        -:  907:            /* Can only calculate CRC for closed files */
        1:  908:            FM_GlobalData.ChildCmdWarnCounter++;
        -:  909:
        1:  910:            CFE_EVS_SendEvent(FM_GET_FILE_INFO_WARNING_EID, CFE_EVS_INFORMATION,
        -:  911:               "%s warning: unable to compute CRC: invalid file state = %d, file = %s",
        -:  912:                CmdText, (int)CmdArgs->FileInfoState, CmdArgs->Source1);
        -:  913:
        1:  914:            CmdArgs->FileInfoCRC = FM_IGNORE_CRC;
        -:  915:        }
        8:  916:        else if ((CmdArgs->FileInfoCRC != CFE_ES_CRC_8) &&
        1:  917:                 (CmdArgs->FileInfoCRC != CFE_ES_CRC_16) &&
        1:  918:                 (CmdArgs->FileInfoCRC != CFE_ES_CRC_32))
        -:  919:        {
        -:  920:            /* Can only calculate CRC using known algorithms */
        1:  921:            FM_GlobalData.ChildCmdWarnCounter++;
        -:  922:
        1:  923:            CFE_EVS_SendEvent(FM_GET_FILE_INFO_WARNING_EID, CFE_EVS_INFORMATION,
        -:  924:               "%s warning: unable to compute CRC: invalid CRC type = %d, file = %s",
        -:  925:                CmdText, (int)CmdArgs->FileInfoCRC, CmdArgs->Source1);
        -:  926:
        1:  927:            CmdArgs->FileInfoCRC = FM_IGNORE_CRC;
        -:  928:        }
        -:  929:    }
        -:  930:
        -:  931:    /* Compute CRC */
        8:  932:    if (CmdArgs->FileInfoCRC != FM_IGNORE_CRC)
        -:  933:    {
        5:  934:        FileHandle = OS_open(CmdArgs->Source1, OS_READ_ONLY, 0);
        -:  935:
        5:  936:        if (FileHandle < 0)
        -:  937:        {
        1:  938:            FM_GlobalData.ChildCmdWarnCounter++;
        -:  939:
        -:  940:            /* Send CRC failure event (warning) */
        1:  941:            CFE_EVS_SendEvent(FM_GET_FILE_INFO_WARNING_EID, CFE_EVS_ERROR,
        -:  942:               "%s warning: unable to compute CRC: OS_open result = %d, file = %s",
        -:  943:                CmdText, (int)FileHandle, CmdArgs->Source1);
        -:  944:
        1:  945:            GettingCRC = FALSE;
        -:  946:        }
        -:  947:        else
        -:  948:        {
        4:  949:            GettingCRC = TRUE;
        -:  950:        }
        -:  951:
       31:  952:        while (GettingCRC)
        -:  953:        {
       21:  954:            BytesRead = OS_read(FileHandle, FM_GlobalData.ChildBuffer,
        -:  955:                                FM_CHILD_FILE_BLOCK_SIZE);
        -:  956:
       21:  957:            if (BytesRead == 0)
        -:  958:            {
        -:  959:                /* Finished reading file */
        3:  960:                GettingCRC = FALSE;
        3:  961:                OS_close(FileHandle);
        -:  962:
        -:  963:                /* Add CRC to telemetry packet */
        3:  964:                FM_GlobalData.FileInfoPkt.CRC_Computed = TRUE;
        3:  965:                FM_GlobalData.FileInfoPkt.CRC = CurrentCRC;
        -:  966:            }
       18:  967:            else if (BytesRead < 0)
        -:  968:            {
        -:  969:                /* Error reading file */
        1:  970:                CurrentCRC = 0;
        1:  971:                GettingCRC = FALSE;
        1:  972:                OS_close(FileHandle);
        -:  973:
        -:  974:                /* Send CRC failure event (warning) */
        1:  975:                FM_GlobalData.ChildCmdWarnCounter++;
        1:  976:                CFE_EVS_SendEvent(FM_GET_FILE_INFO_WARNING_EID, CFE_EVS_INFORMATION,
        -:  977:                   "%s warning: unable to compute CRC: OS_read result = %d, file = %s",
        -:  978:                    CmdText, (int)BytesRead, CmdArgs->Source1);
        -:  979:            }
        -:  980:            else
        -:  981:            {
        -:  982:                /* Continue CRC calculation */
       17:  983:                CurrentCRC = CFE_ES_CalculateCRC(FM_GlobalData.ChildBuffer, BytesRead,
        -:  984:                                                 CurrentCRC, CmdArgs->FileInfoCRC);
        -:  985:            }
        -:  986:
        -:  987:            /* Avoid CPU hogging */
       21:  988:            if (GettingCRC)
        -:  989:            {
       17:  990:                LoopCount++;
       17:  991:                if (LoopCount == FM_CHILD_FILE_LOOP_COUNT)
        -:  992:                {
        -:  993:                    /* Give up the CPU */
        1:  994:                    CFE_ES_PerfLogExit(FM_CHILD_TASK_PERF_ID);
        1:  995:                    OS_TaskDelay(FM_CHILD_FILE_SLEEP_MS);
        1:  996:                    CFE_ES_PerfLogEntry(FM_CHILD_TASK_PERF_ID);
        1:  997:                    LoopCount = 0;
        -:  998:                }
        -:  999:            }
        -: 1000:        }
        -: 1001:
        5: 1002:        FM_GlobalData.FileInfoPkt.CRC = CurrentCRC;
        -: 1003:    }
        -: 1004:
        -: 1005:    /* Timestamp and send file info telemetry packet */
        8: 1006:    CFE_SB_TimeStampMsg((CFE_SB_Msg_t *) &FM_GlobalData.FileInfoPkt);
        8: 1007:    CFE_SB_SendMsg((CFE_SB_Msg_t *) &FM_GlobalData.FileInfoPkt);
        -: 1008:
        8: 1009:    FM_GlobalData.ChildCmdCounter++;
        -: 1010:
        -: 1011:    /* Send command completion event (debug) */
        8: 1012:    CFE_EVS_SendEvent(FM_GET_FILE_INFO_CMD_EID, CFE_EVS_DEBUG,
        -: 1013:       "%s command: file = %s", CmdText, CmdArgs->Source1);
        -: 1014:
        -: 1015:    /* Report previous child task activity */
        8: 1016:    FM_GlobalData.ChildPreviousCC = CmdArgs->CommandCode;
        8: 1017:    FM_GlobalData.ChildCurrentCC = 0;
        -: 1018:
        8: 1019:    return;
        -: 1020:
        -: 1021:} /* End of FM_ChildFileInfoCmd() */
        -: 1022:
        -: 1023:
        -: 1024:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -: 1025:/*                                                                 */
        -: 1026:/* FM child task command handler -- Create Directory               */
        -: 1027:/*                                                                 */
        -: 1028:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -: 1029:
        3: 1030:void FM_ChildCreateDirCmd(FM_ChildQueueEntry_t *CmdArgs)
        -: 1031:{
        3: 1032:    char *CmdText = "Create Directory";
        -: 1033:    int32 OS_Status;
        -: 1034:
        -: 1035:    /* Report current child task activity */
        3: 1036:    FM_GlobalData.ChildCurrentCC = CmdArgs->CommandCode;
        -: 1037:
        3: 1038:    OS_Status = OS_mkdir(CmdArgs->Source1, 0);
        -: 1039:
        3: 1040:    if (OS_Status != OS_SUCCESS)
        -: 1041:    {
        1: 1042:        FM_GlobalData.ChildCmdErrCounter++;
        -: 1043:
        -: 1044:        /* Send command failure event (error) */
        1: 1045:        CFE_EVS_SendEvent(FM_CREATE_DIR_OS_ERR_EID, CFE_EVS_ERROR,
        -: 1046:           "%s error: OS_mkdir failed: result = %d, dir = %s",
        -: 1047:            CmdText, (int)OS_Status, CmdArgs->Source1);
        -: 1048:    }
        -: 1049:    else
        -: 1050:    {
        2: 1051:        FM_GlobalData.ChildCmdCounter++;
        -: 1052:
        -: 1053:        /* Send command completion event (info) */
        2: 1054:        CFE_EVS_SendEvent(FM_CREATE_DIR_CMD_EID, CFE_EVS_DEBUG,
        -: 1055:           "%s command: src = %s", CmdText, CmdArgs->Source1);
        -: 1056:    }
        -: 1057:
        -: 1058:    /* Report previous child task activity */
        3: 1059:    FM_GlobalData.ChildPreviousCC = CmdArgs->CommandCode;
        3: 1060:    FM_GlobalData.ChildCurrentCC = 0;
        -: 1061:
        3: 1062:    return;
        -: 1063:
        -: 1064:} /* End of FM_ChildCreateDirCmd() */
        -: 1065:
        -: 1066:
        -: 1067:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -: 1068:/*                                                                 */
        -: 1069:/* FM child task command handler -- Delete Directory               */
        -: 1070:/*                                                                 */
        -: 1071:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -: 1072:
        5: 1073:void FM_ChildDeleteDirCmd(FM_ChildQueueEntry_t *CmdArgs)
        -: 1074:{
        5: 1075:    char *CmdText = "Delete Directory";
        5: 1076:    boolean RemoveTheDir = TRUE;
        -: 1077:    os_dirp_t DirPtr;
        -: 1078:    os_dirent_t *DirEntry;
        -: 1079:    int32 OS_Status;
        -: 1080:
        -: 1081:    /* Report current child task activity */
        5: 1082:    FM_GlobalData.ChildCurrentCC = CmdArgs->CommandCode;
        -: 1083:
        -: 1084:    /* Open the dir so we can see if it is empty */
        5: 1085:    DirPtr = OS_opendir(CmdArgs->Source1);
        -: 1086:
        5: 1087:    if (DirPtr == NULL)
        -: 1088:    {
        2: 1089:        CFE_EVS_SendEvent(FM_DELETE_DIR_OS_ERR_EID, CFE_EVS_ERROR,
        -: 1090:           "%s error: OS_opendir failed: dir = %s",
        -: 1091:            CmdText, CmdArgs->Source1);
        -: 1092:
        2: 1093:        RemoveTheDir = FALSE;
        2: 1094:        FM_GlobalData.ChildCmdErrCounter++;
        -: 1095:    }
        -: 1096:    else
        -: 1097:    {
        -: 1098:        /* Look for a directory entry that is not "." or ".." */
        7: 1099:        while (((DirEntry = OS_readdir(DirPtr)) != NULL) && (RemoveTheDir == TRUE))
        -: 1100:        {
        2: 1101:            if ((strcmp(OS_DIRENTRY_NAME(*DirEntry), FM_THIS_DIRECTORY) != 0) &&
        1: 1102:                (strcmp(OS_DIRENTRY_NAME(*DirEntry), FM_PARENT_DIRECTORY) != 0))
        -: 1103:            {
        1: 1104:                CFE_EVS_SendEvent(FM_DELETE_DIR_EMPTY_ERR_EID, CFE_EVS_ERROR,
        -: 1105:                   "%s error: directory is not empty: dir = %s",
        -: 1106:                    CmdText, CmdArgs->Source1);
        -: 1107:
        1: 1108:                RemoveTheDir = FALSE;
        1: 1109:                FM_GlobalData.ChildCmdErrCounter++;
        -: 1110:            }
        -: 1111:        }
        -: 1112:
        3: 1113:        OS_closedir(DirPtr);
        -: 1114:    }
        -: 1115:
        5: 1116:    if (RemoveTheDir)
        -: 1117:    {
        -: 1118:        /* Remove the directory */
        2: 1119:        OS_Status = OS_rmdir(CmdArgs->Source1);
        -: 1120:
        2: 1121:        if (OS_Status != OS_SUCCESS)
        -: 1122:        {
        -: 1123:            /* Send command failure event (error) */
        1: 1124:            CFE_EVS_SendEvent(FM_DELETE_DIR_OS_ERR_EID, CFE_EVS_ERROR,
        -: 1125:               "%s error: OS_rmdir failed: result = %d, dir = %s",
        -: 1126:                CmdText, (int)OS_Status, CmdArgs->Source1);
        -: 1127:
        1: 1128:            FM_GlobalData.ChildCmdErrCounter++;
        -: 1129:        }
        -: 1130:        else
        -: 1131:        {
        -: 1132:            /* Send command completion event (info) */
        1: 1133:            CFE_EVS_SendEvent(FM_DELETE_DIR_CMD_EID, CFE_EVS_DEBUG,
        -: 1134:               "%s command: src = %s", CmdText, CmdArgs->Source1);
        -: 1135:
        1: 1136:            FM_GlobalData.ChildCmdCounter++;
        -: 1137:        }
        -: 1138:    }
        -: 1139:
        -: 1140:    /* Report previous child task activity */
        5: 1141:    FM_GlobalData.ChildPreviousCC = CmdArgs->CommandCode;
        5: 1142:    FM_GlobalData.ChildCurrentCC = 0;
        -: 1143:
        5: 1144:    return;
        -: 1145:
        -: 1146:
        -: 1147:} /* End of FM_ChildDeleteDirCmd() */
        -: 1148:
        -: 1149:
        -: 1150:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -: 1151:/*                                                                 */
        -: 1152:/* FM child task command handler -- Get Directory List (to file)   */
        -: 1153:/*                                                                 */
        -: 1154:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -: 1155:
        3: 1156:void FM_ChildDirListFileCmd(FM_ChildQueueEntry_t *CmdArgs)
        -: 1157:{
        3: 1158:    char     *CmdText = "Directory List to File";
        -: 1159:    boolean   Result;
        -: 1160:    int32     FileHandle;
        -: 1161:    os_dirp_t DirPtr;
        -: 1162:
        -: 1163:    /* Report current child task activity */
        3: 1164:    FM_GlobalData.ChildCurrentCC = CmdArgs->CommandCode;
        -: 1165:
        -: 1166:    /*
        -: 1167:    ** Command argument useage for this command:
        -: 1168:    **
        -: 1169:    **  CmdArgs->CommandCode = FM_GET_DIR_FILE_CC
        -: 1170:    **  CmdArgs->Source1     = directory name
        -: 1171:    **  CmdArgs->Source2     = directory name plus separator
        -: 1172:    **  CmdArgs->Target      = output filename
        -: 1173:    */
        -: 1174:
        -: 1175:    /* Open directory for reading directory list */
        3: 1176:    DirPtr = OS_opendir(CmdArgs->Source1);
        -: 1177:
        3: 1178:    if (DirPtr == NULL)
        -: 1179:    {
        2: 1180:        FM_GlobalData.ChildCmdErrCounter++;
        -: 1181:
        -: 1182:        /* Send command failure event (error) */
        2: 1183:        CFE_EVS_SendEvent(FM_GET_DIR_FILE_OS_ERR_EID, CFE_EVS_ERROR,
        -: 1184:           "%s error: OS_opendir failed: dir = %s",
        -: 1185:            CmdText, CmdArgs->Source1);
        -: 1186:    }
        -: 1187:    else
        -: 1188:    {
        -: 1189:        /* Create output file, write placeholder for statistics, etc. */
        1: 1190:        Result = FM_ChildDirListFileInit(&FileHandle, CmdArgs->Source1,
        -: 1191:                                         CmdArgs->Target);
        1: 1192:        if (Result == TRUE)
        -: 1193:        {
        -: 1194:            /* Read directory listing and write contents to output file */
        1: 1195:            FM_ChildDirListFileLoop(DirPtr, FileHandle, CmdArgs->Source1,
        1: 1196:                                    CmdArgs->Source2, CmdArgs->Target, CmdArgs->GetSizeTimeMode);
        -: 1197:
        -: 1198:            /* Close output file */
        1: 1199:            OS_close(FileHandle);
        -: 1200:        }
        -: 1201:
        -: 1202:        /* Close directory list access handle */
        1: 1203:        OS_closedir(DirPtr);
        -: 1204:    }
        -: 1205:
        -: 1206:    /* Report previous child task activity */
        3: 1207:    FM_GlobalData.ChildPreviousCC = CmdArgs->CommandCode;
        3: 1208:    FM_GlobalData.ChildCurrentCC = 0;
        -: 1209:
        3: 1210:    return;
        -: 1211:
        -: 1212:} /* End of FM_ChildDirListFileCmd() */
        -: 1213:
        -: 1214:
        -: 1215:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -: 1216:/*                                                                 */
        -: 1217:/* FM child task command handler -- Get Directory List (to pkt)    */
        -: 1218:/*                                                                 */
        -: 1219:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -: 1220:
        4: 1221:void FM_ChildDirListPktCmd(FM_ChildQueueEntry_t *CmdArgs)
        -: 1222:{
        4: 1223:    char                     *CmdText = "Directory List to Packet";
        -: 1224:    char                      LogicalName[OS_MAX_PATH_LEN];
        -: 1225:    boolean                   StillProcessing;
        -: 1226:    os_dirp_t                 DirPtr;
        -: 1227:    os_dirent_t              *DirEntry;
        -: 1228:    int32                     ListIndex;
        -: 1229:    FM_DirListEntry_t        *ListEntry;
        -: 1230:    int32                     PathLength;
        -: 1231:    int32                     EntryLength;
        4: 1232:    int32                     FilesTillSleep = FM_CHILD_STAT_SLEEP_FILECOUNT;
        -: 1233:
        -: 1234:    /* Report current child task activity */
        4: 1235:    FM_GlobalData.ChildCurrentCC = CmdArgs->CommandCode;
        -: 1236:
        -: 1237:    /*
        -: 1238:    ** Command argument useage for this command:
        -: 1239:    **
        -: 1240:    **  CmdArgs->CommandCode   = FM_GET_DIR_PKT_CC
        -: 1241:    **  CmdArgs->Source1       = directory name
        -: 1242:    **  CmdArgs->Source2       = directory name plus separator
        -: 1243:    **  CmdArgs->DirListOffset = index of 1st reported dir entry
        -: 1244:    */
        4: 1245:    PathLength = strlen(CmdArgs->Source2);
        -: 1246:
        -: 1247:    /* Open source directory for reading directory list */
        4: 1248:    DirPtr = OS_opendir(CmdArgs->Source1);
        -: 1249:
        4: 1250:    if (DirPtr == NULL)
        -: 1251:    {
        2: 1252:        FM_GlobalData.ChildCmdErrCounter++;
        -: 1253:
        -: 1254:        /* Send command failure event (error) */
        2: 1255:        CFE_EVS_SendEvent(FM_GET_DIR_PKT_OS_ERR_EID, CFE_EVS_ERROR,
        -: 1256:           "%s error: OS_opendir failed: dir = %s",
        -: 1257:            CmdText, CmdArgs->Source1);
        -: 1258:    }
        -: 1259:    else
        -: 1260:    {
        -: 1261:        /* Initialize the directory list telemetry packet */
        2: 1262:        CFE_SB_InitMsg(&FM_GlobalData.DirListPkt, FM_DIR_LIST_TLM_MID,
        -: 1263:                        sizeof(FM_DirListPkt_t), TRUE);
        -: 1264:
        2: 1265:        strncpy(FM_GlobalData.DirListPkt.DirName, CmdArgs->Source1, OS_MAX_PATH_LEN);
        2: 1266:        FM_GlobalData.DirListPkt.FirstFile = CmdArgs->DirListOffset;
        -: 1267:
        2: 1268:        StillProcessing = TRUE;
        8: 1269:        while (StillProcessing == TRUE)
        -: 1270:        {
        -: 1271:            /* Read next directory entry */
        4: 1272:            DirEntry = OS_readdir(DirPtr);
        -: 1273:
        4: 1274:            if (DirEntry == NULL)
        -: 1275:            {
        -: 1276:                /* Stop reading directory - no more entries */
        2: 1277:                StillProcessing = FALSE;
        -: 1278:            }
        4: 1279:            else if ((strcmp(OS_DIRENTRY_NAME(*DirEntry), FM_THIS_DIRECTORY) != 0) &&
        2: 1280:                     (strcmp(OS_DIRENTRY_NAME(*DirEntry), FM_PARENT_DIRECTORY) != 0))
        -: 1281:            {
        -: 1282:                /* Do not count the "." and ".." directory entries */
        2: 1283:                FM_GlobalData.DirListPkt.TotalFiles++;
        -: 1284:
        -: 1285:                /* Start collecting directory entries at command specified offset */
        -: 1286:                /* Stop collecting directory entries when telemetry packet is full */
        4: 1287:                if ((FM_GlobalData.DirListPkt.TotalFiles > FM_GlobalData.DirListPkt.FirstFile) &&
        2: 1288:                    (FM_GlobalData.DirListPkt.PacketFiles < FM_DIR_LIST_PKT_ENTRIES))
        -: 1289:                {
        -: 1290:                    /* Create a shorthand access to the packet list entry */
        2: 1291:                    ListIndex = FM_GlobalData.DirListPkt.PacketFiles;
        2: 1292:                    ListEntry = &FM_GlobalData.DirListPkt.FileList[ListIndex];
        -: 1293:
        2: 1294:                    EntryLength = strlen(OS_DIRENTRY_NAME(*DirEntry));
        -: 1295:
        -: 1296:                    /* Verify combined directory plus filename length */
        5: 1297:                    if ((EntryLength < sizeof(ListEntry->EntryName)) &&
        2: 1298:                       ((PathLength + EntryLength) < OS_MAX_PATH_LEN))
        -: 1299:                    {
        -: 1300:                        /* Add filename to directory listing telemetry packet */
        1: 1301:                        strcpy(ListEntry->EntryName, OS_DIRENTRY_NAME(*DirEntry));
        -: 1302:
        -: 1303:                        /* Build filename - Directory already has path separator */
        1: 1304:                        strcpy(LogicalName, CmdArgs->Source2);
        1: 1305:                        strcat(LogicalName, OS_DIRENTRY_NAME(*DirEntry));
        -: 1306:
        1: 1307:                        FM_ChildSleepStat(LogicalName, ListEntry, &FilesTillSleep, CmdArgs->GetSizeTimeMode);
        -: 1308:
        -: 1309:                        /* Add another entry to the telemetry packet */
        1: 1310:                        FM_GlobalData.DirListPkt.PacketFiles++;
        -: 1311:                    }
        -: 1312:                    else
        -: 1313:                    {
        1: 1314:                        FM_GlobalData.ChildCmdWarnCounter++;
        -: 1315:
        -: 1316:                        /* Send command warning event (info) */
        1: 1317:                        CFE_EVS_SendEvent(FM_GET_DIR_PKT_WARNING_EID, CFE_EVS_INFORMATION,
        -: 1318:                           "%s warning: dir + entry is too long: dir = %s, entry = %s",
        -: 1319:                            CmdText, CmdArgs->Source2, OS_DIRENTRY_NAME(*DirEntry));
        -: 1320:                    }
        -: 1321:                }
        -: 1322:            }
        -: 1323:        }
        -: 1324:
        2: 1325:        OS_closedir(DirPtr);
        -: 1326:
        -: 1327:        /* Timestamp and send directory listing telemetry packet */
        2: 1328:        CFE_SB_TimeStampMsg((CFE_SB_Msg_t *) &FM_GlobalData.DirListPkt);
        2: 1329:        CFE_SB_SendMsg((CFE_SB_Msg_t *) &FM_GlobalData.DirListPkt);
        -: 1330:
        -: 1331:        /* Send command completion event (info) */
        2: 1332:        CFE_EVS_SendEvent(FM_GET_DIR_PKT_CMD_EID, CFE_EVS_DEBUG,
        -: 1333:           "%s command: offset = %d, dir = %s",
        -: 1334:            CmdText, (int)CmdArgs->DirListOffset, CmdArgs->Source1);
        -: 1335:
        2: 1336:        FM_GlobalData.ChildCmdCounter++;
        -: 1337:    }
        -: 1338:
        -: 1339:    /* Report previous child task activity */
        4: 1340:    FM_GlobalData.ChildPreviousCC = CmdArgs->CommandCode;
        4: 1341:    FM_GlobalData.ChildCurrentCC = 0;
        -: 1342:
        4: 1343:    return;
        -: 1344:
        -: 1345:} /* End of FM_ChildDirListPktCmd() */
        -: 1346:
        -: 1347:
        -: 1348:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -: 1349:/*                                                                 */
        -: 1350:/* FM child task command handler -- Set File Permissions           */
        -: 1351:/*                                                                 */
        -: 1352:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        3: 1353:void FM_ChildSetPermissionsCmd(FM_ChildQueueEntry_t *CmdArgs)
        -: 1354:{
        -: 1355:    int32 OS_Status;
        3: 1356:    char *CmdText = "Set Permissions";
        -: 1357:    
        3: 1358:    OS_Status = OS_chmod(CmdArgs->Source1, CmdArgs->Mode);
        -: 1359:
        3: 1360:    if (OS_Status == OS_SUCCESS)
        -: 1361:    {
        2: 1362:        FM_GlobalData.ChildCmdCounter++;
        -: 1363:
        -: 1364:        /* Send command completion event (info) */
        2: 1365:        CFE_EVS_SendEvent(FM_SET_PERM_CMD_EID, CFE_EVS_DEBUG,
        -: 1366:           "%s command: file = %s, access = %d", 
        -: 1367:                CmdText, CmdArgs->Source1, (int)CmdArgs->Mode);
        -: 1368:    }
        -: 1369:    else
        -: 1370:    {
        1: 1371:        FM_GlobalData.ChildCmdErrCounter++;
        -: 1372:
        -: 1373:        /* Send OS error message */
        1: 1374:        CFE_EVS_SendEvent(FM_SET_PERM_OS_ERR_EID, CFE_EVS_ERROR,
        -: 1375:           "%s command: OS_chmod error, RC=0x%08X, file = %s, access = %d", 
        -: 1376:                CmdText, (unsigned int)OS_Status, CmdArgs->Source1, (int)CmdArgs->Mode);
        -: 1377:    }
        -: 1378:    
        3: 1379:    return;
        -: 1380:}  /* End of FM_ChildSetPermissionsCmd() */
        -: 1381:
        -: 1382:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -: 1383:/*                                                                 */
        -: 1384:/* FM child task utility function -- create dir list output file   */
        -: 1385:/*                                                                 */
        -: 1386:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -: 1387:
        5: 1388:boolean FM_ChildDirListFileInit(int32 *FileHandlePtr, char *Directory, char *Filename)
        -: 1389:{
        5: 1390:    char  *CmdText  = "Directory List to File";
        5: 1391:    boolean            CommandResult = TRUE;
        -: 1392:    CFE_FS_Header_t    FileHeader;
        -: 1393:    int32              FileHandle;
        -: 1394:    int32              BytesWritten;
        -: 1395:
        -: 1396:    /* Initialize the standard cFE File Header for the Directory Listing File */
        5: 1397:    CFE_PSP_MemSet(&FileHeader, 0, sizeof(CFE_FS_Header_t));
        5: 1398:    FileHeader.SubType = FM_DIR_LIST_FILE_SUBTYPE;
        5: 1399:    strcpy(FileHeader.Description, CmdText);
        -: 1400:
        -: 1401:    /* Create directory listing output file */
        5: 1402:    FileHandle = OS_creat(Filename, OS_READ_WRITE);
        5: 1403:    if (FileHandle >= OS_SUCCESS)
        -: 1404:    {
        -: 1405:        /* Write the standard CFE file header */
        4: 1406:        BytesWritten = CFE_FS_WriteHeader(FileHandle, &FileHeader);
        4: 1407:        if (BytesWritten == sizeof(CFE_FS_Header_t))
        -: 1408:        {
        -: 1409:            /* Initialize directory statistics structure */
        3: 1410:            CFE_PSP_MemSet(&FM_GlobalData.DirListFileStats, 0, sizeof(FM_DirListFileStats_t));
        3: 1411:            strcpy(FM_GlobalData.DirListFileStats.DirName, Directory);
        -: 1412:
        -: 1413:            /* Write blank FM directory statistics structure as a place holder */
        3: 1414:            BytesWritten = OS_write(FileHandle, &FM_GlobalData.DirListFileStats, sizeof(FM_DirListFileStats_t));
        3: 1415:            if (BytesWritten == sizeof(FM_DirListFileStats_t))
        -: 1416:            {
        -: 1417:                /* Return output file handle */
        2: 1418:                *FileHandlePtr = FileHandle;
        -: 1419:            }
        -: 1420:            else
        -: 1421:            {
        1: 1422:                CommandResult = FALSE;
        1: 1423:                FM_GlobalData.ChildCmdErrCounter++;
        -: 1424:
        -: 1425:                /* Send command failure event (error) */
        1: 1426:                CFE_EVS_SendEvent(FM_GET_DIR_FILE_OS_ERR_EID, CFE_EVS_ERROR,
        -: 1427:                   "%s error: OS_write blank stats failed: result = %d, expected = %d",
        -: 1428:                    CmdText, (int)BytesWritten, sizeof(FM_DirListFileStats_t));
        -: 1429:            }
        -: 1430:        }
        -: 1431:        else
        -: 1432:        {
        1: 1433:            CommandResult = FALSE;
        1: 1434:            FM_GlobalData.ChildCmdErrCounter++;
        -: 1435:
        -: 1436:            /* Send command failure event (error) */
        1: 1437:            CFE_EVS_SendEvent(FM_GET_DIR_FILE_OS_ERR_EID, CFE_EVS_ERROR,
        -: 1438:               "%s error: CFE_FS_WriteHeader failed: result = %d, expected = %d",
        -: 1439:                CmdText, (int)BytesWritten, sizeof(CFE_FS_Header_t));
        -: 1440:        }
        -: 1441:
        -: 1442:        /* Close output file after write error */
        4: 1443:        if (CommandResult == FALSE)
        -: 1444:        {
        2: 1445:            OS_close(FileHandle);
        -: 1446:        }
        -: 1447:    }
        -: 1448:    else
        -: 1449:    {
        1: 1450:        CommandResult = FALSE;
        1: 1451:        FM_GlobalData.ChildCmdErrCounter++;
        -: 1452:
        -: 1453:        /* Send command failure event (error) */
        1: 1454:        CFE_EVS_SendEvent(FM_GET_DIR_FILE_OS_ERR_EID, CFE_EVS_ERROR,
        -: 1455:           "%s error: OS_creat failed: result = %d, file = %s",
        -: 1456:            CmdText, (int)FileHandle, Filename);
        -: 1457:    }
        -: 1458:
        5: 1459:    return(CommandResult);
        -: 1460:
        -: 1461:} /* End FM_ChildDirListFileInit */
        -: 1462:
        -: 1463:
        -: 1464:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -: 1465:/*                                                                 */
        -: 1466:/* FM child task utility function -- write to dir list output file */
        -: 1467:/*                                                                 */
        -: 1468:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -: 1469:
        5: 1470:void FM_ChildDirListFileLoop(os_dirp_t DirPtr, int32 FileHandle,
        -: 1471:                             char *Directory, char *DirWithSep, char *Filename, uint8 getSizeTimeMode)
        -: 1472:{
        5: 1473:    char  *CmdText = "Directory List to File";
        5: 1474:    int32    WriteLength = sizeof(FM_DirListEntry_t);
        5: 1475:    boolean  ReadingDirectory = TRUE;
        5: 1476:    boolean  CommandResult = TRUE;
        5: 1477:    uint32   DirEntries = 0;
        5: 1478:    uint32   FileEntries = 0;
        -: 1479:    int32    EntryLength;
        -: 1480:    int32    PathLength;
        -: 1481:    int32    BytesWritten;
        5: 1482:    int32    FilesTillSleep = FM_CHILD_STAT_SLEEP_FILECOUNT;
        -: 1483:    char     TempName[OS_MAX_PATH_LEN];
        -: 1484:    os_dirent_t *DirEntry;
        -: 1485:    FM_DirListEntry_t  DirListData;
        -: 1486:
        -: 1487:
        5: 1488:    PathLength = strlen(DirWithSep);
        -: 1489:
        -: 1490:    /* Until end of directory entries or output file write error */
       18: 1491:    while ((CommandResult == TRUE) && (ReadingDirectory == TRUE))
        -: 1492:    {
        8: 1493:        DirEntry = OS_readdir(DirPtr);
        -: 1494:
        -: 1495:        /* Normal loop end - no more directory entries */
        8: 1496:        if (DirEntry == NULL)
        -: 1497:        {
        4: 1498:            ReadingDirectory = FALSE;
        -: 1499:        }
        8: 1500:        else if ((strcmp(OS_DIRENTRY_NAME(*DirEntry), FM_THIS_DIRECTORY) != 0) &&
        4: 1501:                 (strcmp(OS_DIRENTRY_NAME(*DirEntry), FM_PARENT_DIRECTORY) != 0))
        -: 1502:        {
        -: 1503:            /* Do not count the "." and ".." files */
        4: 1504:            DirEntries++;
        -: 1505:
        -: 1506:            /* Count all files - write limited number */
        4: 1507:            if (FileEntries < FM_DIR_LIST_FILE_ENTRIES)
        -: 1508:            {
        4: 1509:                EntryLength = strlen(OS_DIRENTRY_NAME(*DirEntry));
        -: 1510:
       11: 1511:                if ((EntryLength < sizeof(DirListData.EntryName)) &&
        4: 1512:                   ((PathLength + EntryLength) < OS_MAX_PATH_LEN))
        -: 1513:                {
        -: 1514:                    /* Build qualified directory entry name */
        3: 1515:                    strcpy(TempName, DirWithSep);
        3: 1516:                    strcat(TempName, OS_DIRENTRY_NAME(*DirEntry));
        -: 1517:
        -: 1518:                    /* Populate directory list file entry */
        3: 1519:                    strcpy(DirListData.EntryName, OS_DIRENTRY_NAME(*DirEntry));
        -: 1520:
        3: 1521:                    FM_ChildSleepStat(TempName, (FM_DirListEntry_t *)&DirListData, &FilesTillSleep, getSizeTimeMode);
        -: 1522:
        -: 1523:                    /* Write directory list file entry to output file */
        3: 1524:                    BytesWritten = OS_write(FileHandle, &DirListData, WriteLength);
        -: 1525:
        3: 1526:                    if (BytesWritten == WriteLength)
        -: 1527:                    {
        2: 1528:                        FileEntries++;
        -: 1529:                    }
        -: 1530:                    else
        -: 1531:                    {
        1: 1532:                        CommandResult = FALSE;
        1: 1533:                        FM_GlobalData.ChildCmdErrCounter++;
        -: 1534:
        -: 1535:                        /* Send command failure event (error) */
        1: 1536:                        CFE_EVS_SendEvent(FM_GET_DIR_FILE_OS_ERR_EID, CFE_EVS_ERROR,
        -: 1537:                           "%s error: OS_write entry failed: result = %d, expected = %d",
        -: 1538:                            CmdText, (int)BytesWritten, (int)WriteLength);
        -: 1539:                    }
        -: 1540:                }
        -: 1541:                else
        -: 1542:                {
        1: 1543:                    FM_GlobalData.ChildCmdWarnCounter++;
        -: 1544:
        -: 1545:                    /* Send command failure event (error) */
        1: 1546:                    CFE_EVS_SendEvent(FM_GET_DIR_FILE_WARNING_EID, CFE_EVS_INFORMATION,
        -: 1547:                       "%s error: combined directory and entry name too long: dir = %s, entry = %s",
        -: 1548:                        CmdText, Directory, OS_DIRENTRY_NAME(*DirEntry));
        -: 1549:                }
        -: 1550:            }
        -: 1551:        }
        -: 1552:    }
        -: 1553:
        -: 1554:    /* Update directory statistics in output file */
        5: 1555:    if ((CommandResult == TRUE) && (DirEntries != 0))
        -: 1556:    {
        -: 1557:        /* Update entries found in directory vs entries written to file */
        3: 1558:        FM_GlobalData.DirListFileStats.DirEntries = DirEntries;
        3: 1559:        FM_GlobalData.DirListFileStats.FileEntries = FileEntries;
        -: 1560:
        -: 1561:        /* Back up to the start of the statisitics data */
        3: 1562:        OS_lseek(FileHandle, sizeof(CFE_FS_Header_t), OS_SEEK_SET);
        -: 1563:
        -: 1564:        /* Write an updated version of the statistics data */
        3: 1565:        WriteLength = sizeof(FM_DirListFileStats_t);
        3: 1566:        BytesWritten = OS_write(FileHandle, &FM_GlobalData.DirListFileStats, WriteLength);
        -: 1567:
        3: 1568:        if (BytesWritten != WriteLength)
        -: 1569:        {
        1: 1570:            CommandResult = FALSE;
        1: 1571:            FM_GlobalData.ChildCmdErrCounter++;
        -: 1572:
        -: 1573:            /* Send command failure event (error) */
        1: 1574:            CFE_EVS_SendEvent(FM_GET_DIR_FILE_OS_ERR_EID, CFE_EVS_ERROR,
        -: 1575:               "%s error: OS_write update stats failed: result = %d, expected = %d",
        -: 1576:                CmdText, (int)BytesWritten, (int)WriteLength);
        -: 1577:        }
        -: 1578:    }
        -: 1579:
        -: 1580:    /* Send command completion event (info) */
        5: 1581:    if (CommandResult == TRUE)
        -: 1582:    {
        3: 1583:        FM_GlobalData.ChildCmdCounter++;
        -: 1584:
        3: 1585:        CFE_EVS_SendEvent(FM_GET_DIR_FILE_CMD_EID, CFE_EVS_DEBUG,
        -: 1586:           "%s command: wrote %d of %d names: dir = %s, filename = %s",
        -: 1587:            CmdText, (int)FileEntries, (int)DirEntries, Directory, Filename);
        -: 1588:    }
        -: 1589:
        5: 1590:    return;
        -: 1591:
        -: 1592:} /* End of FM_ChildDirListFileLoop */
        -: 1593:
        -: 1594:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -: 1595:/*                                                                 */
        -: 1596:/* FM child task utility function -- get dir entry size and time   */
        -: 1597:/*                                                                 */
        -: 1598:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -: 1599:
        8: 1600:int32 FM_ChildSizeTimeMode(const char *Filename, uint32 *FileSize, uint32 *FileTime, uint32 *FileMode)
        -: 1601:{
        -: 1602:    int32       Result;
        -: 1603:    os_fstat_t  FileStatus;
        -: 1604:    uint32      FileStatTime;
        -: 1605:
        8: 1606:    CFE_PSP_MemSet(&FileStatus, 0, sizeof(os_fstat_t));
        -: 1607:
        8: 1608:    Result = OS_stat(Filename, &FileStatus);
        -: 1609:
        8: 1610:    if (Result != OS_SUCCESS)
        -: 1611:    {
        1: 1612:        *FileSize = 0;
        1: 1613:        *FileTime = 0;
        -: 1614:    }
        -: 1615:    else
        -: 1616:    {
        7: 1617:        FileStatTime = FileStatus.st_mtime;
        -: 1618:
        -: 1619:        /* Convert the file system time to spacecraft time */
        7: 1620:        *FileTime = CFE_TIME_FS2CFESeconds(FileStatTime);
        -: 1621:
        7: 1622:        *FileSize = FileStatus.st_size;
        -: 1623:        
        7: 1624:        *FileMode = FileStatus.st_mode;
        -: 1625:        
        -: 1626:    }
        -: 1627:
        8: 1628:    return(Result);
        -: 1629:
        -: 1630:} /* End of FM_ChildSizeTimeMode */
        -: 1631:
        -: 1632:
        -: 1633:
        -: 1634:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -: 1635:/*                                                                 */
        -: 1636:/* FM child task utility function -- sleep between OS_stat on files*/
        -: 1637:/*                                                                 */
        -: 1638:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -: 1639:
        7: 1640:void FM_ChildSleepStat(const char *Filename, FM_DirListEntry_t *DirListData, int32 *FilesTillSleep, boolean getSizeTimeMode)
        -: 1641:{
        -: 1642:    /* Check if command requested size and time */
        7: 1643:    if (getSizeTimeMode == TRUE)
        -: 1644:    {
        6: 1645:        if (*FilesTillSleep <= 0)
        -: 1646:        {
        5: 1647:            CFE_ES_PerfLogExit(FM_CHILD_TASK_PERF_ID);
        5: 1648:            OS_TaskDelay(FM_CHILD_STAT_SLEEP_MS);
        5: 1649:            CFE_ES_PerfLogEntry(FM_CHILD_TASK_PERF_ID);
        5: 1650:            *FilesTillSleep = FM_CHILD_STAT_SLEEP_FILECOUNT;
        -: 1651:        }
        -: 1652:
        -: 1653:        /* Get file size, date, and mode */
        6: 1654:        FM_ChildSizeTimeMode(Filename, &(DirListData->EntrySize),
        -: 1655:                            &(DirListData->ModifyTime),
        -: 1656:                            &(DirListData ->Mode));
        -: 1657:        
        6: 1658:        (*FilesTillSleep)--;
        -: 1659:    }
        -: 1660:    else
        -: 1661:    {
        1: 1662:        DirListData->EntrySize  = 0;
        1: 1663:        DirListData->ModifyTime = 0;
        1: 1664:        DirListData->Mode       = 0;
        -: 1665:    }
        7: 1666:} /* FM_ChildSleepStat */
        -: 1667:
        -: 1668:/************************/
        -: 1669:/*  End of File Comment */
        -: 1670:/************************/
        -: 1671:
